<!DOCTYPE html>
<html><head>
<meta charset="UTF-8" /> 
<script src="webcamjs_mitLicense_1.0.24.js"></script>
<script src="gpujs_browser_mitLicense_2.11.0.js"></script>
<script>
//This code is opensource MIT license, by Ben F Rayfield 2021-7+, or someone may have forked after that.

"use strict";

var theGpu = null;

var gpu = function(){
	if(!theGpu) theGpu = new GPU(); //gpu*.js
	return theGpu;
};


//2 canvases of same size. webcam goes in a <video> dom object which is copied to canvasIn, then preprocessing (flip horizontal, etc),
//then Sim.io(dt,byteRectIn,byteRectOut) reads canvasIn, does physics/energy calculations, and writes canvasOut,
//then repeat many times per second for realtime augmented reality using webcam.
//ODO Sim.io use GPU.js optimization for springs and nonlinear color pull on voxel near those pixels.
var canvasInContext = null;
var canvasOutContext = null;
var canvasInImageData = null;
var canvasOutImageData = null;
var canvasInPixels = null;
var canvasOutPixels = null;
var canvasIn = null;
var canvasOut = null;
var byteRectIn = null;
var byteRectOut = null;

//utc seconds
var time = function(){
	return Date.now()*.001;
};

var updateCanvasObjects = function(){
	canvasIn = document.getElementById('canvasIn');
	canvasOut = document.getElementById('canvasOut');
	if((canvasIn.width != canvasOut.width) || (canvasIn.height != canvasOut.height)) throw 'Diff size canvases, canvasIn and canvasOut';
	canvasInContext = canvasIn.getContext('2d');
	canvasOutContext = canvasOut.getContext('2d');
	canvasInImageData = canvasInContext.getImageData(0, 0, canvasIn.width, canvasIn.height);
	canvasOutImageData = canvasOutContext.getImageData(0, 0, canvasOut.width, canvasOut.height);
	canvasInPixels = canvasInImageData.data;
	canvasOutPixels = canvasOutImageData.data;
	byteRectIn = new ByteRect(canvasInPixels, canvasIn.height, canvasIn.width);
	byteRectOut = new ByteRect(canvasOutPixels, canvasOut.height, canvasOut.width);
	//console.log('updateCanvasObjects done.');
};

const AX = 0; //affineTransform X
const AY = 1; //affineTransform Y
const AZ = 2; //affineTransform Z
const AS = 3; //affineTransform S. TODO rename to M for Move or P for position.

const AXX = AX*4+AX; //affineTransform X->X (FIXME or is it <- ?)
const AXY = AX*4+AY;
const AXZ = AX*4+AZ;
const AXS = AX*4+AS;
const AYX = AY*4+AX;
const AYY = AY*4+AY;
const AYZ = AY*4+AZ;
const AYS = AY*4+AS;
const AZX = AZ*4+AX;
const AZY = AZ*4+AY;
const AZZ = AZ*4+AZ;
const AZS = AZ*4+AS;
const ASX = AS*4+AX;
const ASY = AS*4+AY;
const ASZ = AS*4+AZ;
const ASS = AS*4+AS; //TODO rename S to O for offset or P for position, or something like that. its not scale. its for position.

//byte offsets for ByteRect, canvas, etc, in js.
const RED = 0, GREEN = 1, BLUE = 2, ALPHA = 3; //ALPHA isnt used in voxels, so another const also equals alpha's constant.
var colorDimRed = RED;
var colorDimGreen = GREEN;
var colorDimBlue = BLUE;
var colorDimAlpha = ALPHA; //these colorDim* vars are from older code. todo replace them with RED GREEN BLUE ALPHA.

//FIXME position and velocity for all such vars? or just for VX VY VZ?

const NUMWEBCAMS = 1;

//voxel dim indexs
const VRED = RED;
const VGREEN = GREEN;
const VBLUE = BLUE;
//const VHEAT = 3; //store heat energy here, moved from spring-dampening friction and velocity decay etc, and adjacent voxels/springs, and taken from here when need to move more.
const VX = 3;
const VY = 4;
const VZ = 5;
//index of the first of n webcams (by default is just 1), which each have a color dim of how much they can see each voxel, so what they see next pushes on those and not whats hidden (from their view) behind other voxels.
//screens count as webcams that do statsistical inference in reverse to generate pixels from voxels instead of generate/update voxels from pixels.
const VWEBCAMS = 6; //index of first webcam. //TODO rename to VWEBCAMSTART
const VLASTWEBCAM = VWEBCAMS+NUMWEBCAMS-1; //index of last webcam.
const VARSPERVOXEL = VLASTWEBCAM+1;

//spring dim indexs
//
//OLD (cuz created SWEAK, which used to always be 0):
//sstrength multiplies how much the spring accelerates 2 voxels its between toward or away from eachother.
//This is how sparse springs fade in and out to change topology of the manifold of voxels.

const SWEAK = 0; //potentialEnergy of spring ranges SWEAK to SSTRENGTH.
const SSTRENGTH = 1;
//const SHEAT = 1; //store heat energy here, moved from spring-dampening friction and velocity decay etc, and adjacent voxels/springs, and taken from here when need to move more.
const SAVEDIST = 2; //this decays toward the average distance between the 2 voxels, so when they're near that distance, SSTRENGTH increases else decreases.
const SRESTLEN = 3; //the at-rest-length of the spring, its length if nothing is squashing or stretching it
const SFRICTION = 4; //spring-dampening-friction which resists change in the distance between the 2 ends
const SDOWNFROM = 5; //see comment in potentialEnergyOfSpring
const SWIDE = 6; //see comment in potentialEnergyOfSpring
const VARSPERSPRING = 7;
console.log('VARSPERSPRING='+VARSPERSPRING);

//B vars mean BALLVOXEL aka BAXEL, a point on the surface of a ball (such as a tennis ball with random curves drawn on it to make it easier for webcam to see it turning).
//BX BY and BZ are not included since Ball stores these densely in a rectangle array (Float32Array) that wraps around sphere surface.
const BRED = RED;
const BGREEN = GREEN;
const BBLUE = BLUE;
//index of first webcam. This color dim means how much this part of ball is visible to webcam, instead of on back side of ball or behind finger holding ball etc.
const BWEBCAMS = 3; //TODO rename to BWEBCAMSTART
const BLASTWEBCAM = BWEBCAMS+NUMWEBCAMS-1; //index of last webcam
const VARSPERBAXEL = BLASTWEBCAM+1;
console.log('VARSPERBAXEL='+VARSPERBAXEL);

//C vars are pixels in a circle in a ball.
const CRED = RED;
const CGREEN = GREEN;
const CBLUE = BLUE;
//attention, similar to webcamA webcamB webcamC... dims except this is how much influence it has when circles are compared
//to eachother for matching colors at a number of rotations (take the max match) same number as how many pixels in each circle.
//all circles have the same number of pixels, somewhere around 1/4..1/20 as big a circle as the equator of spheres.
const CATTEN = 3;
const VARSPERCIRCLE = CATTEN+1;
console.log('VARSPERCIRCLE='+VARSPERCIRCLE);



//readable and writable pixels as Uint8Array. A canvas is a kind of Uint8Array.
//Single pixel read and write funcs are slow unless you just do a few places.
//TODO Write horizontal lines of same color or 2 colors on end interpolating between,
//and these lines can be derived from triangle which has different color at each corner.
var ByteRect = function(bytes, height, width){
	this.bytes = bytes;
	this.height = height;
	this.width = width;
};

//TODO choose [y x] vs [x y z scale] order. Swap y and x in ByteRect params order? aftrans is [x y z scale].

ByteRect.prototype.index = function(y, x, colorDim){
	return (y*this.width+x)*4+colorDim;
};

ByteRect.prototype.read = function(y, x, colorDim){
	return this.bytes[(y*this.width+x)*4+colorDim];
};

//TODO bilinear interpolation for smoother color?
ByteRect.prototype.readSafe = function(y, x, colorDim){
	return this.bytes[betweenInt(0,(Math.round(y)*this.width+Math.round(x))*4+colorDim,this.bytes.length-1)];
};

ByteRect.prototype.readBrightnessSafe = function(y, x){
	let i = between(0, (Math.round(y)*this.width+Math.round(x))*4, this.bytes.length-4);
	return (this.bytes[i+RED]+this.bytes[i+GREEN]+this.bytes[i+BLUE])/3;
};

/** same as readBrightnessSafe but as Float32Array whose length is this.bytes.length/4. a copy, not backing. */
ByteRect.prototype.brightnessFloats = function(y, x){
	let ret = new Float32Array(this.bytes.length/4);
	let i = 0;
	for(let j=0; j<this.bytes.length; j+=4){
		ret[i++] = (this.bytes[j+RED]+this.bytes[j+GREEN]+this.bytes[j+BLUE])/3;
	}
	return ret;
};

ByteRect.prototype.write = function(y, x, colorDim, bright){
	this.bytes[(y*this.width+x)*4+colorDim] = bright;
};

ByteRect.prototype.writeSafe = function(y, x, colorDim, bright){
	this.bytes[between(0,(Math.round(y)*this.width+Math.round(x))*4+colorDim,this.bytes.length-1)] = bright;
};

ByteRect.prototype.writeSafeRGBA = function(y, x, redByte, greenByte, blueByte, optionalAlphaByte){
	if(optionalAlphaByte === undefined) optionalAlphaByte = 255; //visible
	let index = between(0,(Math.round(y)*this.width+Math.round(x))*4,this.bytes.length-4);
	this.bytes[index+RED] = redByte;
	this.bytes[index+GREEN] = greenByte;
	this.bytes[index+BLUE] = blueByte;
	this.bytes[index+ALPHA] = optionalAlphaByte;
};

ByteRect.prototype.writeSafeBright = function(y, x, brightByte){
	let index = between(0,(Math.round(y)*this.width+Math.round(x))*4,this.bytes.length-4);
	this.bytes[index+RED] = brightByte;
	this.bytes[index+GREEN] = brightByte;
	this.bytes[index+BLUE] = brightByte;
	this.bytes[index+ALPHA] = 255;
};

ByteRect.prototype.atYXWriteRGB = function(y, x, redByte, greenByte, blueByte){
	let ind = (y*this.width+x)*4;
	this.bytes[ind+RED] = redByte;
	this.bytes[ind+GREEN] = greenByte;
	this.bytes[ind+BLUE] = blueByte;
};

ByteRect.prototype.writeHoriz = function(y, fromX, toXExclusive, colorDim, fromBright, toBright){
	var indexStart = this.index(y, fromX, colorDim);
	var pixelSiz = toXExclusive-fromX;
	var siz = pixelSiz*4;
	var bright = fromBright;
	var brightAdd = (toBright-fromBright)/pixelSiz;
	for(var i=0; i<siz; i+=4){
		bright += brightAdd;
		this.bytes[indexStart+i] = Math.floor(bright) & 0xff;
	}
};

ByteRect.prototype.flipHorizontal = function(){
	let bytes = this.bytes;
	for(let y=0; y<this.height; y++){
		let xMid = Math.floor(this.width/2);
		let offsetA = y*this.width*4; //first byte index of first pixel in row
		let offsetB = ((y+1)*this.width-1)*4; //first byte of last pixel in row
		for(let x=0; x<xMid; x++){
			for(let colorDim=0; colorDim<4; colorDim++){ //swap 2 pixels as 4 bytes each
				let temp = bytes[offsetA+colorDim];
				bytes[offsetA+colorDim] = bytes[offsetB+colorDim];
				bytes[offsetB+colorDim] = temp;
			}
			offsetA += 4;
			offsetB -= 4;
		}
	}
};

ByteRect.prototype.verifySameSizeAs = function(byteRect){
	if(!byteRect) throw 'Param ByteRect = '+byteRect;
	if(this.height != byteRect.height) throw this.height+' == this.height != byteRect.height == '+byteRect.height;
	if(this.width != byteRect.width) throw this.width+' == this.width != byteRect.width == '+byteRect.width;
};

ByteRect.prototype.loopAve = function(loopSize, firstByteIndex, addByteIndex){
	let sum = 0;
	let i = firstByteIndex;
	for(let a=0; a<loopSize; a++){
		sum += this.bytes[i];
		i += addByteIndex;
	}
	return sum/loopSize;
};

ByteRect.prototype.loopFractionOfBytesThatAreAtLeastVal = function(loopSize, firstByteIndex, addByteIndex, brightnessIsAtLeastThisByteVal){
	let count = 0;
	let i = firstByteIndex;
	for(let a=0; a<loopSize; a++){
		if(brightnessIsAtLeastThisByteVal <= this.bytes[i]) count++;
		i += addByteIndex;
	}
	return count/loopSize;
};

ByteRect.prototype.loopWriteByte = function(loopSize, firstByteIndex, addByteIndex, writeByteVal){
	let i = firstByteIndex;
	for(let a=0; a<loopSize; a++){
		this.bytes[i] = writeByteVal;
		i += addByteIndex;
	}
};

ByteRect.prototype.loopWriteBlack = function(loopSize, firstByteIndex, addByteIndex){
	let i = firstByteIndex;
	for(let a=0; a<loopSize; a++){
		this.bytes[i+RED] = 0;
		this.bytes[i+GREEN] = 0;
		this.bytes[i+BLUE] = 0;
		i += addByteIndex;
	}
};

/** stdDev of looping over bytes (a row or column and colorDim).
optionalAve is from loopAve or as optional param it computes that.
*/
ByteRect.prototype.loopDev = function(loopSize, firstByteIndex, addByteIndex, optionalAve){
	if(optionalAve === undefined) optionalAve = this.loopAve(byteRect, firstByteIndex, addByteIndex);
	let sumOfSquares = 0;
	let i = firstByteIndex;
	for(let a=0; a<loopSize; a++){
		let diff = this.bytes[i]-optionalAve;
		sumOfSquares += diff*diff;
		i += addByteIndex;
	}
	return Math.sqrt(sumOfSquares/loopSize);
};

/** ave brightness of a certain row and [RED, GREEN, BLUE, or ALPHA]. Range 0 to 255. */
ByteRect.prototype.rowAve = function(y, colorDim){
	return this.loopAve(this.width, y*this.width*4+colorDim, 4);
};

/** stdDev of brightness of a certain row and [RED, GREEN, BLUE, or ALPHA]. Range 0 to 255. */
ByteRect.prototype.rowDev = function(y, colorDim, optionalAve){
	return this.loopDev(this.width, y*this.width*4+colorDim, 4, optionalAve);
};

/** ave brightness of a certain column and [RED, GREEN, BLUE, or ALPHA]. Range 0 to 255. */
ByteRect.prototype.colAve = function(x, colorDim){
	return this.loopAve(this.height, x*4+colorDim, this.width*4);
};

/** stdDev of brightness of a certain column and [RED, GREEN, BLUE, or ALPHA]. Range 0 to 255. */
ByteRect.prototype.colDev = function(x, colorDim, optionalAve){
	return this.loopDev(this.height, x*4+colorDim, this.width*4, optionalAve);
};

ByteRect.prototype.setRowAndColordimToByte = function(y, colorDim, byteVal){
	this.loopWriteByte(this.width, y*this.width*4+colorDim, 4, byteVal);
};

ByteRect.prototype.setColAndColordimToByte = function(x, colorDim, byteVal){
	this.loopWriteByte(this.height, x*4+colorDim, this.width*4, byteVal);
};

ByteRect.prototype.rowFractionOfBytesThatAreAtLeastVal = function(y, colorDim, brightnessIsAtLeastThisByteVal){
	return this.loopFractionOfBytesThatAreAtLeastVal(this.width, y*this.width*4+colorDim, 4, brightnessIsAtLeastThisByteVal);
};

ByteRect.prototype.colFractionOfBytesThatAreAtLeastVal = function(x, colorDim, brightnessIsAtLeastThisByteVal){
	return this.loopFractionOfBytesThatAreAtLeastVal(this.height, x*4+colorDim, this.width*4, brightnessIsAtLeastThisByteVal);
};

ByteRect.prototype.setRowToBlack = function(y){
	this.loopWriteBlack(this.width, y*this.width*4, 4);
};

ByteRect.prototype.setColToBlack = function(x){
	this.loopWriteBlack(this.height, x*4, this.width*4);
};

//centerY, centerX, and radius can be scalars. Does bounds checking
var paintDonut = function(byteRect, centerY, centerX, minRadius, maxRadius, redByte, greenByte, blueByte){
	if(minRadius > maxRadius) throw 'minRadius='+minRadius+' maxRadius='+maxRadius;
	var minYI = Math.max(0, Math.min(Math.floor(centerY-maxRadius), byteRect.height-1));
	var maxYI = Math.max(0, Math.min(Math.ceil(centerY+maxRadius), byteRect.height-1));
	var minXI = Math.max(0, Math.min(Math.floor(centerX-maxRadius), byteRect.width-1));
	var maxXI = Math.max(0, Math.min(Math.ceil(centerX+maxRadius), byteRect.width-1));
	var minRadiusSq = minRadius*minRadius;
	var maxRadiusSq = maxRadius*maxRadius;
	for(var y=minYI; y<=maxYI; y++){
		var i = byteRect.index(y, minXI, 0);
		for(var x=minXI; x<=maxXI; x++){
			var dy = y-centerY;
			var dx = x-centerX;
			let sq = dy*dy + dx*dx;
			if((minRadiusSq <= sq) && (sq <= maxRadiusSq)){
				//TODO optimize by skipping parts where this isnt true, in the loop before getting here.
				byteRect.bytes[i+colorDimRed] = redByte;
				byteRect.bytes[i+colorDimGreen] = greenByte;
				byteRect.bytes[i+colorDimBlue] = blueByte;
			}
			i += 4;
		}
	}
};

ByteRect.prototype.paintLineYXYXRGB = function(fromY, fromX, toY, toX, redByte, greenByte, blueByte){
	let diffY = toY-fromY;
	let diffX = toX-fromX;
	let len = Math.hypot(diffY, diffX);
	let numPoints = Math.ceil(len*1.5);
	for(let i=0; i<numPoints; i++){
		//TODO optimize
		let y = Math.round(fromY+diffY*i/numPoints);
		let x = Math.round(fromX+diffX*i/numPoints);
		this.atYXWriteRGB(y, x, redByte, greenByte, blueByte);
	}
};

ByteRect.prototype.paintCircleRadiusYXRGBSafe = function(radius, cy, cx, redByte, greenByte, blueByte){
	let circle = 2*Math.PI;
	let numPoints = Math.ceil(radius*circle*1.5);
	let anglePerPoint = 2*Math.PI/numPoints;
	for(let i=0; i<numPoints; i++){
		let angle = anglePerPoint*i;
		let x = cx+radius*Math.cos(angle);
		let y = cy+radius*Math.sin(angle);
		this.writeSafeRGBA(y, x, redByte, greenByte, blueByte);
	}
};


var bytesToFloats = function(bytes){
	let floats = new Float32Array(bytes.length);
	for(let i=0; i<bytes.length; i++) floats[i] = bytes[i];
	return floats;
};

var floatsToBytes = function(floats){
	let bytes = new Uint8Array(floats.length);
	for(let i=0; i<bytes.length; i++) bytes[i] = floats[i];
	return bytes;
};

var floatsAsMonochromeToPic = function(floats, height, width){
	if(floats.length != height*width) throw 'floats.length='+floats.length+' height='+height+' width='+width+' are diff sizes';
	let ret = new ByteRect(new Uint8Array(floats.length*4), height, width);
	let outb = ret.bytes;
	let j = 0;
	for(let i=0; i<ret.bytes.length; i+=4){
		//let bright = floats[j++];
		let bright = asByte(floats[j++]);
		outb[i+RED] = bright;
		outb[i+GREEN] = bright;
		outb[i+BLUE] = bright;
		outb[i+ALPHA] = 255; //visible
	}
	return ret;
};

var isByteRect = function(b){
	return (b.bytes && b.height && b.width);
};


var floats2dToFloats1d = function(floats2d){
	let size = 0;
	for(let i=0; i<floats2d.length; i++) size += floats2d[i].length;
	let ret = new Float32Array(size);
	let j = 0;
	for(let i=0; i<floats2d.length; i++){
		let innerFloats = floats2d[i];
		for(let k=0; k<innerFloats.length; k++){ //TODO optimize by range copy
			ret[j++] = innerFloats[k];
		}
	}
	return ret;
};


//distance between observed red and redness of voxel (r g b in param) moving near it. sqrt of sum of square diffs.
//Since colors range 0..255, distance ranges 0..sqrt(3*255^2)=441.6729559300637.
const maxPossibleColorDistance = Math.hypot(255,255,255);

//get y x velocity, given a certain color (of a voxel there), at an x, y, and rectangle_or_2d_bellcurve, to accel that voxel, and how to change its color
//View it as a 5d vector field of x y red green blue, or maybe 6d if you count the size of rectangle_or_2d_bellcurve but since it doesnt
//give a derivative for the size, maybe shouldnt include that. Also z dim (into or out of the screen) is a dim in other parts of the system but not here.
//TODO find a more efficient way to do this than 1 at a time and returning a new [5 numbers] each time, but this is early experiments.
//size param is normally 1-20 and must always be at least 1. size is 2*radius.
//r g b are 0..255. Derivatives returned are floats.
//0 <= y < byteRect.height.
//0 <= x < byteRect.width.
//OLD: If isPaintOver, then paints over the area observed, to show what its observing and the weights there.
//byteRectOutOrNull is null to not paint anything, or nonnull to paint at byteRectOutOrNull
ByteRect.prototype.yxrgbDerivs = function(size, y, x, r, g, b, byteRectOutOrNull){
	//FIXME if size is even, or x and y are not integers, then can pull a direction cuz of roundoff?
	//Or will it avoid that to compare weightedSum of x and y to the average x and y of the pixels measured
	//instead of comparing it to the param x and y?

	if(size < 1) throw 'size='+size;
	let radius = size/2;
	let radiusSquared = radius*radius;
	let xStart = Math.max(0,Math.round(x-size/2));
	let xEndExcl = Math.min(xStart+size,this.width);
	let yStart = Math.max(0,Math.round(y-size/2));
	let yEndExcl = Math.min(yStart+size,this.height);
	let numPixels = (yEndExcl-yStart)*(xEndExcl-xStart);
	//do it the simple square way for now, but bellcurve is better todo that
	let dy = 0;
	let dx = 0;
	let dr = 0;
	let dg = 0;
	let db = 0;
	let sumR = 0, sumG = 0, sumB = 0;
	let bytes = this.bytes;
	//use Math.pow (such as of 2 for leastSquares, or 2.1 for a little stronger matching (ignore more colors that differ slightly), 1 for linear, etc.
	let colorMatchExponent = 2;
	//let colorMatchExponent = 1;
	let sumYByWeight = 0;
	let sumXByWeight = 0;
	let sumWeight = 0;
	let aveYUnweighted = (yStart+(yEndExcl-1))/2;
	let aveXUnweighted = (xStart+(xEndExcl-1))/2;
	let paintBytes = (byteRectOutOrNull ? byteRectOutOrNull.bytes : null);
	for(let yy=yStart; yy<yEndExcl; yy++){
		for(let xx=xStart; xx<xEndExcl; xx++){
			let ptr = (yy*this.width+xx)*4; //pixel starts at which byte (and is 4 bytes)
			let rr = bytes[ptr+RED];
			let gg = bytes[ptr+GREEN];
			let bb = bytes[ptr+BLUE];
			sumR += rr;
			sumG += gg;
			sumB += bb;
			let colorDistanceFraction = Math.hypot(rr-r, gg-g, bb-b)/maxPossibleColorDistance;
			//weightedSum of colors accelerates voxel in x and y dims toward colors similar to its current color,
			//and TODO its current color is accelerated (or just decay toward?) toward whatever colors its near.
			let weight = Math.pow(1-colorDistanceFraction,colorMatchExponent);
			//let distanceXYFromCenterPointAskedAbout = Math.hypot(yy-aveYUnweighted, xx-aveXUnweighted);
			let diffY = yy-aveYUnweighted;
			let diffX = xx-aveXUnweighted;
			if(diffY*diffY + diffX*diffX <= radiusSquared){ //only whats inside the circle within radius of param 2d point, to be angle invariant.
			
				//let distanceSquaredXYFromCenterPointAskedAbout = diffY*diffY + diffX*diffX;
				//let weightMulForShapeOfMovingWindow = ((distanceSquaredXYFromCenterPointAskedAbout <= radiusSquared) ? 1 : 0);
				//weight *= weightMulForShapeOfMovingWindow;
			
			
				sumYByWeight += yy*weight;
				sumXByWeight += xx*weight;
				sumWeight += weight;
				if(paintBytes){
					//let mult = weight; //weight ranges 0 to 1 (or 0 to 1/sqrt(3) if norming color to sum to constant?)
					//let mult = weight*2; //FIXME
					/* //paint weight as grayscale
					paintBytes[ptr+RED] = weight*255;
					paintBytes[ptr+GREEN] = weight*255;
					paintBytes[ptr+BLUE] = weight*255;
					*/
					//paint weight as varying brightness of the color of the voxel
					paintBytes[ptr+RED] = weight*r;
					paintBytes[ptr+GREEN] = weight*g;
					paintBytes[ptr+BLUE] = weight*b;
				}
			}
		}
	}
	if(sumWeight > 0){
	//if(sumWeight > 10){ //FIXME
		let aveYByWeight = sumYByWeight/sumWeight;
		let aveXByWeight = sumXByWeight/sumWeight;
		dy += (aveYByWeight-aveYUnweighted)/size;
		dx += (aveXByWeight-aveXUnweighted)/size;
		let aveR = sumR/numPixels;
		let aveG = sumG/numPixels;
		let aveB = sumB/numPixels;
		dr += aveR-r; //diff of average color of the square of pixels observed and the param voxel color
		dg += aveG-g;
		db += aveB-b;
	}else{
		//console.log("yxrgbDerivs.sumWeight="+sumWeight);
	}
	return Float32Array.of(dy, dx, dr, dg, db);
};

var dom = (id)=>document.getElementById(id);

var prevTime = time();

var webcamFrames = 0;
var webcamFpsObserved = 1;

//targetSum is target red+green+blue to norm each pixel to. returns new ByteRect.
var normPixelsAllToSameBrightness = function(byteRect, targetSum){
	let inb = byteRect.bytes;
	let ret = new ByteRect(new Uint8Array(inb.length), byteRect.height, byteRect.width);
	let retb = ret.bytes;
	for(let i=0; i<inb.length; i+=4){
		let sum = inb[i+RED]+inb[i+GREEN]+inb[i+BLUE];
		if(sum == 0){
			let bright = targetSum/3;
			retb[i+RED] = bright;
			retb[i+GREEN] = bright;
			retb[i+BLUE] = bright;
		}else{
			let mul = targetSum/sum;
			retb[i+RED] = inb[i+RED]*mul;
			retb[i+GREEN] = inb[i+GREEN]*mul;
			retb[i+BLUE] = inb[i+BLUE]*mul;
		}
		retb[i+ALPHA] = 255; //visible
		//FIXME? floor ceil round range as its probably a Uint8ClampedArray?
	}
	return ret;
};

var take_snapshot = function(sim){
	// play sound effect
	//shutter.play();

	// take snapshot and get image data
	Webcam.snap(
		function(data_uri){
			let video = Webcam.video;
			if(video !== undefined){
				canvasInContext.drawImage(video, 0, 0, canvasIn.width, canvasIn.height);
				updateCanvasObjects();
				let now = time();
				let dt = now-prevTime;
				prevTime = now

				webcamFrames++;
				webcamFpsObserved = webcamFpsObserved*(1-dt) + 1; //TODO adjustable decay rate
				let fpsDisplay = (57 < webcamFpsObserved && webcamFpsObserved < 63) ? 'around 60 where it should be' : ''+webcamFpsObserved;
				dom('fpsLabel').innerHTML = 'fps='+fpsDisplay;

				byteRectIn.flipHorizontal(); //part of preprocessing
				//TODO move color norming here, so sim.io doesnt modify byteRectIn. part of preprocessing.
				if(sim.paintTestObjectsAsInput){
					//FIXME also paint them onto output (in sim.io(...) if !sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack ?
					paintTestsOntoByteRectIn(now,byteRectIn);
				}
				let pic = byteRectIn;
				let h = byteRectIn.height;
				let w = byteRectIn.width;
				if(sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU){
					//pic = normPixelsAllToSameBrightness(pic, 255);
					pic = normPixelsAllToSameBrightness(pic, 500);
				}
				if(sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU){
					pic = sim.doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls(pic);
				}
				if(sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG){
					let allowBytesIntoGpu = sim.allowBytesIntoGpuElseCopyBytesToFloats_thisMayBeBuggy;
					pic = sim.doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu(pic, true, allowBytesIntoGpu);
					//TODO optimize: let pic be monochrome Float32Array here (gpujs outputs that)
					//so preprocessPicToRemoveHorizontalAndVerticalLines_usingGpu can take Float32Array as input,
					//skipping a step of copying each float into 3 equal bytes then back to float.
				}
				
				if(sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic){
					//these lines seem to be caused by camera norming color in a grid of many small rectangles, and the
					//code to norm colors is so good that it finds them which are otherwise not much visible to the naked eye.
					sim.preprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic(
						pic, //modifies pic
						sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright,
						sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction
					);
				}
				if(sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_usingGpu){
					pic = sim.preprocessPicToRemoveHorizontalAndVerticalLines_usingGpu(
						pic, //this can be ByteRect or  (TODO?)[Float32Array as monochrome]
						h,
						w,
						sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright,
						sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction,
						true //isModifyByteRectIn
						//true //true return ByteRect (else Float32Array)
					);
				}
				
				if(pic != byteRectIn){
					copyBytes(pic.bytes, byteRectIn.bytes);
					//TODO optimize: by not creating another ByteRect?
					//TODO optimize: is bytaeRectIn from canvasIn? Does it need to be? Or just call sim.io(dt, pic, byteRectOut) to skip this copyBytes?
				}
				sim.io(dt, byteRectIn, byteRectOut);
				//canvasInContext.putImageData(canvasInImageData, 0, 0);
				canvasOutContext.putImageData(canvasOutImageData, 0, 0);
				//if((webcamFrames%10)==0) console.log("webcamFpsObserved="+webcamFpsObserved+"    frames="+webcamFrames+" time="+now);
			}
			// display results in page
			//document.getElementById('results').innerHTML =  '<img src="'+data_uri+'"/>';
		}
	);
};

var rrr=0;

var between = (min, val, max)=>Math.max(min,Math.min(val,max));

var betweenInt = (min, val, max)=>Math.round(Math.max(min,Math.min(val,max)));

var asByte = (x)=>Math.max(0,Math.min(Math.floor(x),255));

var warnIfStrangeDt = function(dt){
	//a good dt is .02 for 50 fps, or .01 is better, but anything less than .01 wont be much noticable improvement in graphics,
	//but it might improve the convergence of the physics energy equations
	//(springs, color matching, etc, all part of a single energy equation, TODO)
	//to run multiple physics/energy/puzzleSolving cycles per display/webcam cycle.
	if((dt <= 0) || (dt > .2)) console.log('dt='+dt);
};

var rand = function(min,max){
	return min+(max-min)*Math.random();
};

//0 to maxExcl-1, if 0<=maxExcl<approx_2pow53minusALittleForRoundoffSoMaybe2pow50 after that doubles cant represent all possible integers.
var randInt = (maxExcl)=>Math.floor(Math.random() * maxExcl);

/*var Slidebar = function(){
	this.getFraction = 
	<input type="range" id="vol" min="0" max="1000000" value="777777" oninput="console.log(this.valueAsNumber/1000000);">
};*/

//0..255
var randByte = ()=>Math.floor(Math.random()*256);

var onceRandomBytes = [];
var testPointEnabled = [];
for(let i=0; i<30000; i++){
	onceRandomBytes.push(randByte());
	//onceRandomBytes.push(Math.floor(Math.random()*256));
	testPointEnabled.push(true);
}

var paintTestsOntoByteRectIn = function(now, byteRect){
	let circleRadius = 15;
	let which_onceRandomBytes = 0;
	let isDisplaying = true;
	let numTestPoints = 70;
	let freq = .05; //turns of this test object per second
	/*if(Math.random()<.15){
		for(let j=0; j<numTestPoints; j++){
			if(Math.random() < .3){
				//randomly display or not display some parts of this object, to test if the voxels move there anyways cuz of springs
				isDisplaying = !isDisplaying;
			}
			testPointEnabled[j] = isDisplaying;
		}
	}*/
	for(let i=0; i<numTestPoints; i++){
		
		if(testPointEnabled[i]){
			let a = 2*Math.PI*(i/numTestPoints+now*freq);
			let yFraction = .5+.3*Math.sin(a);
			let xFraction = .5+.3*Math.cos(a);
			let red = onceRandomBytes[which_onceRandomBytes];
			let green = onceRandomBytes[which_onceRandomBytes+1];
			let blue = onceRandomBytes[which_onceRandomBytes+2];
			paintDonut(
				byteRect,
				byteRect.height*yFraction,
				byteRect.width*xFraction,
				0, //inner radius
				circleRadius,
				red,
				green,
				blue
			);
		}
		which_onceRandomBytes += 3;
	}
};

//These epsilons are meant to be multiplied by the number they're used with, like if distance between 2 voxels is 507.3
//and you want potentialEnergy derivative there, use 507.3 and 507.3*(1+EPSILON) and divide that difference by EPSILON,
//else you will (more often than not, probably) lose more precision than the EPSILON was designed for, compared to 507.3+EPSILON.
//
const EPSILON_FOR_FLOAT = Math.pow(.5,13); //float is exact for all integers in plus/minus 2^24. Browser GPU.js uses floats, unknown if its IEEE754 deterministic.
const EPSILON_FOR_DOUBLE = Math.pow(.5,27); //double is exact for all integers in plus/minus 2^53. Unknown if browser javascript is IEEE754 deterministic.
const EPSILON = EPSILON_FOR_FLOAT; //even though using doubles 2021-7-25, planning to use GPU.js which creates Float32Arrays.

/** 4x4 identityFunc affine transform */
var newIdentAftrans = function(){
	let a = new Float32Array(16);
	a[AXX] = 1;
	a[AYY] = 1;
	a[AZZ] = 1;
	a[ASS] = 1;
	return a;
};

var newRandAftransNearIdent = function(){
	let a = newIdentAftrans();
	for(let i=0; i<a.length; i++){
		a[i] += .1*(Math.random()*2-1);
	}
	return a;
};

var newRandAftrans = function(){
	let a = new Float32Array(16);
	for(let i=0; i<a.length; i++){
		a[i] = Math.random()*4-2; //-2 to 2. TODO unit bellcurve
	}
	return a;
};

var defaultNumAnglesOfCircle = 100;

var newCirclePixels = function(optionalNumAngles, optionalRedByte, optionalGreenByte, optionalBlueByte, optionalAttention){
	if(!optionalNumAngles) optionalNumAngles = defaultNumAnglesOfCircle;
	verifyNumAngles(optionalNumAngles,true); //true allow odd
	this.numAngles = optionalNumAngles;
	
	if(!optionalRedByte) optionalRedByte = randByte();
	if(!optionalGreenByte) optionalGreenByte = randByte();
	if(!optionalBlueByte) optionalBlueByte = randByte();
	if(!optionalAttention) optionalAttention = 1;
	let a = new Float32Array(optionalNumAngles*VARSPERCIRCLE); //TODO rename VARSPERCIRCLE to mean vars per pixel in a circle
	for(let i=0; i<a.length; i+=VARSPERCIRCLE){
		a[i+CRED] = optionalRedByte;
		a[i+CGREEN] = optionalGreenByte;
		a[i+CBLUE] = optionalBlueByte;
		a[i+CATTEN] = optionalAttention;
	}
	return a;
};

var verifyNumAngles = function(numAngles, optionalAllowOdd){
	if(!optionalAllowOdd) optionalAllowOdd = false; //TODO remove this line? !undefined and !false are both true
	if((numAngles < 8) || (4096 < numAngles)) throw 'numAngles='+numAngles+' is far too small or big';
	if(optionalAllowOdd){
		if(numAngles != Math.floor(numAngles)) throw 'Not integer, numAngles='+numAngles;
	}else{
		if((numAngles&1) != 0) throw 'Not even, numAngles='+numAngles;
	}
};

var verifyAftrans = function(aftrans){
	if(!aftrans) throw 'aftrans='+aftrans;
	//if(!(aftrans.length)) throw 'aftrans.length='+aftrans.length;
	if(aftrans.length != 16) throw 'aftrans.length='+aftrans.length+' but must be 16 cuz 4x4';
};

const emptyArray = new Float32Array(0);

//ab is Float32Array(a*b). bc is Float32Array(b*c). Returns Float32Array(a*c).
//TODO GPU.js if its big, but might want to merge multiple kernels to happen at once for intheory lower lag.
//Theres some func to "combine kernels" in GPU.js.
var matmul = function(ab, bc, a, b, c){
	return matmulCpu(ab, bc, a, b, c);
};

var aftransOfAftrans = function(outerAftrans, innerAftrans){
	//FIXME is this right? Use transpose or not? Swap the order of outer and inner?
	//return matmul(outerAftrans,transpose4x4(innerAftrans),4,4,4);
	return matmul(outerAftrans,innerAftrans,4,4,4);
};

var copyBytes = function(bytesIn, bytesOut){
	for(let i=0; i<bytesOut.length; i++){
		bytesOut[i] = bytesIn[i];
	}
};

/*
//matmul(aftransA,aftransB,4,4,4) them in sequence, or identityFunc if theres none of them
var aftransOfAftrans = function(...aftranses){
	if(aftranses.length == 0) return newIdentAftrans();
	let a = aftranses[0];
	for(let i=1; i<aftranses.length; i++){
		a = matmul(a,aftranses[i],4,4,4);
	}
	return a;
};*/

var matmulCpu = function(ab, bc, aSize, bSize, cSize){
	let ret = new Float32Array(aSize*cSize);
	for(let a=0; a<aSize; a++){
		for(let c=0; c<cSize; c++){
			//TODO this will be most of the GPU code in matmulGpu:
			let sum = 0; //double*double then cast to float differs from [float*float which is intheory what you get in GPU.js. TODO align with lazycl]
			for(let b=0; b<bSize; b++){
				sum += ab[a*bSize+b]*bc[b*cSize+c];
			}
			ret[a*cSize+c] = sum;
		}
	}
	return ret;
};

var matmulGpu = function(ab, bc, a, b, c){
	throw 'TODO';
};

/** TODO just do matmul instead. need way to mark a Float32Array as an array instead of a 1d.
//aftrans is a Float32Array(16). points is a Float32Array(any multiple of 4). Modifies points to transform those.
var aftransPoints = function(aftrans, points){
	let temp = new Float32Array(4);
	for(let p=0; p<points.length; p+=4){
		for(let n=0; n<4; n++){
			for(let m=0; m<4; m++){
			temp[d] 
			FIXME
		}
	}
};
*/



/** a circle of cached (bilinear-interpolated?) pixels viewed at sphere surface points on a Ball,
from a certain center point on its surface and a certain radius (surface distance? or from center of circle in 3d?),
which is a cache of the rectangle of pixels (baxels) wrapped around the sphere surface.
The circle has CATTEN (attention at that pixel in circle 1d coordinates) and has low CATTEN for things at a sharp angle
viewed near edges of sphere they're so thin cant see much there, while sideways along that same part of circle can be much higher CATTEN
cuz its how much distance on 2d screen vs distance in circle coordinates.
*/
var Circle = function(numAngles, optionalAftrans, optionalPixels){
	this.numAngles = numAngles;

	if(!optionalAftrans) optionalAftrans = newIdentAftrans();
	this.aftrans = optionalAftrans;
	
	if(!optionalPixels) optionalPixels = newCirclePixels(numAngles);
	this.pixels = optionalPixels;

	//OLD...
	//FIXME what datastruct for CIRCLE? Its an array of C vars but also an aftrans (4x4? 4x3? rel to the ball or absolute?) Should it be its own class?
	//Or should it all go in 1 Float32Array for the C vars and 1 Float32Array for the aftranses?
	//How will that go into GPU.js, when calling a func to find the aftrans that best aligns 2 Balls?
	//The CIRCLES  are stored in Ball, and Balls stored in Sim, so the circles and balls can be displayed on screen for debugging.
	//If I put it in separate Circle objects, with a Float32Array(16) (the 4x4 aftrans) and a Float32Array(VARSPERC..something * circlesizesomething)
	//could be put in [aftranses] and [pixelsEtc] as 2 of 2d arrays. GPU.js can do 2d arrays. Yes do that.
	//...  this.circles = 
	//TODO
};

//Circle doesnt have childs, but here for consistency of the this.childs[whichChild].aftrans being relative to this.aftrans.
Circle.prototype.childs = emptyArray;

var transpose4x4 = function(aftrans){
	let a = new Float32Array(16);
	for(let i=0; i<4; i++){
		for(let j=0; j<4; j++){
			a[4*i+j] = aftrans[4*j+i];
		}
	}
	return a;
};


/** matrix inverse for Float32Array. FIXME this doesnt seem to work.
OLD: FIXME might not be invertible matrixs. Are most invertible? Seems to have zeros often in the aftrans.
...
Might be working now, but I had to change the 0s to 1s, which I maybe could change them to .00001 instead,
and maybe leave some of them as 0s, but it seems that might interfere with what I'm using them for (positioning balls nad other 3d objects).
Float32Array(16) [40, -40, 0, 0, 40, 80, 0, 0, 50, -40, 10, 0, 190, 200, 0, 0]
for(i in af) if(af[i] == 0) af[i] = 1
1
inverse4x4(af)
Float32Array(16) [0.006666666828095913, -0.013333333656191826, -0, 0.006666666828095913, -0.008333333767950535, 0.008333333767950535, -0, -0, -0.11851851642131805, 0.014814814552664757, 0.1111111119389534, -0.007407407276332378, 0.5185185074806213, 0.8518518805503845, -0.1111111119389534, -0.25925925374031067]
aftransOfAftrans(inverse4x4(af),af)
Float32Array(16) [1, 0, 0, 0, 0, 1, 0, 0, 1.3969838619232178e-7, -1.1175870895385742e-7, 1, 2.7939677238464355e-9, 0.0000017136335372924805, 0.000003874301910400391, 1.4901161193847656e-8, 1]
..
af
Float32Array(16) [38.17185974121094, -37.34263610839844, 0.567450225353241, 0.9653493165969849, 44.762725830078125, 75.62342834472656, 2.032400608062744, 1.092972755432129, 47.32026290893555, -49.86602020263672, 9.876603126525879, 0.9346176981925964, 314.396484375, 233.5746307373047, 4.626655578613281, 4.095148086547852]
aftransOfAftrans(af,inverse4x4(af))
Float32Array(16) [1, -2.8939762586333018e-8, -6.901840432504969e-9, 6.330946877852739e-9, 6.891576731504756e-8, 0.9999999403953552, -4.097648442780155e-9, 7.388507139438616e-9, 2.5632354905269494e-8, -1.2609987720679783e-8, 1, 7.609613383863234e-9, 2.213476051338148e-7, -1.2695329587586457e-7, -1.5567275468697517e-8, 1.0000001192092896]
aftransOfAftrans(inverse4x4(af),af)
Float32Array(16) [1.0000001192092896, 6.570027011321145e-8, 1.0449441312232466e-9, 1.00316499551667e-9, 1.7116050798904325e-8, 1, 6.754415915466438e-10, 4.2082873297211165e-10, 2.8648202032854897e-8, 9.683519408554275e-8, 1, 1.570354069002633e-9, -0.0000015082332538440824, -0.000004397804332256783, -1.0071694589441904e-7, 1]
..

got this from wolframalpha "inverse {{a, b, c, d}, {e, f, g, h}, {i, j, k, l}, {m, n, o, p}}"
1/(a f k p - a f l o - a g j p + a g l n + a h j o - a h k n - b e k p + b e l o + b g i p - b g l m - b h i o + b h k m + c (e j p - e l n - f i p + f l m + h i n - h j m) + d (-e j o + e k n + f i o - f k m - g i n + g j m))(f k p - f l o - g j p + g l n + h j o - h k n | -b k p + b l o + c j p - c l n - d j o + d k n | b g p - b h o - c f p + c h n + d f o - d g n | -b g l + b h k + c f l - c h j - d f k + d g j
-e k p + e l o + g i p - g l m - h i o + h k m | a k p - a l o - c i p + c l m + d i o - d k m | -a g p + a h o + c e p - c h m - d e o + d g m | a g l - a h k - c e l + c h i + d e k - d g i
e j p - e l n - f i p + f l m + h i n - h j m | -a j p + a l n + b i p - b l m - d i n + d j m | a f p - a h n - b e p + b h m + d e n - d f m | -a f l + a h j + b e l - b h i - d e j + d f i
-e j o + e k n + f i o - f k m - g i n + g j m | a j o - a k n - b i o + b k m + c i n - c j m | -a f o + a g n + b e o - b g m - c e n + c f m | a f k - a g j - b e k + b g i + c e j - c f i)
//FIXME theres whitespace instead of | where the newline is, as it displayed as 4 lines in the 4x4 part.
https://www.wolframalpha.com/input/?i=inverse+%7B%7Ba%2C+b%2C+c%2C+d%7D%2C+%7Be%2C+f%2C+g%2C+h%7D%2C+%7Bi%2C+j%2C+k%2C+l%7D%2C+%7Bm%2C+n%2C+o%2C+p%7D%7D
*/
var inverse4x4 = function(aftrans){
	//FIXME what if theres a divide by 0? does it mean its not an invertible matrix?
	let a = aftrans[0];
	let b = aftrans[1];
	let c = aftrans[2];
	let d = aftrans[3];
	let e = aftrans[4];
	let f = aftrans[5];
	let g = aftrans[6];
	let h = aftrans[7];
	let i = aftrans[8];
	let j = aftrans[9];
	let k = aftrans[10];
	let l = aftrans[11];
	let m = aftrans[12];
	let n = aftrans[13];
	let o = aftrans[14];
	let p = aftrans[15];
	let W = a*f*k*p - a*f*l*o - a*g*j*p + a*g*l*n + a*h*j*o - a*h*k*n - b*e*k*p + b*e*l*o + b*g*i*p - b*g*l*m - b*h*i*o + b*h*k*m;
	let X = c*(e*j*p - e*l*n - f*i*p + f*l*m + h*i*n - h*j*m);
	let Y = d*(- e*j*o + e*k*n + f*i*o - f*k*m - g*i*n + g*j*m);
	let mul = 1/(W + X + Y);
	if(mul == Infinity) throw 'Not invertible matrix';
	//let add = W + c*X;
	//let mul = d*Y;
	/*return Float32Array.of(
		1/(add+(f*k*p - f*l*o - g*j*p + g*l*n + h*j*o - h*k*n)*mul),
		1/(add+( - b*k*p + b*l*o + c*j*p - c*l*n - d*j*o + d*k*n)*mul),
		1/(add+(b*g*p - b*h*o - c*f*p + c*h*n + d*f*o - d*g*n)*mul),
		1/(add+( - b*g*l + b*h*k + c*f*l - c*h*j - d*f*k + d*g*j)*mul),
		1/(add+( - e*k*p + e*l*o + g*i*p - g*l*m - h*i*o + h*k*m)*mul),
		1/(add+(a*k*p - a*l*o - c*i*p + c*l*m + d*i*o - d*k*m)*mul),
		1/(add+( - a*g*p + a*h*o + c*e*p - c*h*m - d*e*o + d*g*m)*mul),
		1/(add+(a*g*l - a*h*k - c*e*l + c*h*i + d*e*k - d*g*i)*mul),
		1/(add+(e*j*p - e*l*n - f*i*p + f*l*m + h*i*n - h*j*m)*mul),
		1/(add+( - a*j*p + a*l*n + b*i*p - b*l*m - d*i*n + d*j*m)*mul),
		1/(add+(a*f*p - a*h*n - b*e*p + b*h*m + d*e*n - d*f*m)*mul),
		1/(add+( - a*f*l + a*h*j + b*e*l - b*h*i - d*e*j + d*f*i)*mul),
		1/(add+( - e*j*o + e*k*n + f*i*o - f*k*m - g*i*n + g*j*m)*mul),
		1/(add+(a*j*o - a*k*n - b*i*o + b*k*m + c*i*n - c*j*m)*mul),
		1/(add+( - a*f*o + a*g*n + b*e*o - b*g*m - c*e*n + c*f*m)*mul),
		1/(add+(a*f*k - a*g*j - b*e*k + b*g*i + c*e*j - c*f*i)*mul)
	);*/
	return Float32Array.of(
		(f*k*p - f*l*o - g*j*p + g*l*n + h*j*o - h*k*n)*mul,
		( - b*k*p + b*l*o + c*j*p - c*l*n - d*j*o + d*k*n)*mul,
		(b*g*p - b*h*o - c*f*p + c*h*n + d*f*o - d*g*n)*mul,
		( - b*g*l + b*h*k + c*f*l - c*h*j - d*f*k + d*g*j)*mul,
		( - e*k*p + e*l*o + g*i*p - g*l*m - h*i*o + h*k*m)*mul,
		(a*k*p - a*l*o - c*i*p + c*l*m + d*i*o - d*k*m)*mul,
		( - a*g*p + a*h*o + c*e*p - c*h*m - d*e*o + d*g*m)*mul,
		(a*g*l - a*h*k - c*e*l + c*h*i + d*e*k - d*g*i)*mul,
		(e*j*p - e*l*n - f*i*p + f*l*m + h*i*n - h*j*m)*mul,
		( - a*j*p + a*l*n + b*i*p - b*l*m - d*i*n + d*j*m)*mul,
		(a*f*p - a*h*n - b*e*p + b*h*m + d*e*n - d*f*m)*mul,
		( - a*f*l + a*h*j + b*e*l - b*h*i - d*e*j + d*f*i)*mul,
		( - e*j*o + e*k*n + f*i*o - f*k*m - g*i*n + g*j*m)*mul,
		(a*j*o - a*k*n - b*i*o + b*k*m + c*i*n - c*j*m)*mul,
		( - a*f*o + a*g*n + b*e*o - b*g*m - c*e*n + c*f*m)*mul,
		(a*f*k - a*g*j - b*e*k + b*g*i + c*e*j - c*f*i)*mul
	);
};

/** given a Float32Array(prevCols*prevRows) viewed as [prevCols][prevRows], returns a new Float32Array to be viewed as [prevRows][prevCols]. */
var transpose = function(matrix, prevCols, prevRows){
	if(matrix.length != (prevCols*prevRows)) throw 'matrix.length='+matrix.length+' prevCols='+prevCols+' prevRows='+prevRows;
	let ret = new Float32Array(matrix.length);
	for(let pc=0; pc<prevCols; pc++){
		for(let pr=0; pr<prevRows; pr++){
			ret[pr*prevCols+pc] = matrix[pc*prevRows+pr];
		}
	}
	return ret;
};

//A point thats just an aftrans, displayed as 3 lines joined one one side for the 3 axis, red green and blue,
//and it can have any kind of child objects.
var AfPoint = function(optionalAftrans){
	if(!optionalAftrans) optionalAftrans = newIdentAftrans();
	this.aftrans = optionalAftrans;
	this.childs = [];
};

AfPoint.prototype.paint = function(byteRect, aftrans){
	//let displayIdent = newIdentAftrans(); //todo optimize by not creating this ever time or not even transforming it. Is it just aftrans?
	//let d = aftransOfAftrans(aftrans,displayIdent); //paint these 3 lines, and display childs in those coordinates
	//FIXME is this the wrong order of using the 4x4 dims, swap the inner/outer 4?
	let centerXFloat = aftrans[ASX];
	let centerYFloat = aftrans[ASY];
	let centerX = Math.floor(centerXFloat);
	let centerY = Math.floor(centerYFloat);
	let redX = Math.floor(centerXFloat+aftrans[AXX]);
	let redY = Math.floor(centerYFloat+aftrans[AXY]);
	let greenX = Math.floor(centerXFloat+aftrans[AYX]);
	let greenY = Math.floor(centerYFloat+aftrans[AYY]);
	let blueX = Math.floor(centerXFloat+aftrans[AZX]);
	let blueY = Math.floor(centerYFloat+aftrans[AZY]);
	byteRect.paintLineYXYXRGB(centerY, centerX, redY, redX, 255, 0, 0);
	byteRect.paintLineYXYXRGB(centerY, centerX, greenY, greenX, 0, 255, 0);
	byteRect.paintLineYXYXRGB(centerY, centerX, blueY, blueX, 0, 0, 255);
	for(let i in this.childs){
		let child = this.childs[i];
		let childAftrans = aftransOfAftrans(aftrans, child.aftrans);
		child.paint(byteRect, childAftrans);
	}
};

//Example: tennis ball with random curved lines drawn on it with pens andOr markers of various color(s),
//used as a 6 dimensional joystick. Example: 20 of these, 2 in hands of each of 10 people, all playing a game together in front of 1 webcam.
//numAngles is the distance around its equator, and from one pole to the other is numAngles/2, so it must be even.
//Recommended range for numAngles is 30-300.
var Ball = function(numAngles){
	verifyNumAngles(numAngles,false); //false, dont allow odd
	
	this._testIsInSetBaxels = false;
	
	//TODO rename numAngles to numEquatorAngles, cuz theres numPoleAngles func.
	this.numAngles = numAngles; //2*pi radians around equator in polar coordinates
	//this.halfAngles = numAngles/2; //pi radians between poles in polar coordinates
	this.baxels = new Float32Array(this.numAngles*this.numAngles/2*VARSPERBAXEL); //FIXME fill these. FIXME if numPoleAngles() is not numAngles/2.
	
	//put radius in here. TODO choose between radius being in the x y z vs in the fourth dim of 4x4 aftrans.
	this.aftrans = newIdentAftrans();
	
	//as of 2021-8 these are all Circle objects, but in general the childs field of an object in 3d can be any objects,
	//and this.childs[whichChild].aftrans is relative to this.aftrans.
	this.childs = [];
	
	this.randomizeColors();
	
	//TODO do circles (C* vars) go here or are they just temporary to align 2 balls to eachother? Each circle needs baxels and a 3x4 aftrans.

	/*TODO m*n ByteRect or Float32Array for pixel colors etc of ceil(radius*pi)*ceil(radius*2*pi) floats (scale radius first)
		that wraps around sphere in polar coordinates. Costs pi/2-1 = 57% more array size than the sphere surface itself,
		which is not too wasteful for the optimization of it being in a regular grid.
		Circles on the sphere surface are (todo) bilinear interpolated on that, keeping red green and blue,
		and compared between 2 spheres, 1 here and 1 (bent using known centerX centerY and radius of ball (find the yellow circles) from webcam.
	*/
	//throw 'TODO';
};

Ball.prototype.numBaxels = function(){
	return this.numAngles*this.numPoleAngles();
};

Ball.prototype.numPoleAngles = function(){
	return this.numAngles/2;
};

Ball.prototype.randomizeColors = function(){
	for(let i=0; i<this.baxels.length; i+=VARSPERBAXEL){
		this.baxels[i+BRED] = randByte();
		this.baxels[i+BGREEN] = randByte();
		this.baxels[i+BBLUE] = randByte();;
	}
};

/** x where Math.hypot(x,y,z)==1 except roundoff. This is one of the 3 partial inverses of xyzToBaxelIndexIgnoringAftrans(x,y,z). *
Ball.prototype.normXOfBaxelIndex function(baxelIndex){
};
*/

/** returns [normX, normY, normZ] where Math.hypot(normX,normY,normZ)==1 except roundoff */
Ball.prototype.normXYZOfBaxelIndex = function(baxelIndex){
	//FIXME test this is inverse (except roundoff) of xyzToBaxelIndexIgnoringAftrans.
	let poleAngles = this.numPoleAngles();
	let picX = baxelIndex%this.numAngles; //rectangle pic (numAngles * numPoleAngles) wrapped around sphere.
	let picY = (baxelIndex-picX)/this.numAngles;
	let equatorAngle = twoPi*picX/this.numAngles; //0(inclusive)..2*pi(exclusive)
	let poleAngle = Math.PI*picY/this.numPoleAngles(); //0(inclusive)..pi(exclusive)
	let z = Math.cos(poleAngle); //FIXME negative of some of those? swap sin/cos?
	let otherThanZ = Math.sqrt(1-z*z);
	let x = otherThanZ*Math.cos(equatorAngle);
	let y = otherThanZ*Math.sin(equatorAngle);
	return [x,y,z];
};

/** func(prevVal,x,y,z,baxelDim)->nextVal, where Math.hypot(x,y,z)==1 except roundoff, and baxelDim is BRED BGREEN BBLUE and other B* vars.
To do nothing, func returns prevVal, or similar to change just some parts.
*/
Ball.prototype.setBaxels = function(func){
	if(this._testIsInSetBaxels) throw 'already in setBaxels';
	try{
		this._testIsInSetBaxels = true;
		let numBaxels = this.numBaxels();
		//for(let i=0; i<this.baxels.length; i+=VARSPERBAXEL){
		for(let b=0; b<numBaxels; b++){
			let i = b*VARSPERBAXEL;
			let normXYZ = this.normXYZOfBaxelIndex(b);
			for(let baxelVar=0; baxelVar<VARSPERBAXEL; baxelVar++){ //Examples: BRED BGREEN BBLUE BLASTWEBCAM
				this.baxels[i+baxelVar] = func(this.baxels[i+baxelVar], normXYZ[0], normXYZ[1], normXYZ[2], baxelVar);
			}
		}
	}finally{
		this._testIsInSetBaxels = false;
	}
};

const twoPi = 2*Math.PI;

//ball.baxels[ball.baxelIndexIgnoringAftrans(...)*VARSPERBAXEL+whichBaxelVar], of the closest baxel to the point,
//where a line from ball center to that point intersects ball surface.
//TODO bilinear interpolation, so would need 4 adjacent baxels in a 2x2 in the rectangle of baxels wrapped around sphere.
//The rectangle (numAngles around equator * (numAngles/2 between the poles)) is in polar coordinates.
//This is a slow way to access surface contents of Ball. Its faster to loop over equator and pole angles (TODO aftrans, call sine, quarternion, or what to do in loop?).
Ball.prototype.xyzToBaxelIndexIgnoringAftrans = function(x, y, z){
	let len = Math.hypot(x,y,z);
	if(len == 0) return 0;
	//TODO x should be horizontal on screen, y vertical, and z into/outOf screen.
	x /= len; //become unit vec. FIXME what if roundoff lets it be slightly outside range -1 to 1 so Math.asin/acos breaks?
	y /= len;
	z /= len;
	let equatorAngle = Math.acos(x);
	if(y < 0) equatorAngle = twoPi-equatorAngle; //range 0 to 2pi. FIXME?
	let poleAngle = Math.acos(z); //range 0 to pi. FIXME?
	let equatorIndex = equatorAngle/twoPi*this.numAngles; //FIXME roundoff here, before combine equatorIndex and poleIndex into 1 number
	let poleIndex = poleAngle/Math.PI*this.halfAngles; //FIXME roundoff here, before combine equatorIndex and poleIndex into 1 number
	return between(0, equatorIndex*this.halfAngles+poleIndex, this.numBaxels()-1);
};

//x y z and whichBaxelVar -> value of that var, or if optionalValue!==undefined then sets value there. Either way returns value.
//This is a slow way to access surface contents of Ball. Its faster to loop over equator and pole angles (TODO aftrans, call sine, quarternion, or what to do in loop?).
Ball.prototype.xyzvIgnoringAftrans = function(x, y, z, whichBaxelVar, optionalValue){
	let index = this.xyzToBaxelIndexIgnoringAftrans(x,y,z)*VARSPERBAXEL+whichBaxelVar;
	if(optionalValue !== undefined){ //write
		this.baxels[index] = optionalValue;
		return optionalValue;
	}else{ //read
		return this.baxels[index];
	}
};

/*
//aftrans can be any FloatBuffer(16), such as aftrans called on aftrans for objects inside objects. See .childs and .aftrans and .paint.
Ball.prototype.paintSlow = function(byteRect, aftrans){
	
	TODO
};
*/

let aftransStr = function(aftrans){
	return 'Float32Array.of('+aftrans[0]+', '+aftrans[1]+', '+aftrans[2]+', '+aftrans[3]+', '
		+aftrans[4]+', '+aftrans[5]+', '+aftrans[6]+', '+aftrans[7]+', '
		+aftrans[8]+', '+aftrans[9]+', '+aftrans[10]+', '+aftrans[11]+', '
		+aftrans[12]+', '+aftrans[13]+', '+aftrans[14]+', '+aftrans[15]+')';
};

//aftrans can be any FloatBuffer(16), such as aftrans called on aftrans for objects inside objects.
Ball.prototype.paint = function(byteRect, aftrans){
	//console.log('Ball paint at '+aftransStr(aftrans));
	//let halfangs = this.numAngles/2;
	let halfangs = this.numPoleAngles(); //normally this.numAngles/2, and the other size is this.numAngles (equatorAngles), of 2d pic
	let numPoints = this.numBaxels();
	//put x y z 1 coordinates (or is it 1 x y z? how does opengl order that?) of sphere surface in here,
	//then aftrans them, then paint colors in byteRect there.
	let points = new Float32Array(4*numPoints);
	let p = 0;
	for(let equatorIndex=0; equatorIndex<this.numAngles; equatorIndex++){
		for(let poleIndex=0; poleIndex<halfangs; poleIndex++){
			//https://gamedev.stackexchange.com/questions/72044/why-do-we-use-4x4-matrices-to-transform-things-in-3d
			//and http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/ both say its x y z 1 in opengl.
			let equatorAngle = (equatorIndex+.5)/this.numAngles*twoPi;
			let poleAngleFraction = (poleIndex+.5)/halfangs; //FIXME sometimes I +.5 to round, and sometimes I dont.
			//let poleAngle = (poleAngleFraction*.5-1)*Math.PI;
			//let z = Math.sin(poleAngle);
			let poleAngle = poleAngleFraction*Math.PI;
			//let z = -Math.cos(poleAngle);
			let z = Math.cos(poleAngle);
			//let xyRadius = (1-z*z);
			let xyRadius = Math.sqrt(1-z*z);
			//let len_z_xyRadius = Math.hypot(z, xyRadius);
			let xBeforeMul = Math.cos(equatorAngle);
			let yBeforeMul = Math.sin(equatorAngle);
			//let lenXYBefore = Math.hypot(xBeforeMul, yBeforeMul);
			let x = xyRadius*xBeforeMul;
			let y = xyRadius*yBeforeMul;
			//let len = Math.hypot(x, y, z);
			//if(Math.random() < .0001) console.log(
			//	'ballpaint test len='+len+' x='+x+' y='+y+' z='+z+' poleAngle='+poleAngle+' xyRadius='+xyRadius+' equatorAngle='+equatorAngle+' poleAngleFraction='+poleAngleFraction+' len_z_xyRadius='+len_z_xyRadius+' xBeforeMul='+xBeforeMul+' yBeforeMul='+yBeforeMul+' lenXYBefore='+lenXYBefore);
			points[p++] = x;
			points[p++] = y;
			points[p++] = z; //z. FIXME sin vs cos here?
			points[p++] = 1; //TODO? 0, dont move the unit sphere
			//if(Math.random() < .0001) console.log('Ball.paint x='+x+' y='+y+' z='+z);
		}
	}
	
	//FIXME shouldnt have to transpose the incoming aftrans
	//points = matmul(transpose4x4(aftrans), points, 4, 4, numPoints); //move and rotate the ball. Its nearly in byteRect coordinates, but without a horizon or viewing position.
	
	
	/*
	points = matmul(aftrans, points, 4, 4, numPoints); //move and rotate the ball. Its nearly in byteRect coordinates, but without a horizon or viewing position.
	points = transpose(points, 4, numPoints); //FIXME remove this?
	*/
	
	
	points = matmul(points, aftrans, numPoints, 4, 4);
	

	p = 0;
	let baxelArrayIndex = 0;
	//for(let poleIndex=0; poleIndex<halfangs; poleIndex++){
		//for(let equatorIndex=0; equatorIndex<this.numAngles; equatorIndex++){
	for(let equatorIndex=0; equatorIndex<this.numAngles; equatorIndex++){
		for(let poleIndex=0; poleIndex<halfangs; poleIndex++){
	
			baxelArrayIndex = (poleIndex*this.numAngles+equatorIndex)*VARSPERBAXEL; //FIXME remove this line, count baxelArrayIndex += 4 instead to optimize.
		
			//TODO optimize by writing byteRect.bytes as array instead of calling writeSafeRGBA
			
			let x = Math.floor(points[p++]);
			let y = Math.floor(points[p++]);
			let z = Math.floor(points[p++]);
			
			//FIXME? use VARSPERBAXEL here? Or what kind of object is p looping thru? x y z 1?
			//p += 2; //ignore z and m (x y z m, renaming s to m)
			p += 1; //ignore z and m (x y z m, renaming s to m)
	
			/*
			let x = Math.floor(points[p++]*70) + 200; //FIXME dont + 200, do that in aftrans. And dont multiply inside the floor(...)
			let y = Math.floor(points[p++]*70) + 200;
			//y *= 200; x *= 200; //FIXME do this in aftrans instead
			let z = Math.floor(points[p++]*10);
			x += z;
			y -= 2*z;
			p++; //ignore scale (x y z scale)
			//p += 2; //ignore z and scale
			*/
			
			let drawPoint = (!sim.hidePointsThatAreBehindOtherPoints || (z < 0)); //FIXME use ball center z
			if(drawPoint){
			
				let redByte = this.baxels[baxelArrayIndex+BRED];
				let greenByte = this.baxels[baxelArrayIndex+BGREEN];
				let blueByte = this.baxels[baxelArrayIndex+BBLUE];
				//if((equatorIndex == 0) && (poleIndex == 0)){ //FIXME remove this test code
				//if(Math.random() < .0001){ //FIXME remove this test code
				//	console.log('Ball.paint x='+x+' y='+y+' redByte='+redByte+' greenByte='+greenByte+' blueByte='+blueByte);
				//}
				byteRect.writeSafeRGBA(y, x, redByte, greenByte, blueByte);
				//byteRect.writeSafeRGBA(y, x, 255, 255, 255); //FIXME use redByte...
			}
			
			
			//baxelArrayIndex += VARSPERBAXEL;
		}
	}
	
	/*for(let i=0; i<256; i++){ //FIXME remove this test code
		byteRect.writeSafeRGBA(i, i, i, i, 255-i);
	}*/
};
//Ball.prototype.paint = Ball.prototype.paintSlow; //TODO optimize using loop

//Does not modify anything.
//TODO is this nondeterministic, or should that part be in the creation and maybe nonstrictfp updating of Ball.circles of both balls?
//Or should the creation of circles be a separate func, and this func would just call that then call another func to compare the circles?
//
//Return aftrans (4x4 affine transform) that aligns the pixels of this Ball to the param Ball,
//optionally with a given last known or last estimated aftrans, after which it might have moved,
//and optionally with an estimated ave number of turns it might have done (0..1) since then.
//Else check all possible rotations equally often (3 kinds of turning),
//except its randomly sampled rotations (such as 1 million rotations),
//and the number of rotations checked is numCirclesInBallA*numCirclesInBallB*numAnglesSameInEachCircle*fractionOfThoseWhichArentDuplicates,
//and fractionOfThoseWhichArentDuplicates is normally around .95 (in theory, todo verify).
Ball.prototype.aftransBetween = function(otherBall, optionalAftrans, optionalEstimatedTurns){
	if(optionalAftrans){ //randomly sample from rotations near optionalAftrans, how near depending on optionalEstimatedTurns
		if(optionalEstimatedTurns && ((optionalEstimatedTurns < 0) || (1 < optionalEstimatedTurns)))
			throw 'optionalEstimatedTurns='+optionalEstimatedTurns+' but must range 0 to 1';
		verifyAftrans(optionalAftrans);
		throw 'TODO';
	}else{ //randomly sample from all rotations
		throw 'TODO';
	}
};

var copyFloat32Array = function(arr){
	return Float32Array.from(arr);
};

var controlWithDeadzone = function(name, deadZone){
	let val = control(name);
	if(Math.abs(val) < deadZone){
		return 0;
	}else{
		if(val > 0){
			return val-deadZone; //dont jump, it starts as 0 movement at border of deadzone and gradually more
		}else{
			return val+deadZone;
		}
	}
};

//returns [valA, valB] with circle of deadzone.
//Not jumpy. It doesnt jump from 0 to deadZone at deadZone. There, its 0, and gradually more.
var control2WithDeadzone = function(deadZone, nameA, nameB){
	let valA = control(nameA);
	let valB = control(nameB);
	let len = Math.hypot(valA,valB);
	if(len < deadZone) return [0, 0];
	let newLen = len-deadZone;
	let mul = newLen/len;
	return [valA*mul, valB*mul];
};

//af is normally selectedOb.aftrans such as a ball to move and rotate.
var controllerTransformsAftrans = function(controllerName, afIn, dt){
	
	//TODO optimize: can this be done by returning an aftrans thats reusable, such as to rotate all the points on the ball?
	
	let mulRotate = 6*dt;
	let mulResize = 2.5*dt;
	let mulMove = 620*dt;
	
	let af = copyFloat32Array(afIn);
	
	for(let i=12; i<16; i++) af[i] = 0; //centered at origin. Put these back after rotations.
	
	
	
	
	let deadZone = .1; //FIXME get this statistically
	let mAndN = control2WithDeadzone(deadZone, controllerName+'_dim0', controllerName+'_dim1'); //left joystick
	let m = mAndN[0];
	let n = mAndN[1];
	let oAndP = control2WithDeadzone(deadZone, controllerName+'_dim2', controllerName+'_dim3'); //right joystick
	let o = oAndP[0];
	let p = oAndP[1];
	let q = controlWithDeadzone(controllerName+'_btn6',deadZone); //left analog trigger, 0..1
	let r = controlWithDeadzone(controllerName+'_btn7',deadZone); //right analog trigger, 0..1
	let qr = r-q; //-1..1
	
	let lb = controlWithDeadzone(controllerName+'_btn4',deadZone);
	let rb = controlWithDeadzone(controllerName+'_btn5',deadZone);
	let mulSize = 1+(rb-lb)*mulResize;
	
	let angleB = m*mulRotate;
	
	let angleC = n*mulRotate;
	
	let angleD = qr*mulRotate;
	
	console.log('angleB='+angleB+' angleC='+angleC+' angleD='+angleD);
	
	
	/*c[AYY] = Math.cos(angleD);
	c[AYX] = -Math.sin(angleD);
	c[AXY] = Math.sin(angleD);
	c[AXX] = Math.cos(angleD);
	*/
	
	//let dimA = AX;
	//let dimB = AY;

	let dimA = 0;
	let dimB = 0;
	let angle = 0;
	for(let kindOfRotation=0; kindOfRotation<3; kindOfRotation++){
		switch(kindOfRotation){
		case 0:
			dimA = AX;
			dimB = AZ;
			angle = angleB;
		break;case 1:
			dimA = AY;
			dimB = AZ;
			angle = angleC;
		break;case 2:
			dimA = AX;
			dimB = AY;
			angle = angleD;
		}
		for(let i=0; i<4; i++){
			//if((i == dimA) || (i == dimB)){
			
				//let indexJ = dimA*4+i; //FIXME i*4+dimA?
				//let indexK = dimB*4+i; //FIXME i*4+dimB?
				let indexJ = i*4+dimA;
				let indexK = i*4+dimB;
				let prevValJ = af[indexJ];
				let prevValK = af[indexK];
				af[indexJ] = prevValJ*Math.cos(angle) - prevValK*Math.sin(angle); //TODO optimize by reusing sin and cos
				af[indexK] = prevValJ*Math.sin(angle) + prevValK*Math.cos(angle);
			//}
		}
		
		/*
		[dimA*4+dimB] = Math.cos(angleD);
		c[dimA*4+dimB] = -Math.sin(angleD);
		c[dimA*4+dimB] = Math.sin(angleD);
		c[dimA*4+dimB] = Math.cos(angleD);
		*/
	}
	
	af[AXX] *= mulSize;
	af[AXY] *= mulSize;
	af[AXZ] *= mulSize;
	af[AYX] *= mulSize;
	af[AYY] *= mulSize;
	af[AYZ] *= mulSize;
	af[AZX] *= mulSize;
	af[AZY] *= mulSize;
	af[AZZ] *= mulSize;
	
	for(let i=12; i<16; i++) af[i] = afIn[i]; //get original position back. keep rotation.
	
	af[ASX] += o*mulMove;
	af[ASY] += p*mulMove;
	
	return af;
};


/*
//Example controllerName: 'gamepad0'
//Example mul: .03, normally proportional to dt (change in time since last used this to aftrans something)
//var controllerToAftrans = function(controllerName, mulRotate, multResize, mulMove){
	
//FIXME can this be done by returning an aftrans without having to take one as param?
var controllerModifiesAftrans = function(controllerName, mulRotate, multResize, mulMove){ //this never worked right
	let deadZone = .1; //FIXME get this statistically
	let mAndN = control2WithDeadzone(deadZone, controllerName+'_dim0',deadZone, controllerName+'_dim1',deadZone); //left joystick
	let m = mAndN[0];
	let n = mAndN[1];
	let oAndP = control2WithDeadzone(deadZone, controllerName+'_dim2',deadZone, controllerName+'_dim3',deadZone); //right joystick
	let o = oAndP[0];
	let p = oAndP[1];
	let q = controlWithDeadzone(controllerName+'_btn6',deadZone); //left analog trigger, 0..1
	let r = controlWithDeadzone(controllerName+'_btn7',deadZone); //right analog trigger, 0..1
	let qr = r-q; //-1..1
	
	let lb = controlWithDeadzone(controllerName+'_btn4',deadZone);
	let rb = controlWithDeadzone(controllerName+'_btn5',deadZone);
	let multSize = 1+(rb-lb)*multResize;
	
	let angleB = m*mulRotate;
	
	let angleC = n*mulRotate;
	
	let angleD = qr*mulRotate;
	
	/*let a = newIdentAftrans();
	a[AXX] = Math.cos(angleB);
	a[AXZ] = -Math.sin(angleB);
	a[AZX] = Math.sin(angleB);
	a[AZZ] = Math.cos(angleB);
	
	let b = newIdentAftrans();
	b[AYY] = Math.cos(angleC);
	b[AYZ] = -Math.sin(angleC);
	b[AZY] = Math.sin(angleC);
	b[AZZ] = Math.cos(angleC);
	*
	
	
	let c = newIdentAftrans();
	
	/*c[AYY] = Math.cos(angleD);
	c[AYX] = -Math.sin(angleD);
	c[AXY] = Math.sin(angleD);
	c[AXX] = Math.cos(angleD);
	*
	
	let dimA = AX;
	let dimB = AY;
	for(let i=0; i<4; i++){
		if(i != AS){ //dont rotate position offset, just rotate the rotations.
			//let indexJ = dimA*4+i; //FIXME i*4+dimA?
			//let indexK = dimB*4+i; //FIXME i*4+dimB?
			let indexJ = i*4+dimA;
			let indexK = i*4+dimB;
			let prevValJ = c[indexJ];
			let prevValK = c[indexK];
			c[indexJ] = prevValJ*Math.cos(angleD) - prevValK*Math.sin(angleD);
			c[indexK] = prevValJ*Math.sin(angleD) + prevValK*Math.cos(angleD);
		}
	}
	
	/*for(let g=0; g<4; g++){
		for(let h=0; h<4; h++){
			let index = g*4+h;
			//if((g == AS) || (h == AS)) c[index] = 0;
			if(g == AS){
				if(h == AS){
					c[index] = 10;
				}else{
					c[index] = 0;
				}
			}else{ //g != AS
				if(h == AS){
					c[index] = 1;
				}else{
					//leave as it is
				}
			}
		}
	}*
	
	
	
	/*
	c[AYY] = Math.cos(angleD);
	c[AYX] = -Math.sin(angleD);
	c[AXY] = Math.sin(angleD);
	c[AXX] = Math.cos(angleD);
	*
	
	/*
	let d = newIdentAftrans();
	d[AXX] = multSize;
	d[AYY] = multSize;
	d[AZZ] = multSize;
	
	
	let e = newIdentAftrans();
	d[ASX] = o*mulMove;
	d[ASY] = p*mulMove;
	*
	
	//let ret = aftransOfAftrans(aftransOfAftrans(aftransOfAftrans(aftransOfAftrans(a,b),c),d),e);
	let ret = c;
	
	//console.log('controllerToAftrans', controllerName+' '+m+' '+n+' '+o+' '+p);
	return ret;
};
*/

//Sim is designed to not touch webcam, mouse, game controllers, or any other inputs and outputs, and do everything thru ByteRect
//(and TODO map of string to number for gamepad, mouse, keyboard, etc, and maybe also ScriptNode in WebAudioAPI)
//dim means dimension.
var Sim = function(){

	//TODO? returns deepest child at that, in the this.childs[...].childs[...].whatsAtYx(yx) etc. Returns this if no child matches that.
	//FIXME for now, just checks 1 level deep, since thats where the Balls are, else returns null.
	this.whatsAtYx = function(yx){
		let minDistance = Infinity;
		let nearestBall = null;
		for(let i in this.childs){
			let child = this.childs[i];
			//if(child instanceof Ball){
				//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof
				//The instanceof operator tests to see if the prototype property of a constructor appears anywhere in the prototype chain of an object. The return value is a boolean value.
				//throw 'TODO put AfPoint at mouse instead, centered on first ball';
				let distance2dMouseToBallCenter = Math.hypot(child.aftrans[ASX]-yx[1], child.aftrans[ASY]-yx[0]);
				if(distance2dMouseToBallCenter < minDistance){
					minDistance = distance2dMouseToBallCenter;
					nearestBall = child;
				}
			//}
		}
		return nearestBall; //FIXME check if its inside the balls oval area on screen
	};

	this.isPaused = false;

	//FIXME? Sim is top level so maybe doesnt need aftrans? Would be more consistent to have it,
	//but it would interfere with older code in Sim.io(...byterects etc...) not using aftrans (yet?).
	//this.aftrans = newIdentAftrans()

	//direct childs, which as of 2021-8 are just Balls, and direct childs of Ball are Circles, so this.childs[0].childs[0] is a Circle unless empty.
	this.childs = [];

	this.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU = false;
	
	this.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	
	this.displaySprings = false;
	//brightness 0 (if 0 were allowed in slider-controlled vars, which its not), contrast 1, is no adjustment, but it seems to make the springs black nearly everywhere.
	this.displaySpringBrightnessSubtract = 3;
	//this.displaySpringBrightness = 0;
	this.displaySpringContrast = 6;
	
	this.ifDisplaySpringsThenOnlyThoseFromThisVoxelIndexOrNullToDisplayAll = 0;
	
	this.enable_holdVoxelsYXAtSingleRadius = true;
	this.holdVoxelsYXAtSingleRadius = 160;
	
	//for xbox dual joystick dual analog trigger controller (for example),
	//but may work on other controllers right away or maybe if you adjust what axis does what (TODO)
	//If true, then its moved by controllerToAftrans, so you can adjust what axis does what there.
	this.gamepadMovesAndRotatesSelectedBall = true;
	
	this.hidePointsThatAreBehindOtherPoints = true;
	
	this.doTestCirclesDetect_oneCenterMultiSizes = false;
	this.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu = false;

	this.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked = false;
	
	this.randomlyChangeFirstBallsAftransGradually = true;
	
	this.holdVoxelsYXInByteRect = true;
	
	this.paintTestObjectsAsInput = true;
	
	this.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU = true;
	this.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG = false;
	
	this.allowBytesIntoGpuElseCopyBytesToFloats_thisMayBeBuggy = false;
	
	this.pixelColorAcceleratesVoxelsInsteadOfMovesThem = false;
	
	this.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	
	this.addABallIfThereIsNoneWhenRestart = false;
	
	//when display lines between voxels, brightness is the potentialEnergy hill of that spring depending on their distance,
	//but it needs the whole distance between them (and outward to infinity, though only 100 pixels or so past them is displayed)
	//as if 1 of them is at constant position and the potentialEnergy of the other is displayed at those possible positions.
	//Do you want it to display relative to the selected voxel vs the other voxel (for all other voxels, a line displayed for each)?
	this.displayPotentialEnergyFromSelectedVsTo = false;
	
	/*
	//learnRate of SRESTLEN (spring at-rest-length) decaying toward SAVEDIST (spring recent average length) when dist is near SAVEDIST.
	this.decaySRESTLEN = 1;
	//FIXME SRESTLEN and SAVEDIST are the same val as of 2021-7-17 but wont 	always be that way, TODO
	this.decaySAVEDIST = 1;
	*/
	//this.decaySAVEDIST = .01;
	//this.decaySAVEDIST = .03;
	this.decaySAVEDIST = .1;
	//this.decaySAVEDIST = 0; //FIXME
	
	this.decaySSTRENGTH = .01;
	//this.decaySSTRENGTH = 0; //FIXME
	
	//somewhere in the middle of repelling alot vs repelling a little. The closer they get, the more they repel.
	this.repelMidDist = 10;
		
	//how many times SSTRENGTH is potentialEnergy from repelling (compared to potentialEnergy from spring vibrating has a max of SSTRENGTH).
	this.repelTimesMoreThanSpring = 2.1;
	//this.repelTimesMoreThanSpring = .00001;
	
	/** velocity *= decayVelocities*dt. This isnt correct physics but is a fast way to get started.
	Correct physics friction subtracts from velocity instead of decays it,
	subtracts proportional to how much the frictioning objects are pushing against eachother etc,
	but if objects start going really fast, as they often do in simulations, its useful to decay instead of subtract.
	Explore both later, after the basics are working.
	*/
	this.decayVoxelVelocities = .4;
	
	//0..255. Only keep rows (red green or blue of separately) at most this bright on average
	this.brightLimitForRowsAndColsToNotBeSetToBlack_bright = 70;
	
	//0..1
	this.brightLimitForRowsAndColsToNotBeSetToBlack_fraction = .2;

	
	/*
	//the test* (testX testB testSize etc) vars will be removed after grid of voxels is working. that was the first voxel.
	//a point that sees color and tries to stay the same color
	this.testX = 200; //voxel x
	this.testY = 200; //voxel y
	this.testR = 0; //voxel red
	this.testG = 0; //voxel green
	this.testB = 255; //voxel blue
	*/
	//this.testSize = 57;
	//this.testSize = 30;
	//this.testSize = 50;
	//this.testSize = 10;
	this.testSize = 30;
	
	//negative is repelled by its current color. positive attract.
	//this.testSpeedMult = -1000; //how fast to move (or accel? todo) the "test" voxel that looks at colors near it and moves toward colors near its own current color
	//this.testSpeedMult = 14400;
	
	//FIXME 14000 might be a little too fast for some computers and will get jittery and get stuck at sides of screen,
	//so reduce it if so. TODO auto detect that kind of stuff. Auto tune it for best match to whats happening on screen and computer abilities.
	//Similar for colorChangeSpeedMult and (this is testSpeedMult).
	this.testSpeedMult = 14000;
	//this.testSpeedMult = 4000;
	//this.testSpeedMult = 400;
	//this.testSpeedMult = 20000; //jumpy even on a fast computer. on a slower computer, might not work at all unless reduce this. springs can make it smoother. todo.
	//
	//2021-7-17 testSpeedMult is how much voxels are moved by near pixel colors they see, not how much they are moved by springs (which is in SSTRENGTH instead).
	//
	//this.testSpeedMult = 400;
	//this.testSpeedMult = 0;
	
	//force (voxelVelocity += dt*mass*accel) due to springs, but all voxels have mass of 1 as of 2021-7-25).
	this.springForceMult = 4000;
	
	//positive becomes more like the color it is near, negative less like it. only positive is stable here.
	//this.colorChangeSpeedMult = 8;
	this.colorChangeSpeedMult = 4;
	//this.colorChangeSpeedMult = .4;
	//this.colorChangeSpeedMult = 0; //FIXME
	
	//this.numVoxels = 3; //TODO want at least 10000 voxels later, will need sparse springs and GPU.js
	//this.numVoxels = 2; //TODO want at least 10000 voxels later, will need sparse springs and GPU.js
	//this.numVoxels = 10; //TODO want at least 10000 voxels later, will need sparse springs and GPU.js
	//this.numVoxels = 50; //TODO want at least 10000 voxels later, will need sparse springs and GPU.js
	this.numVoxels = 200; //TODO want at least 10000 voxels later, will need sparse springs and GPU.js
	//this.numVoxels = 1000; //TODO want at least 10000 voxels later, will need sparse springs and GPU.js
	this.numSprings = this.numVoxels*this.numVoxels;
	//VARSPERVOXEL this.varsPerVoxel = 7; //FIXME how many?
	//VARSPERSPRING this.varsPerSpring = 4; //FIXME how many?
	//for now, do dense springs between all pairs of voxels (including both directions of spring, which are duplicate, but just to keep it simple).
	//later do sparse with max 1 spring (not 2) per pair of voxels, as optimization.
	
	//params are 2 voxel indexs
	this.distanceSq = function(voxA, voxB){
		let aa = voxA*VARSPERVOXEL;
		let bb = voxB*VARSPERVOXEL;
		let diffX = this.voxels[aa+VX]-this.voxels[bb+VX];
		let diffY = this.voxels[aa+VY]-this.voxels[bb+VY];
		let diffZ = this.voxels[aa+VZ]-this.voxels[bb+VZ];
		return diffX*diffX + diffY*diffY + diffZ*diffZ;
	};
	
	//-1 if this.numVoxels==0, else range 0 to this.numVoxels-1.
	//whichever is nearest to mouse in 2d (TODO draggable)
	this.selectedVox = function(){
		let nearestVox = -1;
		let nearestDist = Infinity;
		for(let i=0; i<this.numVoxels; i++){
			let dist = Math.hypot(this.voxelVar(i,VX)-mouseX, this.voxelVar(i,VY)-mouseY);
			if(dist < nearestDist){
				nearestVox = i;
				nearestDist = dist;
			}
		}
		return nearestVox;
	};
	
	this.distance = function(voxA, voxB){
		let aa = voxA*VARSPERVOXEL;
		let bb = voxB*VARSPERVOXEL;
		return Math.hypot(
			this.voxels[aa+VX]-this.voxels[bb+VX],
			this.voxels[aa+VY]-this.voxels[bb+VY],
			this.voxels[aa+VZ]-this.voxels[bb+VZ]
		);
	};
	
	/** 0 <= spr < this.numSprings. */
	this.distanceSpring = function(spr){
		let voxA = spr%this.numVoxels;
		let voxB = (spr-voxA)/this.numVoxels;
		return this.distance(voxA,voxB);
	};
	
	this.setAllVoxelPositionsAndSpeedsInZDimTo0ToBecome2d = function(){
		for(let v=0; v<this.numVoxels; v++){
			let index = v*VARSPERVOXEL+VZ;
			this.voxels[index] = 0;
			this.voxelVels[index] = 0;
		}
	};
	
	this.restart = function(){
		//FIXME this doesnt replace some parts that replaceSim does, and replaceSim maybe doesnt do all this like put the this.voxels back in?
	
		console.log('restart');
		//TODO use GPU.js
		this.voxels = new Float32Array(this.numVoxels*VARSPERVOXEL); //position
		this.voxelVels = new Float32Array(this.voxels.length); //velocity
		this.springs = new Float32Array(this.numSprings*VARSPERSPRING); //springs use the positions and velocities of 2 voxels so dont have those properites themselves
		for(let v=0; v<this.numVoxels; v++){
			let vv = v*VARSPERVOXEL;
			this.voxels[vv+VRED] = Math.random()*255.999;
			this.voxels[vv+VGREEN] = Math.random()*255.999;
			this.voxels[vv+VBLUE] = Math.random()*255.999;
			this.voxels[vv+VX] = 100+300*Math.random();
			this.voxels[vv+VY] = 100+300*Math.random();
			if(this.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly){
				this.voxels[vv+VZ] = 100+300*Math.random();
			}else{
				this.voxels[vv+VZ] = 0;
			}
			this.voxels[vv+VWEBCAMS] = 1;
		}
		for(let v=0; v<this.voxelVels.length; v++){
			this.voxelVels[v] = 0;
		}
		for(let s=0; s<this.numSprings; s++){
			let voxA = s%this.numVoxels;
			let voxB = (s-voxA)/this.numVoxels;
			let ss = s*VARSPERSPRING;
			this.springs[ss+SSTRENGTH] = 25/this.numVoxels;
			//this.springs[ss+SSTRENGTH] = 5/this.numVoxels;
			//this.springs[ss+SSTRENGTH] = 3;
			//this.springs[ss+SSTRENGTH] = 10;
			//this.springs[ss+SSTRENGTH] = 0; //FIXME
			let dist = this.distance(voxA,voxB);
			this.springs[ss+SAVEDIST] = dist;
			//this.springs[ss+SRESTLEN] = dist*rand(.8,1.2);
			this.springs[ss+SRESTLEN] = dist;
			
			//FIXME as of 2021-7-16 SFRICTION is not used yet but Sim.decayVoxelVelocities is.
			//SFRICTION is better cuz doesnt resist objects spinning. only resists change in spring length.
			this.springs[ss+SFRICTION] = .0001; //FIXME this will probably be ignored until later, but without it, springs vibrate out of control
			//TODO norm by energy per spring, sum potentialEnergy of all those and kineticEnergy of all voxels.
			
			this.springs[ss+SDOWNFROM] = 1;
			//this.springs[ss+SWIDE] = dist*.1;
			//this.springs[ss+SWIDE] = dist*.03;
			this.springs[ss+SWIDE] = dist*.07;
			//this.springs[ss+SWIDE] = dist*.1;
			//this.springs[ss+SWIDE] = dist*.01;
			//this.springs[ss+SWIDE] = dist*1.05;
		}
		if(this.addABallIfThereIsNoneWhenRestart){
			if(this.childs.length == 0){
				let div = dom('controlsDiv_aftranses');

				let ball = this.addRandomBall();
				if(!selectedOb) selectedOb = ball;
				//ball.aftrans = Float32Array.of(0, -40, 0, 0, 40, 50, 0, 0, 50, -40, 10, 0, 190 ,200, 0, 0)
				//ball.aftrans = Float32Array.of(40, -40, 0, 0, 40, 80, 0, 0, 50, -40, 10, 0, 190, 200, 0, 0);
				//ball.aftrans = Float32Array.of(40, -40, 1, 1, 40, 80, 1, 1, 50, -40, 10, 1, 190, 200, 1, 1)
				//ball.aftrans = Float32Array.of(40, -40, 0, 0, 40, 70, 0, 0, 50, -40, 0, 0, 190, 200, 0, 0);
				//ball.aftrans = Float32Array.of(40, -40, 0, 1, 40, 70, 0, 1, 50, -40, 0, 1, 190, 200, 0, 1);
				ball.aftrans = Float32Array.of(50, 0, 0, 1, 0, 50, 0, 1, 0, 0, 50, 1, 190, 200, 0, 1);
				createControlsForAftransInDiv(ball.aftrans, div, 10);		
				this.addAfPointSharingAftransWith(this, ball); //FIXME if replace ball.aftrans, its not sharing it with the AfPoint anymore
				
				
				let ball2 = this.addRandomBall();
				//ball2.aftrans = Float32Array.of(0, -40, 0, 0, 40, 50, 0, 0, 50, -40, 10, 0, 390 ,200, 0, 0)
				//ball2.aftrans = Float32Array.of(70, -90, 0, 0, -50, 0, 70, 0, 80, 90, 240, 0, 430, 250, 80, 0);
				//ball2.aftrans = Float32Array.of(70, -90, 1, 1, -50, 1, 70, 1, 80, 90, 240, 1, 430, 250, 80, 1);
				ball2.aftrans = Float32Array.of(60, 0, 0, 1, 0, 40, 0, 1, 0, 0, 50, 1, 390, 220, 0, 1);
				createControlsForAftransInDiv(ball2.aftrans, div, 10);
				this.addAfPointSharingAftransWith(this, ball2);
				
				this.addAfPoint(); //adds 2 of them, one inside the other
				
			}
		}
	};
	
	this.addRandomBall = function(){
		//TODO need to know size of ByteRect its displayed in (unless theres a standard size of the space and may Sim.aftrans view it)
		//let equatorAngles = 40; //FIXME should be around 100. //must be even. poleAngles is half that
		let equatorAngles = 100; //must be even. poleAngles is half that
		//let equatorAngles = 200;
		//let equatorAngles = 300; //FIXME 100
		let ball = new Ball(equatorAngles); //starts with identityFunc aftrans. change that so its not just 2 pixels wide (radius 1)
		
		ball.setBaxels(function(prevVal, normX, normY, normZ, baxelDim){
			//return 255;
			switch(baxelDim){
			case BRED:
				//return 0;
				return (128+normX*127.999);
			case BGREEN:
				//return 0;
				return (128+normY*127.999);
			case BBLUE:
				//return 0;
				return (128+normZ*127.999);
			case BLASTWEBCAM:
				return 255; //255 is visible. 0 is transparent. as that webcam (of possibly multiple webcams, todo) sees it.
			default:
				return prevVal;
			}
		});
		
		
		//x y z scale, in 4x4
		/*let x = 250;
		let y = 200;
		let z = 0;
		let radius = 70;
		ball.aftrans[ASX] = x; //FIXME ASX vs AXS?
		ball.aftrans[ASY] = y; //FIXME?
		ball.aftrans[ASZ] = z; //FIXME?
		ball.aftrans[ASS] = radius; //TODO choose for radius to go here vs in some combo of x y and z?
		*/
		ball.aftrans[AXX] = 100; //FIXME
		ball.aftrans[AYY] = 100;
		ball.aftrans[AZZ] = 100;
		ball.aftrans[ASS] = 100;
		this.childs.push(ball);
		//let div = dom('controlsDiv');
		return ball;
	};
	
	this.addAfPointSharingAftransWith = function(parentOfShareMyAftrans, shareMyAftrans){
		let div = dom('controlsDiv_aftranses');
		let a = new AfPoint(shareMyAftrans.aftrans);
		parentOfShareMyAftrans.childs.push(a);
		return a;
	};
	
	this.addAfPoint = function(){
		let div = dom('controlsDiv_aftranses');
		let a = new AfPoint(newRandAftrans());
		div.innerHTML += '<hr>';
		createControlsForAftransInDiv(a.aftrans, div, 10);
		for(let i=0; i<1; i++){
			//a.childs.push(new AfPoint(newRandAftrans()));
			//a.childs.push(new AfPoint(newRandAftransNearIdent()));
			let childAftrans = newRandAftransNearIdent();
			a.childs.push(new AfPoint(childAftrans));
			div.innerHTML += '<hr>';
			createControlsForAftransInDiv(childAftrans, div, .1);
		}
		this.childs.push(a);
		
		//this.childs[0].aftrans = this.childs[1].aftrans; //make ball and afpoint share the same aftrans, to figure out what went wrong
		
		//Experimental things I typed into browser:
		//sim.childs[0].aftrans = Float32Array.of(100,0,0,0,  0,100,0,0,  10,10,100,10,  120,90,121,1);
		return a;
	};
	

	//copy of the prev byteRect, so can compare 2 consecutive video frames from webcam.
	//this.prevByteRect = null;
	
	//a 2d bendable surface were each point on it has position and velocity in 6 dims: x y z red green blue (or maybe dont have velocity in the color dims?),
	//so its those 12 (or 9?) floats at each 2d cell. Plus it maybe should also have 3 more floats for the target color, or 6 more for prev and next color.
	//These are aligned to the incoming webcam pixels, to bend the sheet and gradually change its color to represent objects moving and rotating
	//in what the webcam sees, to allow it to better predict what it will see next by these velocities and using those predictions
	//to rotate and bend and stretch and squash etc the sheet in these higher dimensions to, for example, have a moving 3d model of your hands
	//that appears at the same pixel locations the webcam sees your hands, so can put augmented reality stuff
	//ike your fingers friction to affect a basketball's spin while you shoot it at a hoop) into the displayed video.
	//It doesnt have to do object recognition to predict which parts of the 3d volume have objects at them and which dont (at voxel precision).
	//this.sheet = null;
	
	this.adjustVoxelVelocitiesBySprings = function(dt){
		if((this.numVoxels == 0) || (this.numSprings == 0) || (dt == 0)) return;
		
		//TODO use velocity and springDampening instead of this quickly written jittery experiment that doesnt use velocity at all...
		let pos = this.voxels;
		let vel = this.voxelVels;
		let spr = this.springs;
		for(let s=0; s<this.numSprings; s++){
			let voxA = s%this.numVoxels;
			let voxB = (s-voxA)/this.numVoxels; //same as floor(s/this.numVoxels) but faster
			let aa = voxA*VARSPERVOXEL;
			let bb = voxB*VARSPERVOXEL;
			//let ss = s*VARSPERSPRING;
			
			let diffX = pos[bb+VX]-pos[aa+VX];
			let diffY = pos[bb+VY]-pos[aa+VY];
			let diffZ = pos[bb+VZ]-pos[aa+VZ];
			let dist = Math.hypot(diffX, diffY, diffZ);
			if(dist != 0){
				let normX = diffX/dist; //(normX,normY,normZ) is a unit vector from voxA toward voxB.
				let normY = diffY/dist;
				let normZ = diffZ/dist;
			
				//as of 2021-7-25 every voxel's mass is 1.
				let force = this.potentialEnergyDerivativeOfSpring(s)*this.springForceMult;
				//force = -force; //FIXME?
				let forceEach = force/2;
				let mul = forceEach*dt;
				
				let addEachDx = normX*mul;
				let addEachDy = normY*mul;
				let addEachDz = normZ*mul;
				
				vel[aa+VX] += addEachDx;
				vel[aa+VY] += addEachDy;
				vel[aa+VZ] += addEachDz;
				vel[bb+VX] -= addEachDx;
				vel[bb+VY] -= addEachDy;
				vel[bb+VZ] -= addEachDz;
				
				
				/*
				//let dist = this.distance(voxA,voxB);
				//if(dist == 0) continue; //FIXME
				//let aveDist = spr[ss+SAVEDIST];
				let restDist = spr[ss+SRESTLEN]; //how long the spring would be if its at rest
				let strength = spr[ss+SSTRENGTH]; //strength of 0 is spring not existing. strength >= 0. Higher strength holds the 2 voxels toward restDist more.
				let diffX = pos[bb+VX]-pos[aa+VX];
				let diffY = pos[bb+VY]-pos[aa+VY];
				let diffZ = pos[bb+VZ]-pos[aa+VZ];
				let dist = Math.hypot(diffX, diffY, diffZ);
				if(dist != 0){
					//TODO force = mass*accel, but as of 2021-7-16 all voxels have mass 1.
					let accel = strength*(restDist-dist); //positive is the 2 voxels accel toward eachother. negative repels.
					let mul = dt*accel/dist/2; // /2 for half accel at each voxel. divide by dist to get normed (x,y,z) vec.
					mul = -mul; //FIXME why does this need to be flipped? 2021-7-17 found that SSTRENGTH needed to be negative for spring to vibrate vs explode
					let addEachDx = diffX*mul;
					let addEachDy = diffY*mul;
					let addEachDz = diffZ*mul;
					vel[aa+VX] += addEachDx;
					vel[aa+VY] += addEachDy;
					vel[aa+VZ] += addEachDz;
					vel[bb+VX] -= addEachDx;
					vel[bb+VY] -= addEachDy;
					vel[bb+VZ] -= addEachDz;
				}
				*/
			}
		}
	};
	
	this.adjustPositionsByVelocities = function(positions, velocities, dt){
		warnIfStrangeDt(dt);
		if(positions.length != velocities.length) throw 'Diff sizes positions and velocities';
		for(let i=0; i<positions.length; i++) positions[i] += velocities[i]*dt;
	};
	
	//https://en.wikipedia.org/wiki/Harmonic_oscillator#Damped_harmonic_oscillator
	//friction is proportional to abs(dotProd(voxelA_dx_dy_dz - voxelB_dx_dy_dz, normToUnitVec(voxelA_x_y_z-voxelB_x_y_z))),
	//where normToUnitVec divides that by its distance unless its 0 in which case the dotProd is 0.
	this.adjustVelocitiesBetweenPairsOfVoxelsBasedOnVelocitiesAlongSpringsSoIfSpringIsntChangingLengthTheresNoFriction = function(dt){
		//TODO
	};
	
	//decay vars range 0 to 1, normally very near 0.
	this.updateAverageDistancesAndRestLens = function(aveDistDecay){
		if(aveDistDecay == 0) return;
		//console.log('aveDistDecay='+aveDistDecay);
		for(let s=0; s<this.numSprings; s++){
			let voxA = s%this.numVoxels;
			let voxB = (s-voxA)/this.numVoxels;
			let prevAveDist = this.springs[s+SAVEDIST];
			let dist = this.distance(voxA,voxB);
			let ss = s*VARSPERSPRING;
			this.springs[ss+SAVEDIST] = this.springs[ss+SAVEDIST]*(1-aveDistDecay)+aveDistDecay*dist;
			this.springs[ss+SRESTLEN] = this.springs[ss+SAVEDIST]; //FIXME should restlen always be average distance?
			//TODO norm by energy per spring, sum potentialEnergy of all those and kineticEnergy of all voxels.
		}
	};
	
	//FIXME should SRESTLEN and SAVEDIST be merged?
	
	this.updateSpringStrengths = function(decayTowardTargetStrength){
		if(decayTowardTargetStrength == 0) return;
		
		//FIXME
		
		/*
		//TODO strength changes faster depending on how fast both the voxels are moving
		//in absolute 3d space (or 2d per webcam? that makes it harder to scale to n webcams, so 3d better in that way).
		//That would avoid adjusting strength for things that arent moving at the time, such as the background,
		//while making things that are moving, multiple voxels in it moving approx together, grow spring strength between them.
		
		//TODO experiment with few enough voxels that can display all the springs, and a few small marks on the line (between 2 vox)
		//representing aveDist, dist, strength related stuff, etc, so can watch it and verify it does what i want.
	
		for(let s=0; s<this.numSprings; s++){
			let ss = s*VARSPERSPRING;
			let voxA = s%this.numVoxels;
			let voxB = (s-voxA)/this.numVoxels;
			let aveDist = this.springs[ss+SAVEDIST];
			let dist = this.distance(voxA,voxB);
			let distDiff = Math.abs(dist-aveDist); //TODO other nonlinear func? allow it to vary more the farther their aveDist?
			let targetStrength = 1/(10+distDiff);
			this.springs[ss+SSTRENGTH] = this.springs[ss+SSTRENGTH]*(1-decayTowardTargetStrength)+decayTowardTargetStrength*targetStrength;
			//TODO norm by energy per spring, sum potentialEnergy of all those and kineticEnergy of all voxels.
		}
		*/
	};
	
	//called by this.io
	this.voxelsAndSpringsIO = function(dt, byteRectIn, byteRectOut){
		if(this.isPaused) return;
		warnIfStrangeDt(dt);
		byteRectIn.verifySameSizeAs(byteRectOut);
		//TODO use asap: VRED VGREEN VBLUE VX VY, and spring dims: SSTRENGTH SRESTLEN SFRICTION, in this.voxels and this.springs
		//TODO use later: VZ VWEBCAMS
		//TODO use much later: VWEBCAMS+1 VWEBCAMS+2 VWEBCAMS+3...
		//throw 'TODO voxelsAndSpringsIO';
		
		let selectedVox = this.selectedVox();
		
		let moveMul = dt*this.testSpeedMult;
		let accelMul = dt*Math.sqrt(moveMul); //FIXME make a new Sim.varname for this.
		let colorMul = dt*this.colorChangeSpeedMult;
		//let isPaintOver = false;
		//let isPaintOver = true;
		
		let minY = this.testSize/2;
		let minX = this.testSize/2;
		let maxY = byteRectIn.height-this.testSize/2;
		let maxX = byteRectIn.width-this.testSize/2;
		
		
		
		//if((this.ifDisplaySpringsThenOnlyThoseFromThisVoxelIndexOrNullToDisplayAll != null) && Math.random()<.1){
		//if(this.ifDisplaySpringsThenOnlyThoseFromThisVoxelIndexOrNullToDisplayAll != null){
		//	this.ifDisplaySpringsThenOnlyThoseFromThisVoxelIndexOrNullToDisplayAll = randInt(this.numVoxels);
		//}
		this.ifDisplaySpringsThenOnlyThoseFromThisVoxelIndexOrNullToDisplayAll = selectedVox;
		
		for(let v=0; v<this.numVoxels; v++){ //TODO GPU.js instead of this loop
			let vv = v*VARSPERVOXEL;
			let derivs = byteRectIn.yxrgbDerivs(
				this.testSize,
				this.voxels[vv+VY],
				this.voxels[vv+VX],
				this.voxels[vv+VRED],
				this.voxels[vv+VGREEN],
				this.voxels[vv+VBLUE],
				byteRectOut //if this param is nonnull, paint it here
			);
			if(this.pixelColorAcceleratesVoxelsInsteadOfMovesThem){
				this.voxels[vv+VY] += derivs[0]*moveMul;
				this.voxels[vv+VX] += derivs[1]*moveMul;
			}else{
				this.voxelVels[vv+VY] += derivs[0]*accelMul;
				this.voxelVels[vv+VX] += derivs[1]*accelMul;
			}
			if(this.enable_holdVoxelsYXAtSingleRadius){
				let centerY = byteRectOut.height/2;
				let centerX = byteRectOut.width/2;
				let diffY = this.voxels[vv+VY]-centerY;
				let diffX = this.voxels[vv+VX]-centerX;
				let observedRadius = Math.hypot(diffY, diffX);
				let newRadius = this.holdVoxelsYXAtSingleRadius;
				let changeRadius = newRadius-observedRadius;
				let mul = changeRadius/observedRadius;
				this.voxels[vv+VY] += diffY*mul;
				this.voxels[vv+VX] += diffX*mul;
			}
			if(this.holdVoxelsYXInByteRect){
				this.voxels[vv+VY] = between(minY, this.voxels[vv+VY], maxY);
				this.voxels[vv+VX] = between(minX, this.voxels[vv+VX], maxX);
			}
			
			//FIXME why are these 3 lines causing movement?
			this.voxels[vv+VRED] += derivs[2]*colorMul;
			this.voxels[vv+VGREEN] += derivs[3]*colorMul;
			this.voxels[vv+VBLUE] += derivs[4]*colorMul;
			
			
			this.voxels[vv+VY] = between(0, this.voxels[vv+VY], byteRectIn.height-1);
			this.voxels[vv+VX] = between(0, this.voxels[vv+VX], byteRectIn.width-1);
			this.voxels[vv+VRED] = between(0, this.voxels[vv+VRED], 255);
			this.voxels[vv+VGREEN] = between(0, this.voxels[vv+VGREEN], 255);
			this.voxels[vv+VBLUE] = between(0, this.voxels[vv+VBLUE], 255);
		}
		if(this.displaySprings){
			//TODO optimize loop for ifDisplaySpringsThenOnlyThoseFromThisVoxelIndexOrNullToDisplayAll!=null to loop over far fewer springs instead of skipping in loop body
			for(let s=0; s<this.numSprings; s++){
				let voxA = s%this.numVoxels;
				let voxB = (s-voxA)/this.numVoxels;
				if(
					(this.ifDisplaySpringsThenOnlyThoseFromThisVoxelIndexOrNullToDisplayAll == null)
					|| ((!this.displayPotentialEnergyFromSelectedVsTo) && (voxA == this.ifDisplaySpringsThenOnlyThoseFromThisVoxelIndexOrNullToDisplayAll))
					|| ((this.displayPotentialEnergyFromSelectedVsTo) && (voxB == this.ifDisplaySpringsThenOnlyThoseFromThisVoxelIndexOrNullToDisplayAll)) //TODO remove duplicate springs (a->b and b->a)
				){ //display spring
					let aa = voxA*VARSPERVOXEL;
					let bb = voxA*VARSPERVOXEL;
					let ss = s*VARSPERSPRING;
					
					//potentialEnergy of spring ranges weak to strength
					let weak = this.springs[ss+SWEAK];
					let strength = this.springs[ss+SSTRENGTH];
					
					/*
					let strength = this.springs[ss+SSTRENGTH];
					byteRectOut.paintLineYXYXRGB(
						this.voxelVar(voxA,VY),
						this.voxelVar(voxA,VX),
						this.voxelVar(voxB,VY),
						this.voxelVar(voxB,VX),
						//TODO color proportional to strength instead of the average color of the voxels
						(this.voxelVar(voxA,VRED)+this.voxelVar(voxB,VRED)), //FIXME ave /2
						(this.voxelVar(voxA,VGREEN)+this.voxelVar(voxB,VGREEN)),
						(this.voxelVar(voxA,VBLUE)+this.voxelVar(voxB,VBLUE))
					);
					*/
					let fromX = this.voxelVar(voxA,VX);
					let fromY = this.voxelVar(voxA,VY);
					let fromZ = this.voxelVar(voxA,VZ);
					let toX = this.voxelVar(voxB,VX);
					let toY = this.voxelVar(voxB,VY);
					let toZ = this.voxelVar(voxB,VZ);
					let diffX = toX-fromX;
					let diffY = toY-fromY;
					let diffZ = toZ-fromZ;
					let len = Math.hypot(diffX, diffY, diffZ);
					let numPoints = Math.ceil(len*1.5);
					for(let i=-100; i<numPoints+100; i++){ //display potentialEnergy of that spring as brightness at many points along line between voxA and voxB
					//for(let i=0; i<numPoints; i++){ //display potentialEnergy of that spring as brightness at many points along line between voxA and voxB
						//TODO optimize
						let y = Math.round(fromY+diffY*i/numPoints);
						let x = Math.round(fromX+diffX*i/numPoints);
						//let possibleLen = Math.hypot(x-fromX, y-fromY); //this only works if all points are directly between the 2 voxels, not past them.
						let possibleLen = len*i/numPoints;
						let possiblePotentialEnergy = this.potentialEnergyOfSpringIfLen(s, possibleLen);
						let possiblePotentialEnergyAsFraction = (possiblePotentialEnergy-weak)/(strength-weak);
						let brightRelToFractionRange = -this.displaySpringBrightnessSubtract + this.displaySpringContrast*possiblePotentialEnergyAsFraction; //not always a fraction
						//let brightRelToFractionRange = this.displaySpringBrightness + this.displaySpringContrast*possiblePotentialEnergy; //not always a fraction
						//brightRelToFractionRange = Math.random();
						let bright = between(0,brightRelToFractionRange*256, 255);
						bright = 255-bright; //FIXME?
						let redByte = bright;
						let greenByte = redByte;
						let blueByte = redByte;
						byteRectOut.atYXWriteRGB(y, x, redByte, greenByte, blueByte);
					}
					
					
					/*
					ByteRect.prototype.paintLineYXYXRGB = function(fromY, fromX, toY, toX, redByte, greenByte, blueByte){
						let diffY = toY-fromY;
						let diffX = toX-fromX;
						let len = Math.hypot(diffY, diffX);
						let numPoints = Math.ceil(len*1.5);
						for(let i=0; i<numPoints; i++){
							//TODO optimize
							let y = Math.round(fromY+diffY*i/numPoints);
							let x = Math.round(fromX+diffX*i/numPoints);
							this.atYXWriteRGB(y, x, redByte, greenByte, blueByte);
						}
					};*/
				}
			}
		}
		
		let aveDistDecay = between(0,colorMul*.1,1); //TODO what number?
		let springStrengthDecay = 100*aveDistDecay; //TODO what number?
		this.updateAverageDistancesAndRestLens(this.decaySAVEDIST);
		this.updateSpringStrengths(this.decaySSTRENGTH);
		this.adjustVoxelVelocitiesBySprings(dt);
		this.adjustPositionsByVelocities(this.voxels, this.voxelVels, dt);
		this.adjustVelocitiesBetweenPairsOfVoxelsBasedOnVelocitiesAlongSpringsSoIfSpringIsntChangingLengthTheresNoFriction(dt);
		let frictionMult = 1-between(0, this.decayVoxelVelocities*dt, 1);
		for(let i=0; i<this.voxelVels.length; i++) this.voxelVels[i] *= frictionMult;
		if(!this.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly){
			this.setAllVoxelPositionsAndSpeedsInZDimTo0ToBecome2d();
		}
	};
	
	//byteRectOut should already contain a copy of what came in thru webcam (after flipped andOr other transforms).
	//Some parts are painted over. Others are kept as they are.
	this.displayVoxels = function(byteRectOut){
		let donutRadius = this.testSize/2;
		for(let v=0; v<this.numVoxels; v++){
			let vv = v*VARSPERVOXEL;
			paintDonut(
				byteRectOut,
				this.voxels[vv+VY],
				this.voxels[vv+VX],
				donutRadius-2,
				donutRadius,
				this.voxels[vv+VRED],
				this.voxels[vv+VGREEN],
				this.voxels[vv+VBLUE]
			);
		}
	};
	
	this.paintChilds = function(byteRectOut, aftrans){
		for(let i in this.childs){
			let child = this.childs[i];
			let af = aftransOfAftrans(aftrans, child.aftrans);
			child.paint(byteRectOut, af);
		}
	};

	//read and write a ByteRect, which may be a wrapper of a Uint8Array or of a canvasContext.getImageData(0, 0, canvas.width, canvas.height).data.
	//This is normally called after copying webcam pixels to a canvas, then this paints some "augmented reality" stuff over it,
	//or this may completely replace it such as viewing it from a different 3d position as best it can estimate where things are in 3d from
	//recent 2d webcam inputs.
	//dt is how many seconds passed since last call,
	//regardless of actual time since you might want to simulate it slower or faster than realtime for testing or to reproduce experimental results.
	this.io = function(dt, byteRectIn, byteRectOut){
		//FIXME put all graphics in .paint, but yxrgbDeriv etc does some of the graphics here.
		//For now I'm creating a paintChilds func, which will paint Balls, and calling it at end of this func.
	
		//FIXME what if byteRect is smaller than this test code uses indexs? Most code (todo all) does rectangle intersection where it hangs outside range.
		
		controls = getButtonsJoysticksEtc();
		if(this.gamepadMovesAndRotatesSelectedBall && selectedOb){
			//let rotateHowMuch = 2.1*dt;
			//let resizeHowMuch = rotateHowMuch*.3;
			//let moveHowMuch = rotateHowMuch*5;
			//let af = controllerToAftrans('gamepad0', rotateHowMuch, resizeHowMuch, moveHowMuch);
			
			//let rotateHowMuch = 2.1*dt;
			//let resizeHowMuch = rotateHowMuch*.3;
			//let moveHowMuch = rotateHowMuch*5;
			selectedOb.aftrans = controllerTransformsAftrans('gamepad0', selectedOb.aftrans, dt);
			
			//selectedOb.aftrans = aftransOfAftrans(af, selectedOb.aftrans);
			//selectedOb.aftrans = aftransOfAftrans(selectedOb.aftrans, af);
			
			//selectedOb.aftrans = aftransOfAftrans(af, selectedOb.aftrans);
			//selectedOb.aftrans = transpose4x4(aftransOfAftrans(transpose4x4(selectedOb.aftrans), af));
			//selectedOb.aftrans = transpose4x4(aftransOfAftrans(transpose4x4(selectedOb.aftrans), transpose4x4(af)));
			//selectedOb.aftrans = aftransOfAftrans(transpose4x4(selectedOb.aftrans), af);
			
			//selectedOb.aftrans = aftransOfAftrans(af, selectedOb.aftrans);
			//selectedOb.aftrans = transpose4x4(aftransOfAftrans(af, transpose4x4(selectedOb.aftrans)));
			//selectedOb.aftrans = aftransOfAftrans(af, transpose4x4(selectedOb.aftrans));
			//selectedOb.aftrans = aftransOfAftrans(transpose4x4(af), transpose4x4(selectedOb.aftrans));
			
			
			//selectedOb.aftrans = aftransOfAftrans(inverse4x4(selectedOb.aftrans), af);
			//selectedOb.aftrans = inverse4x4(aftransOfAftrans(inverse4x4(selectedOb.aftrans), af));
			//selectedOb.aftrans = aftransOfAftrans(inverse4x4(af), selectedOb.aftrans);
			//selectedOb.aftrans = aftransOfAftrans(aftransOfAftrans(inverse4x4(selectedOb.aftrans),af), selectedOb.aftrans);
			//selectedOb.aftrans = aftransOfAftrans(aftransOfAftrans(selectedOb.aftrans,af), selectedOb.aftrans);
			//selectedOb.aftrans = inverse4x4(aftransOfAftrans(inverse4x4(selectedOb.aftrans), inverse4x4(af)));
			//selectedOb.aftrans = aftransOfAftrans(inverse4x4(af), selectedOb.aftrans);
			
			//selectedOb.aftrans = aftransOfAftrans(transpose4x4(af), selectedOb.aftrans);
			//selectedOb.aftrans = aftransOfAftrans(af, selectedOb.aftrans);
			//selectedOb.aftrans = transpose4x4(aftransOfAftrans(af, transpose4x4(selectedOb.aftrans)));
			//selectedOb.aftrans = transpose4x4(aftransOfAftrans(af, transpose4x4(selectedOb.aftrans)));
			//selectedOb.aftrans = aftransOfAftrans(selectedOb.aftrans,af);
		}
		
		warnIfStrangeDt(dt);
		byteRectIn.verifySameSizeAs(byteRectOut);
		
		let bytesIn = byteRectIn.bytes;
		let bytesOut = byteRectOut.bytes;
		let len = bytesIn.length;
		
		/*
		//for(let i=0; i<20000; i++) bytes[i+30000] = bytes[i];
		let offset = 0;
		for(let y=0; y<byteRect.height; y++){
			for(let x=0; x<byteRect.width/2; x+=4){
				let temp = bytes[offset+x];
				bytes[offset+x] = bytes[offset+byteRect.width-1-x];
				bytes[offset+byteRect.width-1-x] = temp;
			}
			offset += byteRect.width*4; //bytes per row of pixels
		}
		//for(let i=0; i<20000; i++) bytes[i+30000] = bytes[i];
		
		let pixs = len/4;
		//console.log('pixs='+pixs);
		for(let repeat=0; repeat<10; repeat++){
			for(let evenVsOdd=0; evenVsOdd<2; evenVsOdd++){
				for(let pix=evenVsOdd; pix<pixs-1; pix+=2){
					let j = bytes[pix*4+2];
					let k = bytes[pix*4+4+2];
					//let ave = (j+k)/2;
					let ave = Math.max(j,k); //FIXME
					//let ave = j;
					//let ave = 255;
					bytes[pix*4+2] = ave;
					bytes[pix*4+4+2] = ave;
				}
			}
		}*/
		
		/*
		let targetSum = 255;
		if(this.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU){
			//FIXME this shouldnt modify input ByteRect, but it cant do it to output ByteRect either
			//since that one doesnt get read. Move this to some preprocessing func that happens before Sim.io is called.
			if(1<2) throw 'FIXME see comment about normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU';
			//let end = pixs*4;
			let end = bytes.length;
			for(let i=0; i<end; i+=4){
				let sum = bytes[i+RED]+bytes[i+GREEN]+bytes[i+BLUE];
				let mul = targetSum/sum;
				bytes[i+RED] *= mul;
				bytes[i+GREEN] *= mul;
				bytes[i+BLUE] *= mul;
				//FIXME roundoff, as its probably a Uint8ClampedArray?
			}
		}*/
		
		if(this.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack){
			//TODO optimize: is there something like java.lang.System.arraycopy for Uint8Array and canvas pixels array in js?
			copyBytes(bytesIn, bytesOut);
		}else{
			for(let i=0; i<bytesOut.length; i+=4){
				bytesOut[i+RED] = 0;
				bytesOut[i+GREEN] = 0;
				bytesOut[i+BLUE] = 0;
				bytesOut[i+ALPHA] = 255;
			}
		}
		
		if(this.doTestCirclesDetect_oneCenterMultiSizes){
			this.testCirclesDetect_oneCenterMultiSizes(byteRectIn, byteRectOut);
		}
		
		if(this.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu){
			this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu(byteRectIn, byteRectOut);
		}
		
		if(this.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu){
			this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu(byteRectIn, byteRectOut);
		}
		
		this.voxelsAndSpringsIO(dt, byteRectIn, byteRectOut);
		
		if(this.randomlyChangeFirstBallsAftransGradually && (this.childs.length > 0)){
			for(let i=0; i<16; i++){
				this.childs[0].aftrans[i] += (Math.random()*2-1)*25*dt;
			}
		}
		
		let firstBall = this.childs[0];
		if(firstBall !== undefined){ //TODO checkbox for use mouse to paint on ball or not
			//mouseYFraction = .5; //FIXME remove this
			//mouseXFraction = 0; //FIXME remove this
			let poleIndex = between(0,Math.floor(firstBall.numPoleAngles()*mouseYFraction),firstBall.numPoleAngles()-1);
			let equatorIndex = between(0,Math.floor(firstBall.numAngles*mouseXFraction),firstBall.numAngles-1);
			let baxelIndex = poleIndex*firstBall.numAngles+equatorIndex;
			//let baxelIndex = equatorIndex*firstBall.numPoleAngles()+poleIndex; //FIXME swap these 2 dims?
			//if(Math.random()<.3) console.log('poleIndex='+poleIndex+' equatorIndex='+equatorIndex+' baxelIndex='+baxelIndex
			//	+' normXYZ='+JSON.stringify(firstBall.normXYZOfBaxelIndex(baxelIndex)));
			let i = baxelIndex*VARSPERBAXEL;
			firstBall.baxels[i+BRED] = 255;//randByte();
			firstBall.baxels[i+BGREEN] = 0;//randByte();
			firstBall.baxels[i+BBLUE] = 0;//randByte();
		}
		
		this.paintChilds(byteRectOut, newIdentAftrans()); //FIXME only call this once in io(...)
		
		byteRectOut.writeSafeRGBA(mouseY, mouseX, 255, 255, 255);
		
		//console.log('energy='+this.energy());
		
	};
	
	/** A slow experiment (TODO GPU.js) to put a circle at screen center and have person move a ball
	that exact place to make the circle change color depending on how much edge detection is there.
	*/
	this.testCirclesDetect_oneCenterMultiSizes = function(byteRectIn, byteRectOut){
		let cx = byteRectIn.width/2;
		let cy = byteRectIn.height/2
		let minRadius = 1;
		let maxRadius = 60;		
		for(let radius=minRadius; radius<=maxRadius; radius++){
			let numPoints = Math.ceil(radius*2*Math.PI*1.7);
			let brightnessSum = 0;
			let anglePerPoint = 2*Math.PI/numPoints;
			for(let i=0; i<numPoints; i++){
				let angle = anglePerPoint*i;
				let x = cx+radius*Math.cos(angle);
				let y = cy+radius*Math.sin(angle);
				let brightObserved = byteRectIn.readBrightnessSafe(y,x);
				brightnessSum += brightObserved;
				//let brightWrite = between(0, brightObserved, 255);
				//byteRectOut.writeSafeRGBA(y, x, brightWrite, 0, 0);
			}
			let aveBrightness = brightnessSum/numPoints; //at circle
			let multiplyAveBrightness = 1.5;
			let displayBrightness = between(0, aveBrightness*multiplyAveBrightness, 255);
			let oneThirdCircle = 2/3*Math.PI;
			let twoThirdsCircle = 4/3*Math.PI;
			for(let i=0; i<numPoints; i++){
				let angle = anglePerPoint*i;
				let x = cx+radius*Math.cos(angle);
				let y = cy+radius*Math.sin(angle);
				//byteRectOut.writeSafe(y, x, RED, 255-displayBrightness);
				if((i%30) == 0){ //display spread out dots just so you know where the circle is, to move ball there
					byteRectOut.writeSafeRGBA(y, x,
						128+128*Math.sin(angle),
						128+128*Math.sin(oneThirdCircle+angle),
						128+128*Math.sin(twoThirdsCircle+angle)
					);
				}else{
					//byteRectOut.writeSafeRGBA(y, x, 0, displayBrightness, displayBrightness);
					byteRectOut.writeSafe(y, x, GREEN, displayBrightness, displayBrightness);
					//byteRectOut.writeSafeRGBA(y, x, 0, 256*i/numPoints, 255-256*i/numPoints);
				}
			}
		}
	};
	
	this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu = function(byteRectIn, byteRectOut){
	
		let maxScore = -1;
		let centerXOfCircleOfMaxScore = 0;
		let centerYOfCircleOfMaxScore = 0;
		let radiusOfCircleOfMaxScore = 0;
		
		let ccx = byteRectIn.width/2;
		let ccy = byteRectIn.height/2
		
		let howFarFromScreenCenterToLookForBall = 10;
		
		let minRadius = 20;
		let maxRadius = 50;
		for(let cy=ccy-howFarFromScreenCenterToLookForBall; cy<ccy+howFarFromScreenCenterToLookForBall; cy++){
			for(let cx=ccx-howFarFromScreenCenterToLookForBall; cx<ccx+howFarFromScreenCenterToLookForBall; cx++){
				for(let radius=minRadius; radius<=maxRadius; radius++){
					let numPoints = Math.ceil(radius*2*Math.PI*1.7);
					let brightnessSum = 0;
					let anglePerPoint = 2*Math.PI/numPoints;
					for(let i=0; i<numPoints; i++){
						let angle = anglePerPoint*i;
						let x = cx+radius*Math.cos(angle);
						let y = cy+radius*Math.sin(angle);
						let brightObserved = byteRectIn.readBrightnessSafe(y,x);
						brightnessSum += brightObserved;
						//let brightWrite = between(0, brightObserved, 255);
						//byteRectOut.writeSafeRGBA(y, x, brightWrite, 0, 0);
					}
					let aveBrightness = brightnessSum/numPoints; //at circle
					
					let score = aveBrightness; //TODO consider theres more data points in bigger circle, so stdDev relevant?
					if(maxScore < score){ //found a circle in webcam pixels thats more likely to be a ball than best found so far this video frame
						maxScore = score;
						radiusOfCircleOfMaxScore = radius;
						centerYOfCircleOfMaxScore = cy;
						centerXOfCircleOfMaxScore = cx;
					}
					
					/*
					let multiplyAveBrightness = 1.5;
					let displayBrightness = between(0, aveBrightness*multiplyAveBrightness, 255);
					let oneThirdCircle = 2/3*Math.PI;
					let twoThirdsCircle = 4/3*Math.PI;
					for(let i=0; i<numPoints; i++){
						let angle = anglePerPoint*i;
						let x = cx+radius*Math.cos(angle);
						let y = cy+radius*Math.sin(angle);
						//byteRectOut.writeSafe(y, x, RED, 255-displayBrightness);
						if((i%30) == 0){ //display spread out dots just so you know where the circle is, to move ball there
							byteRectOut.writeSafeRGBA(y, x,
								128+128*Math.sin(angle),
								128+128*Math.sin(oneThirdCircle+angle),
								128+128*Math.sin(twoThirdsCircle+angle)
							);
						}else{
							//byteRectOut.writeSafeRGBA(y, x, 0, displayBrightness, displayBrightness);
							byteRectOut.writeSafe(y, x, GREEN, displayBrightness, displayBrightness);
							//byteRectOut.writeSafeRGBA(y, x, 0, 256*i/numPoints, 255-256*i/numPoints);
						}
					}*/
				}
			}
		}
		byteRectOut.paintCircleRadiusYXRGBSafe(radiusOfCircleOfMaxScore, centerYOfCircleOfMaxScore, centerXOfCircleOfMaxScore, 255, 255, 255);
	};
	
	this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu_gpuKernel = null;
	//this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu_gpuKernel_jsonWasLogged = false;
	
	this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu = function(byteRectIn, byteRectOut){
	
		if(!this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu_gpuKernel){
			this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu_gpuKernel =
				gpu().createKernel(function(xyBrightFloats, height, width, yFrom, xFrom, radiusFrom, radiusToExcl, pointsPerCircle){
					const cy = yFrom+this.thread.y;
					const cx = xFrom+this.thread.x;
					let maxScore = -1;
					let radiusOfCircleOfMaxScore = 0;
					for(let radius=radiusFrom; radius<radiusToExcl; radius++){
						//let numPoints = Math.ceil(radius*2*Math.PI*1.7);
						let brightnessSum = 0;
						let anglePerPoint = 2*Math.PI/pointsPerCircle;
						for(let i=0; i<pointsPerCircle; i++){
							let angle = anglePerPoint*i;
							let x = Math.floor(cx+radius*Math.cos(angle));
							let y = Math.floor(cy+radius*Math.sin(angle));
							//let brightObserved = byteRectIn.readBrightnessSafe(y,x);
							
							//FIXME dont let this go past the 4 edges of the rectangle pic in 1d xyBrightFloats
							
							let brightObserved = xyBrightFloats[y*width+x];
							brightnessSum += brightObserved;
							//let brightWrite = between(0, brightObserved, 255);
							//byteRectOut.writeSafeRGBA(y, x, brightWrite, 0, 0);
						}
						let aveBrightness = brightnessSum/pointsPerCircle; //at circle
						
						let score = aveBrightness; //TODO consider theres more data points in bigger circle, so stdDev relevant?
						if(maxScore < score){ //found a circle in webcam pixels thats more likely to be a ball than best found so far this video frame
							maxScore = score;
							radiusOfCircleOfMaxScore = radius;
						}
					}
					
					//maxScore = xyBrightFloats[cy*width+cx]; //FIXME remove this
					//maxScore = cx+cy; //FIXME remove this
					
					return [radiusOfCircleOfMaxScore, maxScore];
				},{
					dynamicOutput: true
				});
		}
		
	
		let monochromePicAsFloats = byteRectIn.brightnessFloats(); //monochromePicAsFloats.length*4 == byteRectIn.length
		let h = byteRectIn.height;
		let w = byteRectIn.width;
		
		let ccx = Math.floor(w/2);
		let ccy = Math.floor(h/2);
		
		
		let howFarFromScreenCenterToLookForBall = 100; //TODO whole byteRectIn size (half of that both directions) but careful not to go off edges
		//let howFarFromScreenCenterToLookForBall = 30; //TODO whole byteRectIn size (half of that both directions) but careful not to go off edges
		let yFrom = ccy-howFarFromScreenCenterToLookForBall;
		let yToExcl = ccy+howFarFromScreenCenterToLookForBall;
		let xFrom = ccx-howFarFromScreenCenterToLookForBall;
		let xToExcl = ccx+howFarFromScreenCenterToLookForBall;
		let yRange = yToExcl-yFrom;
		let xRange = xToExcl-xFrom;
		let radiusFrom = 20;
		let radiusToExcl = 51;
		let pointsPerCircle = Math.ceil((radiusToExcl-1)*2*Math.PI*1.7);
		
		//FIXME is it [yRange, xRange] or [xRange, yRange]? Check which order it is in setOutput vs this.thread.x and this.thread.y
		this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu_gpuKernel.setOutput([xRange, yRange]);
		
		//gpuOut[y-yFrom][x-xFrom][0 for radius of max score circle at that y x, or 1 for max score]
		let gpuOut = this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu_gpuKernel(
			monochromePicAsFloats, h, w, yFrom, xFrom, radiusFrom, radiusToExcl, pointsPerCircle);
		
		/*if(!this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu_gpuKernel_jsonWasLogged){
			//test gpujs toJSON. It works, but is bigger than I want logged to console (24kB)
			this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu_gpuKernel_jsonWasLogged = true;
			console.log('First call of kernel: '+JSON.stringify(this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu_gpuKernel.toJSON()));
		}*/
			
		let centerYOfCircleOfMaxScore = 0;
		let centerXOfCircleOfMaxScore = 0;
		let radiusOfCircleOfMaxScore = 0;
			
		let minScore = Infinity;
		let maxScore = -Infinity;
		for(let cy=yFrom; cy<yToExcl; cy++){
			for(let cx=xFrom; cx<xToExcl; cx++){
				let bestScoreAtYX = gpuOut[cy-yFrom][cx-xFrom][1];
				minScore = Math.min(minScore,bestScoreAtYX);
				if(maxScore < bestScoreAtYX){
					maxScore = bestScoreAtYX;
					centerYOfCircleOfMaxScore = cy;
					centerXOfCircleOfMaxScore = cx;
					let bestRadiusAtYX = gpuOut[cy-yFrom][cx-xFrom][0];
					radiusOfCircleOfMaxScore = bestRadiusAtYX;
				}
			}
		}
		if(minScore >= maxScore){
			console.log('WARNING: minScore='+minScore+' maxScore='+maxScore+' so ending early testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu');
			return;
		}

		for(let cy=yFrom; cy<yToExcl; cy++){
			for(let cx=xFrom; cx<xToExcl; cx++){
				let bestRadiusAtYX = gpuOut[cy-yFrom][cx-xFrom][0];
				let bestScoreAtYX = gpuOut[cy-yFrom][cx-xFrom][1];
				let normedBestScoreAtYX = (bestScoreAtYX-minScore)/(maxScore-minScore); //0..1
				let displayBright = normedBestScoreAtYX*255.999;
				//display circle center as brightest, of many possible circle centers, proportional to score for how much it might be a circle
				//byteRectOut.writeSafe(cy, cx, BLUE, displayBright);
				byteRectOut.writeSafeBright(cy, cx, displayBright);
			}
		}
		
		byteRectOut.paintCircleRadiusYXRGBSafe(radiusOfCircleOfMaxScore, centerYOfCircleOfMaxScore, centerXOfCircleOfMaxScore, 255, 255, 255);
		
		
		/*
		Tested this in another file, "return [sum, sum*2, sum*sum, sum*10];" where sum var exists in kernel,
		does create a 3d array, when output size is set to 2d, of that many Float32Array(4).
		
		FIXME should it return 2 (radius,score) of 2d (x, y, just find the best circle centered there of all radius)
			or 1 (score) of 3d (x, y, radius)?
		3d could be an IO bottleneck (if doing the whole video size), even though its a 4d amount of compute.
		
		how to get 2 output numbers per gpu thread? I want to return radius and score. 
		Score may just be ave brightness at the circle, but I'll need to tune that to prefer bigger circles,
		and maybe also to prefer circles which are touching more yellow (tennis ball colored) pixels,
		by trying other equations.
		
		Found this: https://github.com/gpujs/gpu.js/issues/405 "Return more than one value in the main kernel. #405"
		 -> "This is solved in v2 rc13.". Which one did they mean in https://github.com/gpujs/gpu.js/releases ?
		or did they mean 2.0 rc13 (release candidate for version 2)?
		Also https://github.com/gpujs/gpu.js/issues/397
		
		https://github.com/gpujs/gpu.js says...
		
		Declaring variables/functions within kernels

		GPU.js makes variable declaration inside kernel functions easy. Variable types supported are:

			Number (Integer or Number), example: let value = 1 or let value = 1.1
			Boolean, example: let value = true
			Array(2), example: let value = [1, 1]
			Array(3), example: let value = [1, 1, 1]
			Array(4), example: let value = [1, 1, 1, 1]
			private Function, example: function myFunction(value) { return value + 1; }

		Number kernel example:

		const kernel = gpu.createKernel(function() {
		 const i = 1;
		 const j = 0.89;
		 return i + j;
		}).setOutput([100]);

		Boolean kernel example:

		const kernel = gpu.createKernel(function() {
		  const i = true;
		  if (i) return 1;
		  return 0;
		}).setOutput([100]);

		Array(2) kernel examples: Using declaration

		const kernel = gpu.createKernel(function() {
		 const array2 = [0.08, 2];
		 return array2;
		}).setOutput([100]);

		Directly returned

		const kernel = gpu.createKernel(function() {
		 return [0.08, 2];
		}).setOutput([100]);

		Array(3) kernel example: Using declaration

		const kernel = gpu.createKernel(function() {
		 const array2 = [0.08, 2, 0.1];
		 return array2;
		}).setOutput([100]);

		Directly returned

		const kernel = gpu.createKernel(function() {
		 return [0.08, 2, 0.1];
		}).setOutput([100]);

		Array(4) kernel example: Using declaration

		const kernel = gpu.createKernel(function() {
		 const array2 = [0.08, 2, 0.1, 3];
		 return array2;
		}).setOutput([100]);

		Directly returned

		const kernel = gpu.createKernel(function() {
		 return [0.08, 2, 0.1, 3];
		}).setOutput([100]);

		private Function kernel example:

		const kernel = gpu.createKernel(function() {
		  function myPrivateFunction() {
			return [0.08, 2, 0.1, 3];
		  }
		  
		  return myPrivateFunction(); // <-- type inherited here
		}).setOutput([100]);
		*/
		
		
		
		
		
		
		
		
	
		/*
		let maxScore = -1;
		let centerXOfCircleOfMaxScore = 0;
		let centerYOfCircleOfMaxScore = 0;
		let radiusOfCircleOfMaxScore = 0;
		
		let ccx = byteRectIn.width/2;
		let ccy = byteRectIn.height/2
		
		let howFarFromScreenCenterToLookForBall = 10;let howFarFromScreenCenterToLookForBall = 10;
		
		let minRadius = 20;
		let maxRadius = 50;
		for(let cy=yFrom; cy<yToExcl; cy++){
			for(let cx=xFrom; cx<xToExcl; cx++){
				for(let radius=minRadius; radius<=maxRadius; radius++){
					let numPoints = Math.ceil(radius*2*Math.PI*1.7);
					let brightnessSum = 0;
					let anglePerPoint = 2*Math.PI/numPoints;
					for(let i=0; i<numPoints; i++){
						let angle = anglePerPoint*i;
						let x = cx+radius*Math.cos(angle);
						let y = cy+radius*Math.sin(angle);
						let brightObserved = byteRectIn.readBrightnessSafe(y,x);
						brightnessSum += brightObserved;
						//let brightWrite = between(0, brightObserved, 255);
						//byteRectOut.writeSafeRGBA(y, x, brightWrite, 0, 0);
					}
					let aveBrightness = brightnessSum/numPoints; //at circle
					
					let score = aveBrightness; //TODO consider theres more data points in bigger circle, so stdDev relevant?
					if(maxScore < score){ //found a circle in webcam pixels thats more likely to be a ball than best found so far this video frame
						maxScore = score;
						radiusOfCircleOfMaxScore = radius;
						centerYOfCircleOfMaxScore = cy;
						centerXOfCircleOfMaxScore = cx;
					}
				}
			}
		}
		byteRectOut.paintCircleRadiusYXRGBSafe(radiusOfCircleOfMaxScore, centerYOfCircleOfMaxScore, centerXOfCircleOfMaxScore, 255, 255, 255);
		*/
		
		
	};
	
	//Example: sim.springVar(17, 30, SFRICTION) returns the friction of the spring between 2 voxels whose indexs are 17 and 30.
	//If writeVal optional param is given, writes the var, else just reads it. either way returns its val at the end.
	//This is only for a few small things here and there, not nearly as efficient as using GPU.js or a loop over the Float32Arrays.
	this.springVar = function(voxA, voxB, whichSpringVar, writeVal){
		let index = this.springVarIndex(voxA,voxB,whichSpringVar);
		if(writeVal !== undefined) this.springs[index] = writeVal; //TODO use between(...) to truncate into allowed range per which*var?
		return this.springs[index];
	};

	this.springVarIndex = function(voxA, voxB, whichSpringVar){
		return (voxA*this.numVoxels+voxB)*VARSPERSPRING+whichSpringVar;
	};
	
	//like springVar(...), can read or write the var.
	this.voxelVar = function(vox, whichVoxelVar, writeVal){
		let index = this.voxelVarIndex(vox,whichVoxelVar);
		if(writeVal !== undefined) this.voxels[index] = writeVal; //TODO use between(...) to truncate into allowed range per which*var?
		return this.voxels[index];
	};
	
	//like springVar(...), can read or write the var.
	this.voxelVelVar = function(vox, whichVoxelVar, writeVal){
		let index = this.voxelVarIndex(vox,whichVoxelVar);
		if(writeVal !== undefined) this.voxelVels[index] = writeVal; //TODO use between(...) to truncate into allowed range per which*var?
		return this.voxelVels[index];
	};
	
	//returns index for this.voxels (positions) and this.voxelVels (velocities)
	this.voxelVarIndex = function(vox, whichVoxelVar){
		return vox*VARSPERVOXEL+whichVoxelVar;
	};

	/** Range sweak to sstrength. 0 <= spr < this.numSprings.
	UPDATE: Going to use a potentialEnergy equation thats same as spring when near atRestLen (is a parabola) but is sigmoidlike when gets farther away.
	OLD: "elastic potential energy = 0.5 × spring constant × (extension)^2" -- https://www.bbc.co.uk/bitesize/guides/z9hk3k7/revision/3
	*/
	this.potentialEnergyOfSpring = function(spr){
		//TODO optimize, should this func take 2 voxel indexs instead?
		return this.potentialEnergyOfSpringIfLen(spr, this.distanceSpring(spr));
	};
	
	//aka force (if mass is 1, and as of 2021-7-25 it always is, then this is also acceleration)
	this.potentialEnergyDerivativeOfSpring = function(spr){
		return this.potentialEnergyDerivativeOfSpringIfLen(spr, this.distanceSpring(spr));
	};
	
	//at a possible distance between 2 voxels: aka force (if mass is 1, and as of 2021-7-25 it always is, then this is also acceleration)
	this.potentialEnergyDerivativeOfSpringIfLen = function(spr, len){
		//let epsilon = len*EPSILON; //Are the nans caused by epsilon being 0 cuz epsilon is caled by len of 0?
		let epsilon = Math.max(len,1)*EPSILON;
		return (this.potentialEnergyOfSpringIfLen(spr,len+epsilon)-this.potentialEnergyOfSpringIfLen(spr,len))/epsilon;
	};
	
	//0 <= spr < this.numSprings.
	//len is any nonnegative number, such as distance between 2 voxels or that plus an epsilon,
	//or (TODO, if needed?) various possible lengths explored by harmonySearch of possible next voxel velocities.
	//FIXME a spring from voxel to itself, as of 2021-7-25, is getting NaN potentialenergy. why? Are the nans caused by epsilon being 0 cuz epsilon is caled by len of 0?
	this.potentialEnergyOfSpringIfLen = function(spr, len){
		if(len == 0) return 0; //FIXME should be [...sstrength]? this is to get rid of those nans. Are the nans caused by epsilon being 0 cuz epsilon is caled by len of 0?
		
		
		//FIXME What about duplicate springs (only need numVoxels*(numVoxels-1)/2 springs, if dense, and much less if sparse)?
		let ss = spr*VARSPERSPRING;
		
		//UPDATE: potentialEnergy of spring ranges SWEAK to SSTRENGTH, so strength scales it around weak.
		//OLD: strength 0 means spring does not exist. strength scales the potentialEnergy added by this spring.
		let weak = this.springs[ss+SWEAK];
		let strength = this.springs[ss+SSTRENGTH];
		if((weak < 0) || (strength < weak)) throw 'weak='+weak+' strength='+strength;
		
		//proportional (mult by strength) max potentialEnergy everywhere on the curve of this spring.
		let downfrom = this.springs[ss+SDOWNFROM];
		/*FIXME use downfrom andOr heat? how about that diffeq of how much to add to heat based on a position and a dt andOr and maybe also velocity?
		FIXME the potentialEnergyOfSpring needs to be duplicated, unless its called twice with epsilon difference of restlen,
			duplicated in the code that actually adjusts velocities of voxels (movebysprings or something like that, what was it called?).
		FIXME should there be a gravity param?
		FIXME somewhere else, change springvars each physics cycle in a way that doesnt change its potentialEnergy at that position.
		*/
		
		//similar to stdDev of a bellcurve but its more like 1/(1+x^2) and if it where that equation then sWide is 1 cuz
		//half the "area under the curve" of that is in -1..1. The actual equation is scaled differently and subtracted
		//from SDOWNFROM (so is vertically flipped) and has something added to repel voxels which are too near.
		let swide = this.springs[ss+SWIDE];
		
		//restlen is like the bellcurve average, if swide is like the stdDev, even though its not a bellcurve only slightly similar shape.
		let restLen = this.springs[ss+SRESTLEN];
		
		let lenDiff = restLen-len;
		let lenDiff_over_swide = lenDiff/swide;
		//let lenDiff_over_swide = lenDiff*swide; //FIXME rename this var, but it seems that swide needs to be used as 1/swide cuz of the way the parabola is defined in 1/(1+...)
		
		//range 0 (if len==Infinity) to 1 (if len==0). Is .5 at repelMidDist.
		//Its important that min and max possible potentialEnergy be known, so things like 1/len are not allowed.
		let lenOverRepelmiddist = len/this.repelMidDist;
		let repelCurve = 1/(1+lenOverRepelmiddist*lenOverRepelmiddist);
		
		//range 0 (if len==restLen) to 1 (limit as Math.abs(len-restLen) --> Infinity).
		//is a parabola near lenDiff==0, and farther away levels off to have derivative approaching 0.
		let springCurve = 1-1/(1+lenDiff_over_swide*lenDiff_over_swide);
		
		let weightDivide = 1+this.repelTimesMoreThanSpring;
		let springWeight = 1/weightDivide;
		let repelWeight = this.repelTimesMoreThanSpring/weightDivide;
		//springWeight+repelWeight==1 (except roundoff)
		
		//range 0 to 1
		let combinedCurve = springWeight*springCurve + repelWeight*repelCurve;
		
		//let potentialEnergy = .5*this.springs[ss+SSTRENGTH]*lenDiff*lenDiff; //normal spring physics
		
		//range SWEAK to SSTRENGTH
		let potentialEnergy = weak+(strength-weak)*combinedCurve; //Like 1/(1+x^2)+repel except scaled a few ways, a potentialEnergy func.
		
		//in case roundoff puts it slightly outside allowed range.
		potentialEnergy = between(weak, potentialEnergy, strength);
		
		return potentialEnergy;
	};
	
	//does not modify byteRect. returns a new one.
	this.doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls = function(byteRect){
		let inb = byteRect.bytes;
		let ret = new ByteRect(new Uint8Array(byteRect.bytes.length), byteRect.height, byteRect.width);
		let retb = ret.bytes;
		for(let i=ALPHA; i<retb.length; i+=4) retb[i] = 255; //visible
		let muly = ret.width*4;
		let mulx = 4;
		let border = 1;
		
		for(let y=border; y<ret.height-border; y++){
			let byteIndex = y*muly;
			//for(let x=border; x<xEnd; x++){
			for(let x=border; x<ret.width-border; x++){
				
				/*
				let hereRed = inb[byteIndex+RED];
				let hereGreen = inb[byteIndex+GREEN]
				let hereBlue = inb[byteIndex+BLUE];
				let sumOfSquaredDiffs = 0;
				let sumWeights = 0;
				for(let dy=-border; dy<=border; dy++){
					for(let dx=-border; dx<=border; dx++){
						let thereIndex = byteIndex + muly*dy + mulx*dx;
						let thereRed = inb[thereIndex+RED]; //when dx==0 and dy==0, here is there.
						let thereGreen = inb[thereIndex+GREEN];
						let thereBlue = inb[thereIndex+BLUE];
						let redDiff = hereRed-thereRed;
						let greenDiff = hereGreen-thereGreen;
						let blueDiff = hereBlue-thereBlue;
						let weight = ((dx==0) && (dy==0)) ? 0 : (1/(dx*dx + dy*dy));
						//let weight = ((dx==0) && (dy==0)) ? 0 : (1/Math.hypot(dx,dy));
						sumOfSquaredDiffs += weight*(redDiff*redDiff + greenDiff*greenDiff + blueDiff*blueDiff);
						sumWeights += weight;
					}
				}
				let aveSquaredDiff = sumOfSquaredDiffs/sumWeights;
				//let aveSquaredDiff = sumOfSquaredDiffs/(border*border-1); //-1 to not count when dx==0 and dy==0
				let bright = aveSquaredDiff*.05;
				//let bright = aveSquaredDiff*.14;
				*/
				
				
				let dxdred = inb[byteIndex+RED]-inb[byteIndex-mulx+RED];
				let dxdgreen = inb[byteIndex+GREEN]-inb[byteIndex-mulx+GREEN];
				let dxdblue = inb[byteIndex+BLUE]-inb[byteIndex-mulx+BLUE];
				let dydred = inb[byteIndex+RED]-inb[byteIndex-muly+RED];
				let dydgreen = inb[byteIndex+GREEN]-inb[byteIndex-muly+GREEN];
				let dydblue = inb[byteIndex+BLUE]-inb[byteIndex-muly+BLUE];
				let dxydred = inb[byteIndex+RED]-inb[byteIndex-muly-mulx+RED];
				let dxydgreen = inb[byteIndex+GREEN]-inb[byteIndex-muly-mulx+GREEN];
				let dxydblue = inb[byteIndex+BLUE]-inb[byteIndex-muly-mulx+BLUE];
				let dxydred2 = inb[byteIndex+RED]-inb[byteIndex-muly+mulx+RED];
				let dxydgreen2 = inb[byteIndex+GREEN]-inb[byteIndex-muly+mulx+GREEN];
				let dxydblue2 = inb[byteIndex+BLUE]-inb[byteIndex-muly+mulx+BLUE];
				let colorDiffSquared = dxdred*dxdred + dxdgreen*dxdgreen + dxdblue*dxdblue
					+ dydred*dydred + dydgreen*dydgreen + dydblue*dydblue
					+ dxydred*dxydred + dxydgreen*dxydgreen + dxydblue*dxydblue
					+ dxydred2*dxydred2 + dxydgreen2*dxydgreen2 + dxydblue2*dxydblue2;
				//let bright = between(0, colorDiffSquared*.02, 255);
				let bright = between(0, colorDiffSquared*.1, 255);
				
				
				//let bright = between(0, colorDiffSquared*.02, 255);
				//let bright = between(0, Math.sqrt(colorDiffSquared)*5, 255);
				
				let retRed = bright;
				let retGreen = bright;
				let retBlue = bright;
				retb[byteIndex+RED] = retRed;
				retb[byteIndex+GREEN] = retGreen;
				retb[byteIndex+BLUE] = retBlue;
				byteIndex += 4; //optimize using += 4 instead of *muly  and *mulx
			}
		}
		
		
		/*let border = 3;
		//let weights = []; //size (border+1+border)^2. A convolutional weightedSum at each pixel not too near byteRect edges.
		//for(let dy=-border; dy<=border; dy++){
		//	for(let dx=-border; dx<=border; dx++){
		//		weights.push(TODO);
		//	}
		//}
		for(let y=border; y<yEnd; y++){
			let byteIndex = y*muly;
			//for(let x=border; x<xEnd; x++){
			for(let x=border; x<xEnd; x++){
				let retRed = 0;
				let retGreen = 0;
				let retBlue = 0;
				FIXME
				retb[byteIndex+RED] = retRed;
				retb[byteIndex+GREEN] = retGreen;
				retb[byteIndex+BLUE] = retBlue;
				byteIndex += 4; //optimize using += 4 instead of *muly  and *mulx
			}
		}
		*/
		
		return ret;
	};
	
	this.doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_kernel = null;
	
	//func of ByteRect.bytes to Float32Array (size bytes.length/4) of edge detection.
	//Unlike doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls which returns ByteRect,
	//this returns Float32Array (UPDATE: returnByterectElseFloats).
	this.doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu = function(byteRect, returnByterectElseFloats, allowBytesIntoGpu){
		//FIXME can gpujs return Uint8ClampedArray? Or just Uint8Array? Which do I prefer? Uint8Array is probably faster, and just takes the low 8 bits.
		//https://github.com/gpujs/gpu.js/issues/441
	
		//func of ByteRect.bytes to Float32Array (size bytes.length/4) of edge detection.
		if(!this.doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_kernel){
			this.doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_kernel =
				gpu().createKernel(function(inb, height, width){
					
					const RED = this.constants.RED;
					const GREEN = this.constants.GREEN;
					const BLUE = this.constants.BLUE;
					
					const y = this.thread.y;
					const x = this.thread.x;
					const muly = width*4;
					const mulx = 4;
					let bright = 0;
					//let retRed = 0;
					//let retGreen = 0;
					//let retBlue = 0;
					//let retAlpha = 255; //visible
					if((1 <= x) && (x < (width-1)) && (1 <= y) && (y < (height-1))){
						let byteIndex = (width*y+x)*4;
						let dxdred = inb[byteIndex+RED]-inb[byteIndex-mulx+RED];
						let dxdgreen = inb[byteIndex+GREEN]-inb[byteIndex-mulx+GREEN];
						let dxdblue = inb[byteIndex+BLUE]-inb[byteIndex-mulx+BLUE];
						let dydred = inb[byteIndex+RED]-inb[byteIndex-muly+RED];
						let dydgreen = inb[byteIndex+GREEN]-inb[byteIndex-muly+GREEN];
						let dydblue = inb[byteIndex+BLUE]-inb[byteIndex-muly+BLUE];
						let dxydred = inb[byteIndex+RED]-inb[byteIndex-muly-mulx+RED];
						let dxydgreen = inb[byteIndex+GREEN]-inb[byteIndex-muly-mulx+GREEN];
						let dxydblue = inb[byteIndex+BLUE]-inb[byteIndex-muly-mulx+BLUE];
						let dxydred2 = inb[byteIndex+RED]-inb[byteIndex-muly+mulx+RED];
						let dxydgreen2 = inb[byteIndex+GREEN]-inb[byteIndex-muly+mulx+GREEN];
						let dxydblue2 = inb[byteIndex+BLUE]-inb[byteIndex-muly+mulx+BLUE];
						let colorDiffSquared = dxdred*dxdred + dxdgreen*dxdgreen + dxdblue*dxdblue
							+ dydred*dydred + dydgreen*dydgreen + dydblue*dydblue
							+ dxydred*dxydred + dxydgreen*dxydgreen + dxydblue*dxydblue
							+ dxydred2*dxydred2 + dxydgreen2*dxydgreen2 + dxydblue2*dxydblue2;
						//let bright = between(0, colorDiffSquared*.1, 255);
						//bright = Math.max(0, Math.min(colorDiffSquared*.1, 255));
						bright = Math.max(0, Math.min(colorDiffSquared*.3, 255));
						
						//retRed = bright;
						//retGreen = bright;
						//retBlue = bright;
						//byteIndex += 4; //optimize using += 4 instead of *muly  and *mulx
					}
					//retb[byteIndex+RED] = retRed;
					//retb[byteIndex+GREEN] = retGreen;
					//retb[byteIndex+BLUE] = retBlue;
					//retb[byteIndex+ALPHA] = retAlpha;
					//return [retRed, retGren, retBlue, retAlpha];
					
					
					//FIXME
					//bright = inb[byteIndex+RED];
					//bright = Math.random();
					
					return bright;
				},{
					constants: {RED: RED, GREEN: GREEN, BLUE: BLUE},
					dynamicOutput: true,
					precision: 'unsigned' //recommended in https://github.com/gpujs/gpu.js/issues/441 for getting Uint8Array out
				});
		}
		
		//let inb = byteRect.bytes;
		//let ret = new ByteRect(new Uint8Array(byteRect.bytes.length), byteRect.height, byteRect.width);
		//let retb = ret.bytes;
		//for(let i=ALPHA; i<retb.length; i+=4) retb[i] = 255; //visible
		
		//FIXME its 2d in, of that kernel
		//this.doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_kernel.setOutput([byteRect.bytes.length/4]);
		
		this.doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_kernel.setOutput([byteRect.width, byteRect.height]); //FIXME swap width/height?
		
		let pixelsIntoGpu = allowBytesIntoGpu ? byteRect.bytes: bytesToFloats(byteRect.bytes);
		
		let gpuOut = this.doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_kernel(
			pixelsIntoGpu, byteRect.height, byteRect.width);
			
		let gpuOutAs1d = floats2dToFloats1d(gpuOut); //TODO optimize by not requiring this copy
		
		if(returnByterectElseFloats){
			return floatsAsMonochromeToPic(gpuOutAs1d, byteRect.height, byteRect.width); //ByteRect
		}else{
			return gpuOutAs1d; //Float32Array
		}
	};
	
	/** modifies byteRect so that any (rowOrCol,colorDim) which exceeds ave brightLimit, all those bytes are set to 0,
	for RED, GREEN, and BLUE colordims but not ALPHA.
	Removes rows or cols where more (or equalormore?) than fractionLimit fraction (0..1) of pixels (in same color dim)
	are at least brightness brightLimit (0..255)
	*/
	this.preprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic = function(byteRect, brightLimit, fractionLimit){
		//let colorDims = [RED, GREEN, BLUE]; //not ALPHA
		//let colorDims = [RED]; //FIXME
		
		let colsRedFraction = new Float32Array(byteRect.width);
		let colsGreenFraction = new Float32Array(byteRect.width);
		let colsBlueFraction = new Float32Array(byteRect.width);
		let rowsRedFraction = new Float32Array(byteRect.height);
		let rowsGreenFraction = new Float32Array(byteRect.height);
		let rowsBlueFraction = new Float32Array(byteRect.height);
		
		for(let y=0; y<byteRect.height; y++){
			rowsRedFraction[y] = byteRect.rowFractionOfBytesThatAreAtLeastVal(y, RED, brightLimit);
			rowsGreenFraction[y] = byteRect.rowFractionOfBytesThatAreAtLeastVal(y, GREEN, brightLimit);
			rowsBlueFraction[y] = byteRect.rowFractionOfBytesThatAreAtLeastVal(y, BLUE, brightLimit);
		}
		for(let x=0; x<byteRect.width; x++){
			colsRedFraction[x] = byteRect.colFractionOfBytesThatAreAtLeastVal(x, RED, brightLimit);
			colsGreenFraction[x] = byteRect.colFractionOfBytesThatAreAtLeastVal(x, GREEN, brightLimit);
			colsBlueFraction[x] = byteRect.colFractionOfBytesThatAreAtLeastVal(x, BLUE, brightLimit);
		}
		for(let y=0; y<byteRect.height; y++){
			if(fractionLimit < rowsRedFraction[y]){
				byteRect.setRowAndColordimToByte(y, RED, 0);
			}
			if(fractionLimit < rowsGreenFraction[y]){
				byteRect.setRowAndColordimToByte(y, GREEN, 0);
			}
			if(fractionLimit < rowsBlueFraction[y]){
				byteRect.setRowAndColordimToByte(y, BLUE, 0);
			}
		}
		for(let x=0; x<byteRect.width; x++){
			if(fractionLimit < colsRedFraction[x]){
				byteRect.setColAndColordimToByte(x, RED, 0);
			}
			if(fractionLimit < colsGreenFraction[x]){
				byteRect.setColAndColordimToByte(x, GREEN, 0);
			}
			if(fractionLimit < colsBlueFraction[x]){
				byteRect.setColAndColordimToByte(x, BLUE, 0);
			}
		}
		
		
		/*for(let y=0; y<byteRect.height; y++){
			for(let c=0; c<colorDims.length; c++){
				let colorDim = colorDims[c];
				//if(brightLimit < byteRect.rowAve(y,colorDim)){
				if((brightLimit/255) < byteRect.rowFractionOfBytesThatAreAtLeastVal(y, colorDim, brightLimit)){
					//FIXME use 2 separate vars instead of brightLimit twice
					byteRect.setRowAndColordimToByte(y, colorDim, 0);
				}
			}
		}
		for(let x=0; x<byteRect.width; x++){
			for(let c=0; c<colorDims.length; c++){
				let colorDim = colorDims[c];
				//if(brightLimit < byteRect.colAve(x,colorDim)){
				if((brightLimit/255) < byteRect.colFractionOfBytesThatAreAtLeastVal(x, colorDim, brightLimit)){
					//FIXME use 2 separate vars instead of brightLimit twice
					byteRect.setColAndColordimToByte(x, colorDim, 0);
				}
			}
		}*/
	};
	
	this.preprocessPicToRemoveHorizontalAndVerticalLines_usingGpu_kernel = null;
	
	
	/** TODO allow Float32Array as input? func of [ByteRect.bytes or Float32Array] to Float32Array (size bytes.length/4) of edge detection.
	TODO take Float32Array as param instead?
	TODO change ByteRect to have .bytes and .floats but only use 1 of them, whichever form its in?
	*/
	this.preprocessPicToRemoveHorizontalAndVerticalLines_usingGpu = function(byteRectOrFloats, height, width, brightLimit, fractionLimit, isModifyByteRectIn){
		let first_byteRectOrFloats = byteRectOrFloats;
		
		if(!isModifyByteRectIn) throw 'TODO allow !isModifyByteRectIn';
	
		if(!this.preprocessPicToRemoveHorizontalAndVerticalLines_usingGpu_kernel){
			//using plus, and loopSize, this can do rows or cols.
			this.preprocessPicToRemoveHorizontalAndVerticalLines_usingGpu_kernel =
				gpu().createKernel(function(floats, parallelPlus, loopPlus, loopSize, brightLimit){
					let i = this.thread.x*parallelPlus; //this.thread.x could be x/col or y/row
					let count = 0;
					for(let j=0; j<loopSize; j++){
						if(brightLimit < floats[i]) count++;
						i += loopPlus;
					}
					return count/loopSize; //fraction
				},{
					dynamicOutput: true
				});
		}
	
		let wasByterectIn = isByteRect(byteRectOrFloats);
		if(wasByterectIn){
			byteRectOrFloats = byteRectOrFloats.brightnessFloats();
		}else{
			throw 'TODO allow !wasByterectIn';
		}
		//byteRectOrFloats is Float32Array as monochrome
		
		
		this.preprocessPicToRemoveHorizontalAndVerticalLines_usingGpu_kernel.setOutput([height]);
		//for each row, is fraction of pixels that are at least (or equal?) brightLimit
		let gpuOutRows = this.preprocessPicToRemoveHorizontalAndVerticalLines_usingGpu_kernel(
			byteRectOrFloats, width, 1, width, brightLimit);
		
		this.preprocessPicToRemoveHorizontalAndVerticalLines_usingGpu_kernel.setOutput([width]);
		//for each col, is fraction of pixels that are at least (or equal?) brightLimit
		let gpuOutCols = this.preprocessPicToRemoveHorizontalAndVerticalLines_usingGpu_kernel(
			byteRectOrFloats, 1, width, height, brightLimit);
		
		let ret = new ByteRect(new Uint8Array(height*width*4), height, width);
		
		
		//TODO optimize by modifying the input ByteRect, if wasByterectIn and if returnByterectElseFloats,
		//or something like that, todo organize these kinds of inputs and outputs in various funcs.
		//For now, just create a new ByteRect or new floats.
		
		//modify first_byteRectOrFloats
		for(let y=0; y<height; y++){
			if(fractionLimit < gpuOutRows[y]){
				first_byteRectOrFloats.setRowToBlack(y);
			}
		}
		for(let x=0; x<width; x++){
			if(fractionLimit < gpuOutCols[x]){
				first_byteRectOrFloats.setColToBlack(x);
			}
		}
		
		return first_byteRectOrFloats;
	
		/*if(returnByterectElseFloats){
			return floatsAsMonochromeToPic(ret, byteRect.height, byteRect.width); //ByteRect
		}else{
			return ret;
		}*/
	};
	
	
	this.potentialEnergyOfSprings = function(){
		let potentialEnergy = 0;
		for(let i=0; i<this.numSprings; i++){
			potentialEnergy += this.potentialEnergyOfSpring(i);
		}
		return potentialEnergy;
	};
	
	this.heatEnergyOfSprings = function(){
		const end = this.numSprings*VARSPERSPRING;
		let heatEnergy = 0;
		for(let i=SHEAT; i<end; i+=VARSPERSPRING){
			heatEnergy += this.springs[i];
		}
		return heatEnergy;
	};
	
	//0 <= vox < this.numVoxels */
	this.kineticEnergyOfVoxel = function(vox){
		//FIXME should this include velocity in all dims, including color and how much each webcam can see it, or (probably best this way...) just x y z?
		//kineticEnergy = .5*mass*velocity^2. Mass of each voxel is always 1 (as of 2021-7-21).
		let vv = vox*VARSPERVOXEL;
		let velX = this.voxelVels[vv+VX];
		let velY = this.voxelVels[vv+VY];
		let velZ = this.voxelVels[vv+VZ];
		return .5*(velX*velX + velY*velY + velZ*velZ);
	};
	
	this.kineticEnergyOfVoxels = function(){
		let kineticEnergy = 0;
		for(let i=0; i<this.numVoxels; i++){
			kineticEnergy += this.kineticEnergyOfVoxel(i);
		}
		return kineticEnergy;
	};
	
	this.heatEnergyOfVoxels = function(){
		const end = this.numVoxels*VARSPERVOXEL;
		let heatEnergy = 0;
		for(let i=VHEAT; i<end; i+=VARSPERVOXEL){
			heatEnergy += this.voxels[i];
		}
		return heatEnergy;
	};
	
	/** potentialEnergy + heatEnergy of springs, excluding kineticEnergy since thats stored in voxels. A spring is between 2 voxels. *
	this.energyOfSprings = function(includeKineticEnergy, includePotentialEnergy, includeHeatEnergy){
		if(
		for(let s=0; s<this.numSprings; s++){
			let ss = s*VARSPERSPRING;
			let voxA = s%this.numVoxels;
			let voxB = (s-voxA)/this.numVoxels;
			/*let aveDist = this.springs[ss+SAVEDIST];
			let dist = this.distance(voxA,voxB);
			let distDiff = Math.abs(dist-aveDist); //TODO other nonlinear func? allow it to vary more the farther their aveDist?
			let targetStrength = 1/(10+distDiff);
			this.springs[ss+SSTRENGTH] = this.springs[ss+SSTRENGTH]*(1-decayTowardTargetStrength)+decayTowardTargetStrength*targetStrength;
			//TODO norm by energy per spring, sum potentialEnergy of all those and kineticEnergy of all voxels.
			*
		}
		FIXME
	};*/
	
	/** kineticEnergy + heatEnergy of voxels, excluding potentialEnergy since thats stored in springs. A spring is between 2 voxels. *
	this.energyOfVoxels = function(){
	};
	*/
	
	/** Sum of energy of voxels and springs. The purpose of this is to stop the simulated voxels from exploding
	in some combos of the tuneable params (when move the slidebars in some combos, the voxels get stuck on edge of screen, otherwise).
	potentialEnergy + kineticEnergy + heatEnergy must be constant. Friction drains into heat.
	FIXME energy is not conserved when changing pixel colors, since that comes from outside the system,
	so make sure to norm total energy after each video frame, or find a way to conserve energy.
	Springs have only potentialEnergy and heatEnergy, but no kineticEnergy cuz thats stored in voxels. A spring is between 2 voxels.
	Voxels have kineticEnergy and heatEnergy but no potentialEnergy. potentialEnergy is stored in springs.
	Voxels have position and velocity. Springs have no position or velocity other than the 2 voxels they are between.
	*/
	this.energy = function(){
		let en = 0;
		en += this.kineticEnergyOfVoxels();
		en += this.potentialEnergyOfSprings();
		en += this.heatEnergyOfVoxels();
		en += this.heatEnergyOfSprings();
		return en;
	};
	
	this.restart();

};

var nextIdNum = 0;
//prefix is optional
var newId = function(prefix){
	if(!prefix) prefix = 'id';
	return (prefix+(nextIdNum++));
};

//var copySliderToObField = function(slider, ob, field){
//};

//log<base>(val), such as log<e>(e^3)==3
var logBase = function(base, val){
	return Math.log(val)/Math.log(base);
};

//TODO no escapes cuz its field names, but wouldnt hurt to have them anyways
let arrayOfFieldNamesToJsCodeUsingSingleQuotes = function(array){
	let s = '[';
	for(let i in array){
		if(i > 0) s += ', ';
		s += "'"+array[i]+"'";
	}
	return s+']';
};

//used by createControlsForAftransInDiv to refer to js objects in a string of code outside this namespace.
var vars = {};

//filled by getButtonsJoysticksEtc() many times per second.
var controls = {};

/** get something in the controls map or 0 if its not there. Example: control('gamepad0_dim3') returns a number -1 to 1
for that joystick axis, if its a joystick and if there is a first (0th) gamepad.
*/
var control = function(key){
	//TODO call getButtonsJoysticksEtc again? check if its the same millisecond since called it last, and only call again if isnt.
	return controls[key] || 0;
};

//Example: let x = newVar(10); eval(x+' = x*x+5;'); eval(x) is 105.
//used by createControlsForAftransInDiv to refer to js objects in a string of code outside this namespace.
var newVar = function(val){
	let id = newId();
	vars[id] = val;
	return 'vars.'+id;
};

//appends to innerHTML, not replace
var createControlsForAftransInDiv = function(aftrans, div, optionalStep){
	if(!optionalStep) optionalStep = .1;
	let html = '<table border=0><tr><td>';
	let varName = newVar(aftrans);
		let labelId = newId();
	for(let i=0; i<aftrans.length; i++){
		let inner = i%4;
		let outer = (i-inner)/4; //0..4
		if(inner == 0) html += '<br><nobr>\n';
		html += '<input type=number min="-1000" max="1000" step="'+optionalStep+'" oninput="'+varName+'['+i+'] = this.valueAsNumber; dom(\''+labelId+'\').innerHTML = aftransStr('+varName+');" value="'+aftrans[i]+'"></input>';
		if(inner == 3) html += '</nobr>\n';
		//div.innerHTML += '<nobr><input type=range id="'+id+'" min="0" max="1000000" value="'+(fieldValToFraction(firstVal)*1000000)+'"'
		//	+' oninput="let num = '+MUL+'*(Math.pow('+BASE+', between(0,this.valueAsNumber/1000000,1))-1); sim.'+FIELD+' = num; dom(\''+id2+'\').innerHTML = //\''+FIELD+' = \'+num;"></input><label id="'+id2+'">'+FIELD+'='+sim[FIELD]+'</label></nobr><br> ';
	}
	html += '<td><td>';
	//html += '<br><input type=button onclick="" value="copy aftrans to these^, in case something other than these changed it"></input>
	html += '<br><label id='+labelId+'>'+aftransStr(aftrans)+'</label>'; //keep updated as aftransStr(aftrans) if changes from the 16 numberfields
	html += '</td></tr></table>&nbsp;&nbsp;';
	div.innerHTML += html;
};

//appends to innerHTML, not replace
var createControlsForSimInDiv = function(sim, checkboxesDiv, slidersDiv, buttonsDiv){

	//FIXME some of this code ignores the param sim and uses the global var sim instead
	
	
	let bitFields = [
		'gamepadMovesAndRotatesSelectedBall',
		'normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU',
		'isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU',
		'isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG',
		'isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic', //use with brightLimitForRowsAndColsToNotBeSetToBlack
		'isPreprocessPicToRemoveHorizontalAndVerticalLines_usingGpu',
		'isPaused',
		'addABallIfThereIsNoneWhenRestart',
		'doTestCirclesDetect_oneCenterMultiSizes',
		'doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu',
		'doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu',
		'allowBytesIntoGpuElseCopyBytesToFloats_thisMayBeBuggy',
		'enable_holdVoxelsYXAtSingleRadius',
		'hidePointsThatAreBehindOtherPoints',
		'randomlyChangeFirstBallsAftransGradually',
		'pixelColorAcceleratesVoxelsInsteadOfMovesThem',
		'copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack',
		'displaySprings',
		'holdVoxelsYXInByteRect',
		'paintTestObjectsAsInput',
		'displayPotentialEnergyFromSelectedVsTo',
		'is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly',
		'nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked'
	];
	let floatFields = [
		'brightLimitForRowsAndColsToNotBeSetToBlack_bright',
		'brightLimitForRowsAndColsToNotBeSetToBlack_fraction',
		'holdVoxelsYXAtSingleRadius',
		'repelTimesMoreThanSpring',
		'decaySAVEDIST',
		'decaySSTRENGTH',
		'decayVoxelVelocities',
		'testSize',
		'testSpeedMult',
		'springForceMult',
		'displaySpringBrightnessSubtract',
		'displaySpringContrast',
		'colorChangeSpeedMult'
	];
	let funcsOf0Params = [
		'restart'
	];
	let fields = [];
	for(let i in bitFields){
		let FIELD = bitFields[i];
		let id = newId('chk');
		//FIXME if theres multiple Sim objects, this will still just use the one named 'sim', ignoring the param of this function named 'sim'.
		let startChecked = (sim[FIELD] ? true : false);
		checkboxesDiv.innerHTML += '<nobr><input type=checkbox id="'+id+'" onchange="sim.'+FIELD+' = !sim.'+FIELD+';" '+(startChecked ? 'checked' : '')+'><label for="'+id+'"> '+FIELD+'</label></nobr><br> ';
		fields.push(FIELD);
	}
	for(let i in floatFields){
		const FIELD = floatFields[i];
		let id = newId('slider_'+FIELD+'_');
		let firstVal =  sim[FIELD];
		if((firstVal <= 0) || (firstVal !== firstVal)) throw 'field='+FIELD+', firstVal must be positive but is '+firstVal;
		let MIN = firstVal/10;
		let MAX = firstVal*20; //viewed on log scale, so slider moving to right linearly increases field val exponentially
		let MULRANGE = MAX/MIN;
		
		/*
		slider ranges 0 to 1000000.
		fieldval ranges MIN to MAX.
		fieldVal = mul*base^sliderFraction.
		TODO solve. Theres infinity possible solutions since can trade (nonlinearly) between mul and base.
		firstVal should be middle slider position. MIN and MAX are 100 times less and 100 times more than that,
		as of 2021-7-20 but I might change those later.
		TODO
		*/
		
		const MUL = MIN; //MIN*BASE^0
		const BASE = MULRANGE; //MAX == MUL*MULRANGE^1
		
		const fieldValToFraction = function(fieldVal){
			//OLD: fieldVal = mul*base^sliderFraction.
			//OLD: log<base>(fieldVal/mul) = sliderFraction.
			//return logBase(BASE,fieldVal/MUL);
			
			//fieldVal = mul*(base^sliderFraction-1).
			//fieldVal = mul*base^sliderFraction-mul.
			//fieldVal+mul = mul*base^sliderFraction.
			//fieldVal+mul = mul*base^sliderFraction
			//(fieldVal+mul)/mul = base^sliderFraction
			//log<base>((fieldVal+mul)/mul) = sliderFraction
			return logBase(BASE,(fieldVal+MUL)/MUL);
			
		};
		
		const fractionToFieldVal = function(sliderFraction){
			//return MUL*Math.pow(BASE, sliderFraction);
			return MUL*(Math.pow(BASE, sliderFraction)-1);
		};
		
		let id2 = newId(id+'_label');
		
		//FIXME if theres multiple Sim objects, this will still just use the one named 'sim', ignoring the param of this function named 'sim'.
		slidersDiv.innerHTML += '<nobr><input type=range id="'+id+'" min="0" max="1000000" value="'+(fieldValToFraction(firstVal)*1000000)+'"'
			+' oninput="let num = '+MUL+'*(Math.pow('+BASE+', between(0,this.valueAsNumber/1000000,1))-1); sim.'+FIELD+' = num; dom(\''+id2+'\').innerHTML = \''+FIELD+' = \'+num;"></input><label id="'+id2+'">'+FIELD+'='+sim[FIELD]+'</label></nobr><br> ';
		/*const SIM = sim;
		dom(id).oninput = function(e){
			console.log('Slider event');
			/*let sliderPositionFraction = between(0,this.valueAsNumber/1000000,1);
			let nextFieldVal = fractionToFieldVal(sliderPositionFraction);
			console.log('Slider set sim.'+FIELD+' = '+nextFieldVal);
			SIM[FIELD] = nextFieldVal;
			*
		};*/
		//TODO save these changes somewhere, maybe put javascript code into a div so can copy/paste it from there to the js file sometimes,
		//andOr sessionStorage andOr localStorage js vars, but dont forget its there when copying the file to other ppl,
		//and put a button to clear those.
		fields.push(FIELD);
	}
	for(let i in funcsOf0Params){
		let funcName = funcsOf0Params[i];
		let id = newId('btn');
		//FIXME if theres multiple Sim objects, this will still just use the one named 'sim', ignoring the param of this function named 'sim'.
		buttonsDiv.innerHTML += '<input type=button id="'+id+'" value="'+funcName+'" onclick="sim.'+funcName+'();"></input> ';
		//dom(id).onclick = function(){ sim[funcName](); };
		//dont, cuz its not set like a float or true/false: fields.push(funcName);
	}
	buttonsDiv.innerHTML += "<input type=button value=\"get slider positions as js code\" onclick=\"let div = dom('controlsDiv_output'); let fields = "+arrayOfFieldNamesToJsCodeUsingSingleQuotes(fields)+"; div.innerHTML = ''; for(let i in fields) div.innerHTML += '	sim.'+fields[i]+' = '+sim[fields[i]]+';\\n';\"></input> ";
};

var isFirstUseOfSimAfterWebcamStarted = true;

var mouseY = 0;
var mouseX = 0;
var mouseYFraction = 0;
var mouseXFraction = 0;

//for mouse to rotate andOr move ball. This could be any game object (that has a .aftrans and .childs etc), such as Ball or AfPoint.
var selectedOb = null;

var sim = null; //set in window.onload

let isRunningMainLoop = false; //main loop has to stop between painting the screen. Use this to avoid timers possibly running the main loop twice at once.

var replaceSim = function(){
	sim = new Sim();
	
	/*sim.decaySAVEDIST = 0.1;
	sim.decaySSTRENGTH = 0.034316653410148265;
	sim.decayVoxelVelocities = 0.4;
	sim.testSize = 30;
	sim.testSpeedMult = 14000;
	sim.colorChangeSpeedMult = 4;
	*/
	
	/*sim.decaySAVEDIST = 1.2914570562695387;
	sim.decaySSTRENGTH = 0.16351280248351976;
	sim.decayVoxelVelocities = 0.0481811062002097;
	sim.testSize = 37.45811688034309;
	sim.testSpeedMult = 36235.58952071852;
	sim.colorChangeSpeedMult = 0.4;
	*/
	
	/*sim.decaySAVEDIST = 0.7992753435490808;
	sim.decaySSTRENGTH = 0.05432988578658078;
	sim.decayVoxelVelocities = 0.18387273953764224;
	sim.testSize = 25.78076125970597;
	sim.testSpeedMult = 44066.18868455676;
	sim.colorChangeSpeedMult = 1.4900504444106226;
	*/
	
	/*sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = true;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = true;
	sim.holdVoxelsYXAtSingleRadius = 160;
	sim.decaySAVEDIST = 0.7992753435490808;
	sim.decaySSTRENGTH = 0.05432988578658078;
	sim.decayVoxelVelocities = 0.18387273953764224;
	sim.testSize = 25.78076125970597;
	sim.testSpeedMult = 4406.6188684556755;
	sim.colorChangeSpeedMult = 1.4900504444106226;
	*/
	
	/*sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = true;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = true;
	sim.holdVoxelsYXAtSingleRadius = 160;
	sim.decaySAVEDIST = 0.7992753435490808;
	sim.decaySSTRENGTH = 0.2746990526070163;
	sim.decayVoxelVelocities = 0.1238005206092301;
	sim.testSize = 40.36793477837549;
	sim.testSpeedMult = 28166.95075608863;
	sim.colorChangeSpeedMult = 1.2102022482405757;
	*/
	
	/*sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = true;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = true;
	sim.holdVoxelsYXAtSingleRadius = 160;
	sim.decaySAVEDIST = 0.7992753435490808;
	sim.decaySSTRENGTH = 0.2746990526070163;
	sim.decayVoxelVelocities = 0.1238005206092301;
	sim.testSize = 40.36793477837549;
	sim.testSpeedMult = 20829.118400772433;
	sim.springForceMult = 62314.888264822766;
	sim.displaySpringBrightnessSubtract = 60;
	sim.displaySpringContrast = 61.29361620692233;
	sim.colorChangeSpeedMult = 1.2102022482405757;
	
	sim.springForceMult = 200;
	
	sim.displaySpringBrightnessSubtract = .2;
	sim.displaySpringContrast = 1;
	*/
	
	/*sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = true;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = true;
	sim.holdVoxelsYXAtSingleRadius = 160;
	sim.decaySAVEDIST = 0.7992753435490808;
	sim.decaySSTRENGTH = 0.2746990526070163;
	sim.decayVoxelVelocities = 0.1238005206092301;
	sim.testSize = 40.36793477837549;
	sim.testSpeedMult = 20829.118400772433;
	sim.springForceMult = 200;
	sim.displaySpringBrightnessSubtract = 0.29881952810787477;
	sim.displaySpringContrast = 2.622615111455447;
	sim.colorChangeSpeedMult = 1.2102022482405757;
	
	
	sim.springForceMult = 20000;
	*/
	
	
	/*sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = true;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.holdVoxelsYXAtSingleRadius = 160;
	sim.decaySAVEDIST = 1.0374934185566487;
	sim.decaySSTRENGTH = 0.2746990526070163;
	sim.decayVoxelVelocities = 0.1238005206092301;
	sim.testSize = 40.36793477837549;
	sim.testSpeedMult = 2082.911840077243;
	sim.springForceMult = 2000;
	sim.displaySpringBrightnessSubtract = 0.29881952810787477;
	sim.displaySpringContrast = 2.622615111455447;
	sim.colorChangeSpeedMult = 1.2102022482405757;
	*/
	
	/*sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = true;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.holdVoxelsYXAtSingleRadius = 94.8210585858143;
	sim.repelTimesMoreThanSpring = 5.638021239663635;
	sim.decaySAVEDIST = 1.0374934185566487;
	sim.decaySSTRENGTH = 0.2746990526070163;
	sim.decayVoxelVelocities = 0.013851812617503559;
	sim.testSize = 34.45040563350956;
	sim.testSpeedMult = 2082.911840077243;
	sim.springForceMult = 9033.04399163141;
	sim.displaySpringBrightnessSubtract = 1.095755339174466;
	sim.displaySpringContrast = 7.814329630236468;
	sim.colorChangeSpeedMult = 1.2102022482405757;
	*/
	
	/*sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = true;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = true;
	sim.holdVoxelsYXAtSingleRadius = 94.8210585858143;
	sim.repelTimesMoreThanSpring = 0.004607064384103877;
	sim.decaySAVEDIST = 0.12456962305286466;
	sim.decaySSTRENGTH = 0.0032656666431409957;
	sim.decayVoxelVelocities = 0.05216849801632716;
	sim.testSize = 34.45040563350956;
	sim.testSpeedMult = 12.751904492433628;
	sim.springForceMult = 2273.6853180791504;
	sim.displaySpringBrightnessSubtract = 0.6111139203947075;
	sim.displaySpringContrast = 1.3366739284457965;
	sim.colorChangeSpeedMult = 1.2102022482405757;
	*/



	/*sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = true;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = true;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.holdVoxelsYXAtSingleRadius = 94.8210585858143;
	sim.repelTimesMoreThanSpring = .01;
	sim.decaySAVEDIST = 0.12456962305286466;
	sim.decaySSTRENGTH = 0.0032656666431409957;
	sim.decayVoxelVelocities = .01;
	sim.testSize = 34.45040563350956;
	sim.testSpeedMult = 189.60133128377663;
	sim.springForceMult = 21067.995678284373;
	sim.displaySpringBrightnessSubtract = 0.8162463274127334;
	sim.displaySpringContrast = 1.8896223875801657;
	sim.colorChangeSpeedMult = 1.2180064966601865;
	*/

	/*
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = true;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = true;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.holdVoxelsYXAtSingleRadius = 94.8210585858143;
	sim.repelTimesMoreThanSpring = 0.01;
	sim.decaySAVEDIST = 0.12456962305286466;
	sim.decaySSTRENGTH = 0.0032656666431409957;
	sim.decayVoxelVelocities = 0.3;
	sim.testSize = 34.45040563350956;
	sim.testSpeedMult = 20000;
	sim.springForceMult = 33001.356516843494;
	sim.displaySpringBrightnessSubtract = 0.8162463274127334;
	sim.displaySpringContrast = 1.8896223875801657;
	sim.colorChangeSpeedMult = 1.2180064966601865;
	*/
	
	/*
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = true;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = true;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.holdVoxelsYXAtSingleRadius = 10.595620905623312;
	sim.repelTimesMoreThanSpring = 0.01;
	sim.decaySAVEDIST = 0.6900306023779363;
	sim.decaySSTRENGTH = 0.0032656666431409957;
	sim.decayVoxelVelocities = 5.97;
	sim.testSize = 34.45040563350956;
	sim.testSpeedMult = 20000;
	sim.springForceMult = 33001.356516843494;
	sim.displaySpringBrightnessSubtract = 0.8162463274127334;
	sim.displaySpringContrast = 1.8896223875801657;
	sim.colorChangeSpeedMult = 2.696428546613323;
	*/

	/*
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.holdVoxelsYXAtSingleRadius = 10.595620905623312;
	sim.repelTimesMoreThanSpring = 0.01;
	sim.decaySAVEDIST = 0.9779500268510528;
	sim.decaySSTRENGTH = 0.0032656666431409957;
	sim.decayVoxelVelocities = 0.05869256780953997;
	sim.testSize = 53.96384809558231;
	sim.testSpeedMult = 53822.70297499838;
	sim.springForceMult = 76724.29857438857;
	sim.displaySpringBrightnessSubtract = 0.8162463274127334;
	sim.displaySpringContrast = 1.8896223875801657;
	sim.colorChangeSpeedMult = 36.79119149731036;
	*/

	/*
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.holdVoxelsYXAtSingleRadius = 10.595620905623312;
	sim.repelTimesMoreThanSpring = 12;
	sim.decaySAVEDIST = 0.9779500268510528;
	sim.decaySSTRENGTH = 0.0032656666431409957;
	sim.decayVoxelVelocities = 0.05869256780953997;
	sim.testSize = 53.96384809558231;
	sim.testSpeedMult = .00001;
	sim.springForceMult = 52709.95855821406;
	sim.displaySpringBrightnessSubtract = 0.8162463274127334;
	sim.displaySpringContrast = 1.8896223875801657;
	sim.colorChangeSpeedMult = 7.656814952235777;
	*/

	/*
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.holdVoxelsYXAtSingleRadius = 10.595620905623312;
	sim.repelTimesMoreThanSpring = 0.05760820309387089;
	sim.decaySAVEDIST = 9.13933207639887;
	sim.decaySSTRENGTH = 0.0032656666431409957;
	sim.decayVoxelVelocities = 0.00715505143170058;
	sim.testSize = 43.487759351153244;
	sim.testSpeedMult = 10000;
	sim.springForceMult = 7575.730110916798;
	sim.displaySpringBrightnessSubtract = 0.810320633817516;
	sim.displaySpringContrast = 1.8896223875801657;
	sim.colorChangeSpeedMult = 0.8555980052150126;
	*/
	
	/*
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.holdVoxelsYXAtSingleRadius = 10.595620905623312;
	sim.repelTimesMoreThanSpring = 0.05760820309387089;
	sim.decaySAVEDIST = 9.13933207639887;
	sim.decaySSTRENGTH = 0.0032656666431409957;
	sim.decayVoxelVelocities = 0.0002779646460495772;
	sim.testSize = 43.487759351153244;
	sim.testSpeedMult = 34285.358973666;
	sim.springForceMult = 2000;
	sim.displaySpringBrightnessSubtract = 0.810320633817516;
	sim.displaySpringContrast = 1.8896223875801657;
	sim.colorChangeSpeedMult = 0.4470769752094584;
	*/

	/*
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = true;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.holdVoxelsYXAtSingleRadius = 10.595620905623312;
	sim.repelTimesMoreThanSpring = .00001;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.0032656666431409957;
	sim.decayVoxelVelocities = 0.0002779646460495772;
	sim.testSize = 43.487759351153244;
	sim.testSpeedMult = 34285.358973666;
	sim.springForceMult = 2000;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 0.4470769752094584;
	*/
	
	/*
	sim.addABallIfThereIsNoneWhenRestart = true;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.holdVoxelsYXAtSingleRadius = 10.595620905623312;
	sim.repelTimesMoreThanSpring = 0.00001;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.0032656666431409957;
	sim.decayVoxelVelocities = 0.0002779646460495772;
	sim.testSize = 17.06594612230106;
	sim.testSpeedMult = 34285.358973666;
	sim.springForceMult = 2000;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 0.4470769752094584;
	*/
	
	/*
	sim.addABallIfThereIsNoneWhenRestart = true;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.randomlyChangeFirstBallsAftransGradually = true;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.holdVoxelsYXAtSingleRadius = 6.897260168505984;
	sim.repelTimesMoreThanSpring = 0.00003961482491769488;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.006553182835691826;
	sim.decayVoxelVelocities = .5;
	sim.testSize = 55.753071208141286;
	sim.testSpeedMult = 12681.258426317045;
	sim.springForceMult = 41.25807343847554;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 1.6879101109374244;
	
	sim.randomlyChangeFirstBallsAftransGradually = false;
	
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	*/
	
	
	/*
	sim.isPaused = true;
	sim.addABallIfThereIsNoneWhenRestart = false;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU = true;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.randomlyChangeFirstBallsAftransGradually = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.holdVoxelsYXAtSingleRadius = 6.897260168505984;
	sim.repelTimesMoreThanSpring = 0.00003961482491769488;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.006553182835691826;
	sim.decayVoxelVelocities = 0.5;
	sim.testSize = 55.753071208141286;
	sim.testSpeedMult = 12681.258426317045;
	sim.springForceMult = 41.25807343847554;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 1.6879101109374244;


	sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU = true;
	*/
	
	
	/*
	sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU = true;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU = true;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic = true;
	sim.isPaused = true;
	sim.addABallIfThereIsNoneWhenRestart = false;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.randomlyChangeFirstBallsAftransGradually = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked = false;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright = 22.947005675709576;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction = 0.3636231798750524;
	sim.holdVoxelsYXAtSingleRadius = 6.897260168505984;
	sim.repelTimesMoreThanSpring = 0.00003961482491769488;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.006553182835691826;
	sim.decayVoxelVelocities = 0.5;
	sim.testSize = 55.753071208141286;
	sim.testSpeedMult = 12681.258426317045;
	sim.springForceMult = 41.25807343847554;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 1.6879101109374244;
	*/
	
	
	/*
	sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU = true;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU = true;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic = true;
	sim.isPaused = true;
	sim.addABallIfThereIsNoneWhenRestart = false;
	sim.doTestCirclesDetect_oneCenterMultiSizes = true;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.randomlyChangeFirstBallsAftransGradually = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked = false;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright = 22.947005675709576;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction = 0.5986767961552187;
	sim.holdVoxelsYXAtSingleRadius = 6.897260168505984;
	sim.repelTimesMoreThanSpring = 0.00003961482491769488;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.006553182835691826;
	sim.decayVoxelVelocities = 0.5;
	sim.testSize = 55.753071208141286;
	sim.testSpeedMult = 12681.258426317045;
	sim.springForceMult = 41.25807343847554;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 1.6879101109374244;



	sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU = true;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU = true;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic = true;
	sim.isPaused = true;
	sim.addABallIfThereIsNoneWhenRestart = false;
	sim.doTestCirclesDetect_oneCenterMultiSizes = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu = true;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.randomlyChangeFirstBallsAftransGradually = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked = false;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright = 22.947005675709576;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction = 0.5986767961552187;
	sim.holdVoxelsYXAtSingleRadius = 6.897260168505984;
	sim.repelTimesMoreThanSpring = 0.00003961482491769488;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.006553182835691826;
	sim.decayVoxelVelocities = 0.5;
	sim.testSize = 55.753071208141286;
	sim.testSpeedMult = 12681.258426317045;
	sim.springForceMult = 41.25807343847554;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 1.6879101109374244;


	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu = true;
	*/


	/*
	sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU = true;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU = false;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG = false;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic = false;
	sim.isPaused = true;
	sim.addABallIfThereIsNoneWhenRestart = false;
	sim.doTestCirclesDetect_oneCenterMultiSizes = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu = false;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.randomlyChangeFirstBallsAftransGradually = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked = false;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright = 22.947005675709576;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction = 0.5986767961552187;
	sim.holdVoxelsYXAtSingleRadius = 6.897260168505984;
	sim.repelTimesMoreThanSpring = 0.00003961482491769488;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.006553182835691826;
	sim.decayVoxelVelocities = 0.5;
	sim.testSize = 55.753071208141286;
	sim.testSpeedMult = 12681.258426317045;
	sim.springForceMult = 41.25807343847554;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 1.6879101109374244;
	*/
	
	/*
	sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU = true;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU = false;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG = true;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic = false;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_usingGpu = true;
	sim.isPaused = true;
	sim.addABallIfThereIsNoneWhenRestart = false;
	sim.doTestCirclesDetect_oneCenterMultiSizes = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu = false;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.randomlyChangeFirstBallsAftransGradually = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked = false;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright = 22.947005675709576;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction = 0.5986767961552187;
	sim.holdVoxelsYXAtSingleRadius = 6.897260168505984;
	sim.repelTimesMoreThanSpring = 0.00003961482491769488;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.006553182835691826;
	sim.decayVoxelVelocities = 0.5;
	sim.testSize = 55.753071208141286;
	sim.testSpeedMult = 12681.258426317045;
	sim.springForceMult = 41.25807343847554;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 1.6879101109374244;
	*/

	/*
	sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU = false;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU = false;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG = false;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic = false;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_usingGpu = false;
	sim.isPaused = true;
	sim.addABallIfThereIsNoneWhenRestart = true;
	sim.doTestCirclesDetect_oneCenterMultiSizes = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu = false;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.randomlyChangeFirstBallsAftransGradually = true;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked = false;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright = 22.947005675709576;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction = 0.5986767961552187;
	sim.holdVoxelsYXAtSingleRadius = 6.897260168505984;
	sim.repelTimesMoreThanSpring = 0.00003961482491769488;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.006553182835691826;
	sim.decayVoxelVelocities = 0.5;
	sim.testSize = 55.753071208141286;
	sim.testSpeedMult = 12681.258426317045;
	sim.springForceMult = 41.25807343847554;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 1.6879101109374244;
	
	
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	
	sim.randomlyChangeFirstBallsAftransGradually = false;
	*/
	
	
	/*
	sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU = true;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU = true;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG = false;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic = false;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_usingGpu = true;
	sim.isPaused = true;
	sim.addABallIfThereIsNoneWhenRestart = true;
	sim.doTestCirclesDetect_oneCenterMultiSizes = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu = true;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.hidePointsThatAreBehindOtherPoints = true;
	sim.randomlyChangeFirstBallsAftransGradually = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked = false;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright = 22.947005675709576;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction = 0.5986767961552187;
	sim.holdVoxelsYXAtSingleRadius = 6.897260168505984;
	sim.repelTimesMoreThanSpring = 0.00003961482491769488;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.006553182835691826;
	sim.decayVoxelVelocities = 0.5;
	sim.testSize = 55.753071208141286;
	sim.testSpeedMult = 12681.258426317045;
	sim.springForceMult = 41.25807343847554;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 1.6879101109374244;
	*/
	
	
	/*
	sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU = true;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU = true;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG = false;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic = true;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_usingGpu = false;
	sim.isPaused = true;
	sim.addABallIfThereIsNoneWhenRestart = true;
	sim.doTestCirclesDetect_oneCenterMultiSizes = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu = true;
	sim.allowBytesIntoGpuElseCopyBytesToFloats_thisMayBeBuggy = false;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.hidePointsThatAreBehindOtherPoints = true;
	sim.randomlyChangeFirstBallsAftransGradually = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked = false;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright = 22.947005675709576;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction = 0.5986767961552187;
	sim.holdVoxelsYXAtSingleRadius = 6.897260168505984;
	sim.repelTimesMoreThanSpring = 0.00003961482491769488;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.006553182835691826;
	sim.decayVoxelVelocities = 0.5;
	sim.testSize = 55.753071208141286;
	sim.testSpeedMult = 12681.258426317045;
	sim.springForceMult = 41.25807343847554;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 1.6879101109374244;
	*/
	
	sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU = true;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU = false;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG = false;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic = false;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_usingGpu = false;
	sim.isPaused = true;
	sim.addABallIfThereIsNoneWhenRestart = true;
	sim.doTestCirclesDetect_oneCenterMultiSizes = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu = false;
	sim.allowBytesIntoGpuElseCopyBytesToFloats_thisMayBeBuggy = false;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.hidePointsThatAreBehindOtherPoints = true;
	sim.randomlyChangeFirstBallsAftransGradually = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked = false;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright = 22.947005675709576;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction = 0.5986767961552187;
	sim.holdVoxelsYXAtSingleRadius = 6.897260168505984;
	sim.repelTimesMoreThanSpring = 0.00003961482491769488;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.006553182835691826;
	sim.decayVoxelVelocities = 0.5;
	sim.testSize = 55.753071208141286;
	sim.testSpeedMult = 12681.258426317045;
	sim.springForceMult = 41.25807343847554;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 1.6879101109374244;
	
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	
	sim.hidePointsThatAreBehindOtherPoints = true;
	
	
	sim.restart();
};

window.onload = function(){


	// Configure a few settings and attach camera
	Webcam.set({
		fps: 120,               // camera frames per second. FIXME? webcamjs seems to ignore this param.
		width: 320, //FIXME changing thse seems to have no effect 2021-8
		height: 240,
		//image_format: 'png',
		image_format: 'jpeg', //FIXME why does this seem to have no effect? jpeg vs png, and jpeg_quality of 90 vs 3?
		jpeg_quality: 90
	});
	Webcam.attach('#my_camera');

	/*
	// preload shutter audio clip
	var shutter = new Audio();
	shutter.autoplay = true;
	shutter.src = navigator.userAgent.match(/Firefox/) ? 'shutter.ogg' : 'shutter.mp3';
	*/

	updateCanvasObjects();
	replaceSim();

	


	




	//why didnt this fix it, and still need to click restart after it loads (to get voxels off edges of screen they moved too fast got stuck)?: sim.restart(); //cuz changed sim.varnames
	
	createControlsForSimInDiv(sim, dom('controlsDiv_checkboxes'), dom('controlsDiv_sliders'), dom('controlsDiv_buttons'));
	
	let x = function(){
		if(isRunningMainLoop){
			console.log('WARNING: Already isRunningMainLoop='+isRunningMainLoop);
			return;
		}
		isRunningMainLoop = true;
		try{
			if(Webcam.live){ //FIXME also check isPaused here?
				take_snapshot(sim);
				dom('buttonsJoysticksEtcDiv').innerHTML = "<br>"+JSON.stringify(getButtonsJoysticksEtc()).replaceAll(',',',<br>');
				//setTimeout(x, 20);
				if(isFirstUseOfSimAfterWebcamStarted){
					isFirstUseOfSimAfterWebcamStarted = false;
					adjustCanvasEtcSizesToMatchAspectRatioOfWebcamExceptRoundoff();
					sim.restart();
				}
				if(sim.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked){
					setTimeout(x, 1); //likely to get out of sync compared to requestAnimationFrame but seems to get a little higher fps than requestAnimationFrame
				}else{
					requestAnimationFrame(x);
				}
			}else{
				console.log('Webcam isnt on yet');
				setTimeout(x, 500);
			}
		}finally{
			isRunningMainLoop = false;
		}
	};
	x();
	
};


//Returns a map of button/joystick/etc name to number in range -1 to 1. TODO Everything not in the map means 0? Or include zeros?
//gamepad api, todo also add mouse, keyboard, etc. Any data flow from person to computer that doesnt need high bandwidth.
//sound and video need high bandwidth.
//This is called many times per second since navigator.getGamepads() only reads gamepad state once and does not start a stream of it (like browsers used to).
//
/*TODO use controller rumble. I got it to work with bluetooth xbox controller in win10 in chrome (first browser I tried) 2021-8-28 with this
gamepad.vibrationActuator.playEffect("dual-rumble", {
	duration: 1000,
	strongMagnitude: 1.0,
	weakMagnitude: 1.0
})
but it kept rumbling, maybe cuz i was in browser debugger at a breakpoint.
*/
var getButtonsJoysticksEtc = function(){
	let gamepads = navigator.getGamepads(); //may contain nulls, such as [null, null, null, null] or [aGamepad, null, null, null].
	let ret = {};
	ret.mouse0_dim0 = mouseYFraction*2-1; //TODO swap y and x order of dims?
	ret.mouse0_dim1 = mouseXFraction*2-1;
	for(let i=0; i<gamepads.length; i++){
		let gamepad = gamepads[i];
		if(gamepad){
			let s = gamepad.id;
			if(!s) s = 'gamepad';
			//s = s.trim().replaceAll(/\s|\(|\)/g,'_');
			s = s.trim().replaceAll(/\(|\)/g,'').replaceAll(/\s/g,'_');
			//let gamepadName = s+'_index'+i;
			let gamepadName = 'gamepad'+i;
			
			//let buttonOrAxisNum = 0;
			for(let a in gamepad.axes){
				//ret[gamepadName+'_'+(buttonOrAxisNum++)] = gamepad.axes[a];
				ret[gamepadName+'_dim'+a] = gamepad.axes[a];
			}
			for(let b in gamepad.buttons){
				ret[gamepadName+'_btn'+b] = gamepad.buttons[b].value; //GamepadButton {pressed: false, touched: false, value: 0}
			}
			if(gamepad.vibrationActuator){
				ret[gamepadName+'_vib0_TODO'] = 0; //TODO see how I used this in comment of getButtonsJoysticksEtc
			}
			
		}
	}
	return ret;
};

var domSetSize = function(dom, width, height){
	if(dom.width) dom.width = width;
	else dom.style.width = width+'px';
	if(dom.height) dom.height = height;
	else dom.style.height = height+'px';
};

var adjustCanvasEtcSizesToMatchAspectRatioOfWebcamExceptRoundoff = function(){
	let webcamVideo = Webcam.video;
	if(!webcamVideo) throw 'No webcam yet, webcamVideo='+webcamVideo;
	let physicalCameraAspectRatio = webcamVideo.videoWidth/webcamVideo.videoHeight; //may differ from aspectRatio on screen.
	let observedCanvasWidth = canvasOut.width;
	let newCanvasWidth = observedCanvasWidth;
	let newCanvasHeight = Math.ceil(observedCanvasWidth/physicalCameraAspectRatio);
	domSetSize(dom('canvasIn'), newCanvasWidth, newCanvasHeight);
	domSetSize(dom('canvasOut'), newCanvasWidth, newCanvasHeight);
	
};

</script>

</head><body>
//FIXME mouseY etc measures from here not in canvas
<table border=0><tr><td valign=top>

	<canvas id="canvasOut" width=640 height=640 onmousemove="let rect = this.getBoundingClientRect(); mouseY = event.clientY-rect.top; mouseYFraction = between(0,mouseY/this.clientHeight,1); mouseX = event.clientX-rect.left; mouseXFraction = between(0,mouseX/this.clientWidth,1); selectedOb = sim.whatsAtYx([mouseY,mouseX]); /*if(selectedOb) selectedOb.randomizeColors();*/"></canvas><br>
	<div id="controlsDiv_checkboxes"></div>
	<br><br>
</td><td valign=top>
	Works in most browsers if camera is not already in use (or sometimes even if it is), when you click allow camera in the popup. Close other browser tabs or programs that may be using the camera then reload this page, if an error pops up and you dont see live webcam on the left. Its lower lag if only 1 browser tab is using webcam at once. <label id=fpsLabel></label>
	<div id="controlsDiv_sliders"></div>
	<hr>
	<input type=button value="replaceSim (fixme this doesnt replace the checkboxes etc, so they might be the opposite of what they should be)" onclick="replaceSim();"></input>
	<hr>
	<div id="controlsDiv_aftranses"></div>
	<hr>
	<div id="controlsDiv_buttons">
		<textarea cols=50 rows=2 id="controlsDiv_output"></textarea><br>
	</div>
	<div id="buttonsJoysticksEtcDiv">buttonsJoysticksEtcDiv</div>
</td></tr></table>

<font color=#bbbbbb>* DONE: GPU optimized code to unreliably draw circle around tennis ball (it seems to be jittery and work about 60% the time as of 2021-8-21 when I hold the ball in ways that get it to work better, will improve that later).<br>
* DONE: I'm running out of screen space for the checkboxes and sliders and 4x4 grids of number choosers per aftrans (which will have even more controls per aftrans soon). Put these in separate divs: aftrans stuff (which may have their own sliders), individual sliders, individual checkboxes, todos.<br>
* DONE put afpoint on ball, have them share the same aftrans (Float32Array(16)). It seems to be on the ball when ball is centered at top left corner (0,0,0), but when move the aftrans center, the center of the afpoint and the center of the ball stay together, but the ends of the 3 lines (red green blue, for the 3 dims) of the afpoint stay where they would be if the center hadnt moved, while both centers move together. Ball.prototype.paint was hard to get working, so change AfPoint.prototype.paint to match however ball is doing it. Fixed by adding centerX and centerY to those in AfPoint.prototype.paint.<br>
* PARTIALLY DONE, ITS FIXED BUT ITS SLOW CUZ ADDED A CHECKBOX TO ALLOW BYTES OR NOT SO BYTES GET COPIED TO FLOATS AND ITS SLOW: fix isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG. It was working in recent versions, then I started doing stuff with Ball and AfPoint, now the video goes black when simultaneously that and normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU are checked, but either of those 2 alone works, and that normColors* with isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU work together. Also, copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack has to be checked or theres nothing to do those image transforms on. It breaks that way in chrome and operagtx and edge (and in edge, when I clicked isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG before normColors* isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG worked by itself, but after checking then unchecking normColors, it broke as usual), works in brave. In firefox it breaks that way, and sometimes reversed where it only worked when normColors* was unchecked, but then it went back to the usual error. Maybe its best to not have image transform funcs modify arrays (which normColors* modifies, and maybe others do?). Also maybe gpu().combineKernels(...) would fix it? Or maybe gpu should be using multiple canvas, or some kind of lock/sync between the calls.<br>
* DONE, THEY LOOK LIKE BALLS. fix the ball coordinate system since setBaxels seems to be wrapped around it twice. When draw with mouse from one corner of video to opposite corner, it draws 2 places at once, from both poles to somewhere at equator where they dont meet. So the display of ball is wrong. I've already verified normXYZOfBaxelIndex is correct by console.log as I move the mouse. When I only painted red on it, different colors appeared in the (now its 4) lines drawn from where i paint a line in video rectangle. The coordinate system is drawing a sphere surface correctly, as it moves slightly by random aftranses (when a certain checkbox is checked). So its some misalignment in loops of how thats drawn. Its changing the color of things its already painted, so maybe its a thread error such as between js graphics vs main thread? Fixed that, but todo fix hidePointsThatAreBehindOtherPoints cuts off half (or different amount if ball is not at centered z position, depending on aftrans) the ball surface but its not the half I wanted which is toward "into the screen". It cuts it off at different angles depending how the aftrans is at that time.<br>
</font><b>
* TODO make gamepad move and rotate the ball nearest to mouse. Its already doing that some but its in the ball's coordinates instead of screen coordinates, or something like that, so its confusing. Try some combo of reordering the 2 aftransOfAftrans, and inverse4x4, and transpose4x4. Need to change controllerToAftrans to aftrans float4 vecs instead of just float2 which its doing rotations in right now. Its easier to figure out using AfPoints which mouse can now select since I commentedout "instanceof Ball". First, get it rotating just between the 2 screen dims, nomatter how the ball is rotated already (so in screens coords, not balls coords). After thats working, the other rotations and movement should be easy.<br>
</b>
* TODO turn part of spherical pic zeroAttention/ignore/transparent so later when possible sphere rotations are compared it wont be affected by those parts where data isnt known.<br>
* TODO fix why some baxels (pixels on ball surface) dont display depending on ball 3d angle, and when ball is slightly rotated, they do display. Its only about 3% of baxels at any one time.<br>
* TODO create checkbox for mouse position in 2d rectangle painting on ball surface (not where mouse touches ball), and align it to the video window more precisely "//FIXME mouseY etc measures from here not in canvas", and create a button to clear those changes or paint the ball again etc.<br>
* TODO put "a cat pic (from wikipedia that I used in the webgl demo html) or sine waves or something" onto a ball, and put controls to rotate it.
* TODO try this way of 3d matching: considering that gpujs can do pointer jumping based on sine cosine etc, maybe should just try 30 pixels from each of a million rotations, then do more detailed checking for those not excluded in that. Try it with lower resolution balls at first, get 2 balls of 40x20 pixels to align with eachother, where a cat pic (from wikipedia that I used in the webgl demo html) or sine waves or something, are painted onto them at random rotations, so Human can recognize when it is and isnt aligned.
* TODO try a few ways of 3d matching until one works, considering "all rotations of 2 balls 3d wrapped surface 001.png". The "100*50*(2*50)^2=50million calculations" is probably not the right calculation cuz its 1 more dimension than I was thinking, as it needs to store 100*50*100*2 baxels (pixels on ball surface) split between 2 balls, which is 50 copies of each ball with 50*2 different poles (which rectangle pixels are between), instead of just storing 100*50 baxels. Thats about 10k circles (of max radius) per ball, and need to compare all pairs so 100mil compares of circle to circle, which each cost 10k compares (100 offsets of 100 baxels, rotating 2 circles in a 1d loop onto eachother) so its around 1 trillion calculations per video frame. It can find 1 circle that matches between them for "100*50*(2*50)^2=50million calculations" and about 100*50*2 memory. I was thinking that one circle might be enuf to find it to do a more detailed search, but it seems like it will be more efficient to just try 30 random points on all ~1million rotations to exclude most possibilities quickly then do more detailed calculations on those that remain. Or maybe many smaller circles (not max radius) at many random points on the 2 surfaces, is another way. Or maybe need to only check rotations near the last aftrans the ball was observed. Whatever it takes, find some way to, without adding more than 10ms more lag for this step, find how the circles align by rotation.
* TODO test the ball code (2d rect (few floats of data at each point) wrapped around sphere surface, by creating 2 of them at 2 constant aftranses (4x4) and copy color from one to the other, and make sure you see tennis ball at both when webcam sees tennis ball at once held still.<br>
* After 2 balls copying at constant aftranses, do the 3d rotation finder code ("100*50*(2*50)^2=50million calculations" etc) but at constant x y radius, and get it to decay color at the ball I hold while i try to rotate it without moving it.<br>
* * After 3d rotation finder code is working in a basic way that copies tennis ball it sees regardless of rotation to somewhere else on screen, hook the 3d rotation code to the circle finder code, and draw an AfPoint (red green and blue lines showing a position and rotation) on the tennis ball while I move it slowly and carefully near middle of window. This is not optimized enuf for low lag yet, but after I get the basics working, I'll rewrite some of the steps.<br>
* TODO gpu optimize the code to find the n most likely circles (doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu unreliably finds 1 using cpu and is slow) to look for balls there.<br>
* TODO test this recent lowering of lag on other browsers and computers.<br>
* TODO make GPU.js do normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU and isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU without reducing the fps much. costs too much in cpu. Should be around 60 fps with these on, instead of 45 in chrome which seems to stop at 60 even if could go faster or cuz thats webcams max speed.<br>
* TODO use the normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU + isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU (a kind of edge detection that only sees color change not brightness change) to find position of all tennis balls webcam is currently seeing, using GPU.js to check all possible centerX, centerY, and radius (I've already adjusted canvas to webcam's physical aspect ratio so will probably be precise circle somewhere), and if necessary attach it to the older kind of Voxels (Sim.voxels etc) and get them to find the precise circular edge, or do both since that can likely get more precision. Find the circle somehow, even if it requires remembing where the balls were recently so are more likely to be near there next video frame.<br>
* After knowing where the balls are in 2d image, use GPU.js to do "100*50*(2*50)^2=50million calculations" (it would be 1 more dim than that, so probably have to check sparse points to exclude most of the possible rotations first) per ball per video frame, to try all possible 3d rotations to match what webcam sees (need to use sphere surface math to copy a 2d image (at known 2d circle position) to approx half of a sphere surface (create Ball object for what webcam sees) and match that to simulated Ball by aftrans. Find the aftrans, and prove it by putting an Afpoint on the ball so when person moves physical tennis ball (with many random dots drawn on it with marker), on screen theres that same tennis ball with a red line, green line, and blue line sticking out from its center in 3d showing its movement and rotation.<br>
* Reduce lag by using gpu.combineKernels.<br>
* Get that working for at least 4 and hopefully 20 tennis balls same webcam sees (depending on gpu speed), and add that many gamepads into navigator.getGamepads() like in https://dev.to/alvaromontoro/virtual-gamepad-in-javascript-511g<br>
* Use <b>gpu-physics.js</b> (the gpu form of cannon.js) to make an inline skating game where 2 tennis balls held in hands control the movement and rotation (a 6d joystick each ball) of the 2 feet, and theres no button sequences to learn, the game only does physics so if you want to do any tricks, acrobatics, skating backward, spinning, balancing, etc, move the tennis balls how the feet should move relative to the midbody of how it would be done at a real skatepark.<br>
* Use the Sim.voxels (more advanced kinds of voxels) to detect 1 more dimennsion on each ball, so 7d joystick each, so you can lift or hold finger on the ball to grab or release so can dragAndDrop in 6d (angle and movement) so you can choose to only move the tennis ball as a joystick sometimes and not other times.<br>
<br>
experiment with various ways to do the 3d rotation matching.<br>
These experiments to try include:<br>
* fewer points, trying all rotations at once in gpujs since it can do pointer jumping based on sine cosine exp etc at about half speed of lacking pointer jumping, unlike opencl doesnt do that at all.<br>
* many small circles and match them all pairs, with all possible circularqueuelike offsets (so squared of circle perimeter amount of work per gputhread), then do all pairs springs or attraction in 3d to (within 1 video frame) pull the rotation to wherever that pulls the most. The many to many (all circles matching bipartite to all circles on the other ball various amoutns, returning that amount) makes it compute bottlenecked instead of IO bottlenecked. (or maybe... simple convolutional neuralnet but just the low layers, to find patterns on the surface of each ball (not pretrained, must learn within a few seconds or less), or even simpler just a pic or a small circle around various points, instead of the small circles.)<br>
* remember previous aftrans and only look small differences from it, such as up to plus/minus 1/12 of a turn in 3 ways of turning, which is .0046 times as many possible rotations to check, but still check all of them (not all at once) in case it gets out of sync.<br>
* do the full expensive check for rotations less often, like once per second in case things get out of sync or whenever its not matching well and once when system starts. This is, at everywhere it finds there could be a circle on screen (partial matching cuz fingers cover it some), do the full 3d matching of all possible rotations by maxradiuscircle matching.<br>

<canvas id="canvasIn" width=640 height=640 style="visibility:hidden"></canvas>
<div id="my_camera" style="visibility:hidden"
></div>
<div id="results" style="width:320px;height:240px;border:1px solid black;"></div>

<br><br>
<h1>
<br><br>
Do this next, and display the balls positions (as ovals in 2d webcam view), for up to 20 balls at once including that some can be behind others, and fingers in front of or behind balls...
Put a variant of a Voxel (the kind which springs are between in the earlier code that was meant for 3d modelling everything webcam sees at once)... put a bunch of those randomly on screen and have them decay color as usual but have them precision adjust their radius and width/height ratio (cuz of webcam resolution ratio differences), and they try to match (by 1/(1+colorDiff^2) etc) the oval edges of whatever color of ball they might be partially intersecting, considering that part of the oval might be behind fingers holding it etc.
OLDER... TODO to get started easy, just check for the color yellow (color of most tennis balls) and do more detailed search near that for the partially visible tennis balls. Thats how I matched the orange loop of wire I used as a game controller in earlier experiments, by its color and that it was moving.
Dont handle motion blur yet, just move hands as fast as would move mouse, not as fast as you would swing a bat or golf club which creates too much motionblur.
<br><br>
As an experiment, try convolutional neuralnet (even though its probably more gpu hops so possibly more lag) for finding circles of any radius position and color in 2d image)? Dont need that but its a good experiment to do in case its useful for finding balls that got far out of sync, for example?
<br><br>
Sequence of calculations: find yellow partial circles (obscured by fingers etc) by color then more detailed search for circle edge detect. Then in GPU.js expand 100x50 to 100x50x50, for ball on screen at that circle observed by webcam (its back half has 0 attention) and for simulated ball, and do "100*50*(2*50)^2=50million calculations" per ball per video frame to get aftrans4x4 of the ball. Then decay 100x50 colors on simulated ball toward what webcam sees, and display aftrans4x4 as an afpoint (later it goes to navigator.getGamepads(). After that is working, can use the balls as tools to grab and drag and rotate things in 3d to further improve the accuracy of the system, like I'm using a 2d mouse to develop it right now. After thats all working for at least 8 balls at once (todo 20), make an inlineskating game where a tennis ball in each hand controls the position3d and angle3d of each foot so can for example cause mid body to lean forward or backward relative to feet, but still might need more dims for holding arms outward vs closer to body center for spinning slower or faster, but can probably just make arms copy what legs are doing mirred somehow. Can add more dims later if needed, but tennis balls are easiest to get started. Also for my own uses get a lower lag webcam since I want this to be as low lag as the common dual joystick controllers if you have good enough camera.
<br><br>
I'd prefer to avoid convolutional neuralnet cuz it does more sequential gpu steps, 1 per neuralnet layer at least, and cuz training isnt needed if the system just generally recognizes any ball on screen even if each point on the balls surface is a random color. It should work better the more random the ball's surface is.
<br><br>
TODO find the circles in pic from webcam...
For a given radius looking for, such as 57, if average the color of the pic at ceil(2*pi*57) offsets (centered at every point on its perimeter, then the center point of a circle would be unusually bright. Its not possible for anything else to be brighter, except if parts of the circle are hidden by fingers etc. If do that (140-30) times for those possible radiuses, then that would extremely narrow down where the circles are. Possible to gnerate that merging of of 2^n positions of the same image using n steps? Seems unlikely.
<br><br>
No this is too slow a way to find the circles... TODO to find circles, have GPU.js take a 2d image of what webcam sees (such as 400x300) and a circle radius range (such as 30..140), and output a 3d tensor of, for each pixel, 140-30=110 numbers for how likely a circle is centered there of that radius. After get these, find the top few which are likely, especially considering where ball(s) were recently, and align it with 0.1 pixel precision using CPU (or maybe another call of GPU? can merge multiple gpu kernel calls using a combine kernels func in GPU.js). After find circle(s) display them for debug purposes (optional), and do the 3d all rotations for the circle(s) that are best possible match. 
"q38x/w/gpujs/testNonlinearPointerJumping001_its10TimesFasterInGpuThanCpu(comparedTo20TimesFasterForMatmul).html verifies that GPU.js can do nonlinear pointer jumping" so can derive the circle sizes or (costs more IO) use an int array of offsets for each. That calculation will cost 400*300*(140-30)*274=3.6billion pixel compares, where 274 is arbitrary perimeter of the circle to sample points (possible edge) on...
FIXME Thats too much. It will find all the circles (so does all 20 balls at once) but it needs to be about 50 times faster than that to be practical.
Could do it only on a subset of the screen and a subset of possible ball sizes, given where balls (in 3d, so 2d radius and x y center) recent positions.
<br><br>
Maybe instead of the 400*300*(140-30)*274=3.6billion, rotate the 2d image webcam sees at about 16 angles around half a circle, and in each of those, compare all pairs of points on edges (where color sharply changes)?
<br><br>
TODO cache an Int32Array (or bilinear filtering needs a latitude and longitude so 2 floats instead of each int) used as 3d of equatorAngles*poleAngles*poleAngles (or more precise than that?) to tell which index in 2d image (wrapped around sphere surface) each of the rotations are in the calculation below "100*50*(2*50)^2=50million calculations" but its the 100*50*50 part just to create the 2 of 3d tensors to copy into gpu or to derive in gpu. Its expensive to compute these 100*50*50 ints cuz they have sine cosine arcsine or something like that, but just a pointer jump to use them over and over.
<br><br>
TODO these are the ball alignment calculations: scan 2d image of what webcam sees for all possible circles with edges (sharp color change) in webcam pixels of circle shape. also maybe adjust for aftrans tilt, squeeze, strange width to height ration in resolution, etc, if its not perfect circle, all possible circles within min and max radius. Do this in GPU.js. Or maybe theres a faster bigo way to do it something similar to hypercubewave? After finding the top few possible circles (or just the 1 best?), do the function(ByteRect,ByteRect){...} -> aftrans4x4 on it, maybe with a few small differences in +1 -2 pixels width height etc, or maybe just get the circle aligned well first and do it once. That gives aftrans between ball webcam sees and simulated ball. Using that aftrans, decay all baxels (pixels on simulated ball surface) color toward what webcam sees, so it will match better in future, but find some way to decay it toward color of fingers less than color of the ball, such as decay it faster toward colors its already similar to those colors. Return (to navigator.getGamepads() or just an aftrans4x4 per ball) the aftrans4x4 of each ball, which is the valuable product this system makes. It tells you the aftrans4x4 of up to 20 tennis balls (with random stuff drawn on them to make them easier for webcam to see rotations) seen by webcam in 3d for use as game controllers, scientific tools, etc.
<br><br>
Create this... function(ByteRect,ByteRect){...} -> aftrans4x4, where the 2 ByteRects are the same width and height, both wrapped around a sphere, and it returns the approx closest rotation that matches their colors (or todo give some function to score each pair of ByteRect contents such as viewing them normed various ways or with convolutional filters etc.
<br><br>
Before do it using rectangle array wrapped around sphere, consider a 3d array of quarternion indexing to do the same thing??? Does that avoid the blurring by angles? Probably the rectangle around sphere is better, but look into it.<br><br>
<br><br>
DO 100*50*(2*50)^2=50million calculations to try all (2*50) alongEquator rotations, no circles.
<br><br>

Instead of circles, create poleAngles (or a few times more for precision?)
number of rotations of each of 2 Ball.baxels (a Float32Array of a rectangle image wrapped around sphere),
so if the images are 100*50 (5000 baxels each) then create 2 * 50 of 100*50 images (2 balls, 50 rotations of each, to be used upsidedown or not, maybe can use each 4 times so 25 of each?)
... so that gives all possibilities of 2 of the 3 kinds of rotation. For the other kind, in GPU.js, check all 50x50=2500 pairs of matching 100*50 to 100*50 pixels to eachother,
per index 0 to 4999 separately, so maybe split it into smaller pieces of the 100x50 such as 100*(1*50) and optimize for storing the most in gpu core local memory as can (if gpu.js even does that).
Within that "all pairs", just compare the 2 images sliding horizontally (slide along equator) at all 100 positions.
If theres 2 * 50 of 100*50 = 5million baxels to copy into GPU (or to compute inside GPU using just 2 * 100*50), then maybe should reduce precision of color, such as put red green blue attention each as a byte in a single int (does gpujs have int array params?) or 6 bits each in the low 24 bits of a float, or something like that. if it fits in 1 float or int each, thats still 20mB per video frame for 2 balls (10mB per ball), and I want up to 20 balls at once, and at least 30 fps (60 is better, many webcams support 60 but webcamjs seems to do 30 at least by default), so thats 600 times as much aka 6 gB/sec, and I doubt browser javascript is up to it.
<br><br>
For 1 ball and 1 video frame, 100x50 baxels, 50 angles, thats 250k baxels copied to (or derived in, either way is that big in gpu memory) gpu,
and 100*50*(2*50)^2=50million calculations to try all (2*50) alongEquator rotations and 2 pole flips or not, between 2 balls (1 that webcam sees and 1 simulated).
My (benrayfield) fast GPU (nvidia 2080 super, rated at 9 teraflops, and which can in native opencl matmul 1000x1000 floats in 1/60 second, or for things that dont need data moved around much up to around 3 teraflops observed)... My gpu using GPU.js can do 10 billion nonlinear pointer jumping like "Math.floor(Math.abs(b*Math.sin(b*.03)*3.567+25/(1+Math.exp(c*.01)))%512);" or 20 billion loop bodies of matmul per second (cuz gpu.js uses webgl compute shaders which seem to do better at pointer jumping than opencl but worse at general matrix stuff). So 20 billion divided by 50 million = can do that 400 times per second, if thats the only thing the computer is doing. So up to 13 balls at 30 fps, though need to save compute time for other stuff so take half of that, and it should work on slower computers too, so this seems to be just barely fast enuf and might need alot of tuning of these params such as using a 50x25 image for balls instead of 100x50.
Just do it for 1 ball for now, and when thats working, and when thats working, allow any number of balls if you have the compute power.
<br><br>
Or maybe its better to just have 1 copy of each ball (100x50) in gpu mem and have it do sine and cosine etc of nonlinear pointer jumping? Try both and compare speeds.
<br><br>
q38x/w/gpujs/testNonlinearPointerJumping001_its10TimesFasterInGpuThanCpu(comparedTo20TimesFasterForMatmul).html
verifies that GPU.js can do nonlinear pointer jumping which doesnt slow it down much, maybe cuz webgl compute shaders are meant for jumping on textures?
<br><br>
DONE: Verify that this way compares every possible angle (to precision of about 1 to 2 pixels). Think of this as happening from 2 random alignments of 2 poletopole lines in the same sphere,
and at some random angle from each, create poleAngles number of copies of that sphere surface (so a 3d wrapped surface per ball, with 1 of the dims being an approx copy at an aftrans).
VERIFIED in "q38x/pic/math/all rotations of 2 balls 3d wrapped surface 001.png".
<br><br>
</h1>

<hr></hr></hr>

<h1>FIXME theres a problem either in the rows vs cols of aftrans or in Ball.prototype.paint in matmul of aftrans and points,
that transpose4x4 or swapping dims etc might fix it, but todo make it consistent across how all 3d objects (with .paint .childs and .aftrans) work.
I know this cuz when I made an AfPoint and Ball share the same aftrans, and moved them on screen with 16 numberboxes, each of the 3 lines moved 1 of the 4 partialcircles, aligning on a corner of that circular spread of points, which means its a dim mismatch where %4 is happening to groups of points, or something like that. [this.childs[0].aftrans = this.childs[1].aftrans; //make ball and afpoint share the same aftrans, to figure out what went wrong]</h1>
<br><br>

FIXME why arent the .childs objects displaying in the AfPoint?
<br><br>

TODO make an object type (with .paint, .aftrans, .childs) thats just a point with a red line, blue line, and green line outward from it,
like seen in common 3d frameworks. Create objects inside objects and move them around. They will be useful for selecting things later,
but for now I need it to fix the ball (Sim.childs[0]) which seems to be split into 4 discontinuous pieces, probably something about plus minus Math.sin vs Math.cos etc.


<code>

<br><br>
TODO rewrite comments about (x y z scale), its not scale.
<br><br>

[[[
** arvox tennis balls as 6d joystick each, 1 in each hand, inline skating game thats pure physics no button combos for tricks do your tricks by physics, multiplayer.
<br><br>
** inline skating game using arvox tennis balls and cannonjs (a browser js physics engine that uses https://en.wikipedia.org/wiki/Gauss%E2%80%93Seidel_method math which is something about matrix, solving energy gradients or something like that. i tried cannonjs demos, very precise physics, low lag when adjust camera to not artifically lag camera movement) andOr https://github.com/schteppe/gpu-physics.js ?
<br><br>
** arvox bookmarklet (similar to spritzlet) that runs something like js code "navigator.getGamepads = function(){ console.log('abc'); }" except it causes that to include a gamepad with 6*numballs number of dims, maybe more dims each such as 1 finger on the ball is a 7th dim so can use it to drag in 6d so you can move the ball without affecting it on screen. This might hook into existing js games automaticly, any of them that call navigator.getGamepads(). getGamepads will be a func that still includes the prev getGamepads func. getGamepads has to be called repeatedly (30 times per second, for example) since what it returns doesnt (though did years ago) change when gamepad is moved. Wait, that seems to break things, so it probably has to be its own js object and only works with games that look for that object. Explore that in https://www.facebook.com/groups/140161666824556/posts/1173323116841734 (text quoted below) and same at https://www.facebook.com/groups/134155323299776/pending_posts/?post_id=4067473453301257&search=&has_selection=false . todo https://dev.to/alvaromontoro/virtual-gamepad-in-javascript-511g ?? S:\q\q38x\pr\gamepadSimulator_howToHookArvoxTennisBallsToBrowserGamepadAPI uses that, seems to work but test in more browsers, and find if it works in existing js games. todo test at https://squidsquadgames.itch.io/tanuki-sunset for example.
<br><br>
** arvox webcam2d to 3d of everything it sees, especially 10 fingertips, as game controllers, and do the basketball rolling from fingterips to arm to back of neck to other hand, dribble between legs, etc. Goviral asap. Consider https://en.wikipedia.org/wiki/Gauss%E2%80%93Seidel_method math for solving energy stuff, like happens in cannonjs but dont necessarily use cannonjs for that. use cannonjs for games but this is just the webcam2d to 3d scanning part.
]]]
<br><br>

Started coding it: var Ball = function()... see above.
And see these vars: BRED BGREEN BBLUE BWEBCAMS BLASTWEBCAM BVARS CRED CGREEN CBLUE CATTEN VARSPERCIRCLE.
<br><br>
<h1>UPDATE: use ~300 circles of smaller radius than radius of the spheres, spread randomly on surface of both spheres (webcam viewed as nearly half a sphere at whatevers yellow circle tennisball like) so wherever there exist 2 circles centered on the same surface point of the 2 spheres (which will occur many times cuz theres theres about 300*300 ways they could align, and within each circle it checks all angles (loop size of 73 if color[73] circles). This seems easier to think about than circles of maximum radius since the circles are smaller and can be closer to an area on spheres surface, and is probably a few times more efficient. I want at least 20 circles to match eachother between the 2 spheres, even though technically only need 1 to find an aftrans match, I want at least 20 so its more reliable and smooth. Try 100*50 boxels/pixels wrapped around sphere surface as simulated ball color, and try many circles of ~40 boxels/pixels. After find approx alignment, hillroll a little for the last few bits of precision. Decay colors similar to the existing springy voxels after find the 1 max aftransform alignment. GPU.js takes 40*300*2 boxels/pixels (600 small circles of 40 boxels/pixels each) and gives back a float[300*300] which are the max of 40 alignments of each bipartitlepair of circles. Then CPU figures out what the 300*300 floats mean since theres distortion in it. matmul that float[300*300] by the 3d vector of surface points on sphere, or something like that, or try various combos. its basically 300 points attracted various amounts (300*300 weights) to 300 points on the other sphere surface, so theres an energyfunc of points near on same sphere must be near on whatever they match to on other sphere. That converges to approx rotation relating the 2 spheres to eachother, and from there hillroll to adjust the last few pixels get that last few bits of precision. That gives the 4x4 aftrans of a tennis ball used as game controller. Use 2 (up to ~20 if more people or hang them from parts of your body etc) such tennis balls to control inlineskates position and angles and from that midbody balance, to make experimental game.</h1><br><br>
<h1>Time to code it (12d inlineskating game, with tennis balls as each controlling movement and angle of 1 foot and midbody balancing)... Solved the pointer jumping optimization problem. Code this asap, and test it on sphere alignment in general (with some parts having random parts changed to simulate interference of fingers holding the tennis balls. This is going to work, be GPU.js optimized, and be fast enuf for 20 tennis balls tracked as 6d game controllers each using webcam in browser, at as low of lag as the webcam itself (which is medium lag, not as low as I'd like, but can look for lower lag webcams later)...</h1><br>
<h3>I'm going to try using GPU.js in browser ( like you can explore a 3d fractal at https://observablehq.com/@rober.../gpu-js-example-mandelbulb ) to brute-force compare 1 million randomly selected permutations of each ball (I know a way to copy only sqrt that much data, cuz matching pairs of permutations, so its compute bottlenecked not IO bottlenecked), between what the webcam sees vs what it thinks the ball's surface looks like (a spherical image), 30-60 times per second, for maybe up to 20 balls at once (so a party game, bring a bucket of tennis balls to a party, hand them out to 10 people 2 each, and instantly they're all playing the game on any chosen screen.</h3><br>
<h2>Consider this possible GPU optimization for aligning 2 spheres with colors on their surfaces: Generate n circles of same radius as the sphere radius, for each sphere, so total 2*n circles. Each is the color of a sphere intersecting that circle, so the circle might be float[100]. So theres 2*n*100 ints copied to GPU. GPU checks approx n^3 permutations by checking all bipartite pairs (float[100] from a circle on webcam and float[100] from a circle on simulated ball), of which there are n^2 pairs, and for each pair it checks 100 alignments, so if n=300 then theres 2*300*100 = 60000 ints (each is a color) in 300 circles on each of 2 spheres. Thats a small amount of data to copy to/from GPU. It could even be alot more than that. GPU compares them at 300*300*100=9million permutations, but only compares 100 pixels/boxels in each (despite there might be 108*54 or 200*100 or 60*30 boxels which the 100 is a circle subset of that sphere surface) For each permutation it does about 100*smallConstant flops, so maybe 900 million flops per video frame per ball. So maybe need to use a little lower resolution and fewer circles. 9 million permutations seems overkill. Each circle will have a dim to exclude certain pixels from affecting comparing accuracy such as if that part of ball is behind fingers or on the back side of ball webcam cant see. The point is, this is compute bottlenecked instead of IO bottlenecked so can GPU.js optimize sphere alignment, and can make the circles a little thicker and find multiple such matches to smooth it and increase reliability, and maybe do mroe detailed precise searches of possible permutations from where these circle alignments suggest a match is likely.</h2>
<hr><hr><hr><hr>
<br><br>
<br><br>
<br><br>
<h1>TODO this: More generally, think about, if given 2 sphere surfaces with n dimensional (such as 3 or 30) color at each surface point, and 1 of the dimensions at each point is to include vs exclude that point (leave unknown or not), then find a good match of least squares color diff of all possible rotations. Consider the limits of GPU to not do jumping based on affine transforms efficiently, and GPU is only available (GPU.js in browser) but not required if make it efficient enough in CPU or do some parts in CPU and some parts (such as feature vectors) in GPU.</h1>
<br><br>
TODO bend webcam pixels to view each small piece of surface as locally flat) and train it (in realtime) to get more featurevector dims (such as 30 dims)
and do that for many parts of the ball webcam sees as pixels and the simulated ball (100x50 boxels wrapped around a sphere). Do that in GPU.js, without
telling GPU anything about rotations. Just have it generate maybe 15x15 pixels (times 3 colors?) -> 30 floats. Or find a way to remove the need for
1 of those rotation dims so the 15x15 gives approx the same 30 featurevectors regardless of rotating 15x15 at smooth angles.
Its just for matching pieces of surface of 2 sphere surfaces to eachother.
More generally, think about, if given 2 sphere surfaces with n dimensional (such as 3 or 30) color at each surface point, and 1 of the dimensions at each point is to include vs exclude that point (leave unknown or not), then find a good match of least squares color diff of all possible rotations.
<br><br>
<br><br>
<br><br>
<br><br>
FIXME FIXME FIXME can GPU.js actually do this efficiently, since the rotation chooses which memory location to read andor write?
Can it be done without such pointer jumping?
For a single aftrans and pixel, how can GPU check the match quality?
..
GPU could efficiently compare 100 rotations if given 2 of 100*50 images, by looping over an offset 0 to 99. CPU could generate about 100*50 of these, so 25million boxels of data... that seems too much data per compare.
<br><br>
If at least 1 of the 2 images (webcam pixels, simulated ball) was stored as a neuralnet whose input is (not aftransed, do aftrans in GPU) 3d position (on its 2d surface) then that avoids the pointer jumping.
If do that for the simulated ball (since it changes slower than the webcam pixels) and not do it in the webcam pixels (of the mostly yellow circle thats probably a tennis ball) then gpu could run 1 thread for each pixel in that yellow circle... NO it has to be 1 thread per aftrans, not 1 thread per webcam pixel, and every thread loops over all those pixels and calls the neuralnet model of (x,y,z)->color (of the simulated ball) once per pixel. But this might take too big a neuralnet to represent the balls surface color.
<br><br>
<br><br>
<br><br>
<br><br>
CANT, unless solve pointer jumping first...<br>
Do this experiment, using GPU.js with 5000 boxels of data copied to GPU and 40000 GPU threads which all use all of that data. That data should fit in the local memory of a GPU core, or can divide it into 40000*n gpu threads with 5000/n boxels each since they are all independent: [[[Dont need to check all possible rotations, just the possible rotations near the previous known rotation, so maybe plus/minus 1/10 of a turn in each of 3 kinds of turning, so (2/10)^3=.008 fraction of the possible rotations, and less often try all the rotations in case it gets out of sync with ball. So it will be 125 times faster that way with no loss of precision except gets out of sync if you move it really fast.
Try this with 100x50=5000 boxels (100 angles at each of 3 kinds of rotation, but actually rotations can be continuous but resolution is finite), and try 20^3=8000 rotations from the last known aftrans, or maybe a few times that to try a few pixels smaller or bigger, so maybe 40000 aftranses of 5000 boxels, so 200 million things to do per ball per video frame. GPU.js might be able to do that. Its somewhere in the ballpark. Can tune params to trade between precision vs latency, and maybe do a few cycles of increasing precision.]]]
<br><br>
Possible optimization: Statistically narrow it down by testing 1 boxel at 1 aftrans at a time, and how good a match it is, add that to stats for that aftrans. Do this for 500k possible rotations, in a Float32Array[500k*2] summing 2 numbers for each of them (total data points, and average match quality). If it werent for fingers being over different parts of the tennis balls etc and variations in lighting and hairyness of tennis balls etc, a single bad match would be enough to exclude. This could be an early step to start with many possible rotations and narrow those down to a smaller number of possible rotations to check in more detail. This step could NOT be done faster in GPU cuz it uses sparse pointers. PROBLEM: before the 100*50 boxel colors converge to the ball colors, this optimization will not work. Maybe its best to just check all of them every time. 100x50 boxels. 5 different diameters (-2 -1 0 +1 +2 pixels different from whats observed on screen) * 20 * 20 * 20 (20 amounts of each of 3 kinds of rotation, each covering the nearest 20% of those possible rotations) = 40000 possible rotations with a precision of each is 1% of a turn in each of 3 kinds of rotation? then todo more precise alignment of selecting from small adjustments to that?
<hr><hr>
<hr><hr>
TODO make an easier simpler system at first, to measure 6 dimensions (x y z position and angle) of each ball, such as a tennis ball (with random drawing on it with pens/markers/etc to make it easier for webcam to see rotation) in each hand, and use that 12d joystick to control the 2 feet of an inlineskating game with acrobatic movements on curves (more dims later, but just 12 to get started), in browser javascript, using GPU.js if necessary. Details..
<br><br>
Use n ballvars (float vars at each surface point of ball), similar to VARSPERVOXEL and VARSPERSPRING. VARSPERBAXEL?
((pi*r)*(2*pi*r))/(4*pi*r^2) = pi/2 so costs only 1.57 times more baxel vars to put it in grid of ceil(pi*r)*ceil(2*pi*r) baxels aka wrap a rectangle texture around sphere with 2 points on the sphere having a whole row of baxels at the same point and its equator having a row and everywhere between.
<br><br>
Of those baxel vars there will be at least red green blue, maybe radius, maybe bumpmapping related stuff, maybe stretching a small distance in x y z (before aftrans), maybe ave and stddev of each colordim, and var (webcamA) for is it visible vs finger etc in front of that part of ball. Include surfaceNormal vars (x y z)?
<br><br>
Each baxel will be like a voxel except its position is chosen by 4x4 aftrans (or 3x4?), in how it decays toward near color, except it intersects much fewer pixels.
<br><br>
The 3d position of the ball will be found some simpler more efficient way than aftrans, but within that 3 numbers are needed which are the 3 kinds of rotation, and those 3 numbers can be expanded to a 3x3 aftrans, or more generally 4x4 aftrans by [x y z 1].
<br><br>
Checking every possible rotation of a ball, even a low resolution one, is an expensive calculation but may be doable using GPU.js and could certainly be done with lazycl in native code outside browser. I'm unsure if its too expensive and should use some other way instead. You just put the whole rectangle texture into every gpu core at once, or parts of it and sum later, and have them try every possible rotation, which if its a 100x50 texture that would be about 100^3 = 1million rotations. Each rotation needs to rotate and compare 100*50=5000 boxels to pixels. So thats 5 billion compares. Needs to be done at least 30 times per second, times the number of balls, and I want it to support at least 10 balls at once, so thats 30*10*5billion = 1.5 billion pixel_compare_to_boxel per second. Each pixel_compare_to_boxel takes an affine transform and dotProduct, sumOfSquares, etc, so might be around 20 flops. So 30 teraflops, and very low IO. I'd guess lazycl on a nvidia geforce rtx 2080 super (rated at 9 teraflops, but it seems to be a few times slower than that even when not IO bottlenecked, in opencl) could do about 3 teraflops. It does about 0.1 teraflop on the n^3 kind of matrix multiply, and GPU.js in browser is about 3 times slower than lazycl native and about 6 times more latency (GPU.js 7 ms vs lazycl 1 ms, not counting time of first JIT compile). 7 ms is not a problem since it seems to take 33 ms per video frame, though I might get that to more fps (such as 60 or 90?), might be a setting in webcam.js etc. So that bruteforce way is too slow. It has to check all possible rotations since the user might move the ball really fast or the ball might go out of view temporarily.
<br><br>
Fourier would in theory give the angle by giving the phases, though it might be expensive to get the angle from the phases of many frequencies, and it would need to be 3 dimensions of fourier of sphere surface rotation which I'm not sure if it does that.
<br><br>
It must work when theres stuff in front of parts of the ball and small changes in lighting such as shadows and reflections, but a tennis ball tends to look about the same color regardless of angle. The existing attract proportional to colorDiff^-2 (or is it 1/(1+colorDiff^2) or something like that?) voxel code (which slowly changes color and faster is attracted/repelled by colorDiff of near pixels should handle boxel colors and not changing toward the color of fingers over the ball since it differs in color too much (some adjustments to the algorithm will be needed for decay toward only similar colors more than decay toward colors that are very different).
<br><br>
Maybe it doesnt need to model the exact appearance of the random lines drawn on the ball, and instead just put a bunch of pieces of fourier together, or fouriers at different ball rotations. Fourier is supposed to get rid of the need for such rotations. Is there something fourier-like that can give me an aftrans instead of a phase, and give an amplitude as usual? Would it be spinning in multiple ways at once like how a CRT screen goes sideways and vertical?
<br><br>
Brute force it at 60*60*30=108000 possible rotations? Would only work on fast gpus.
<br><br>
Brute force it at 30*30*15=13500 possible rotations? Might work, but "2 minutes on a clock" of angle precision is a little too jumpy for my preference. Maybe could do more precise alignment after choose which (or which few) of the "13500 possible rotations" is closest? Could do imprecise alignment while blurred, and unblur it for more precision?
Or could do more possible rotations but fewer points checked.
<br><br>
If (after find which x y radius it is on screen) could match just 1 point on screen to 1 point on the sphere, then theres only 1 dimension left to solve instead of 3,
so if could use GPU.js to find any 2 points, 1 on screen and 1 on the simulated ball, then could do the rest in CPU.
Or similarly could remove 1 of 3 dims by finding a normed form of rotation of it as viewed on screen.
But I dont know how to do any of those efficiently.
<br><br>
Dont need to check all possible rotations, just the possible rotations near the previous known rotation, so maybe plus/minus 1/10 of a turn in each of 3 kinds of turning, so (2/10)^3=.008 fraction of the possible rotations, and less often try all the rotations in case it gets out of sync with ball. So it will be 125 times faster that way with no loss of precision except gets out of sync if you move it really fast.
Try this with 100x50=5000 boxels (100 angles at each of 3 kinds of rotation, but actually rotations can be continuous but resolution is finite), and try 20^3=8000 rotations from the last known aftrans, or maybe a few times that to try a few pixels smaller or bigger, so maybe 40000 aftranses of 5000 boxels, so 200 million things to do per ball per video frame. GPU.js might be able to do that. Its somewhere in the ballpark. Can tune params to trade between precision vs latency, and maybe do a few cycles of increasing precision.
<br><br>
<br><br>
<br><br>
<br><br>
<br><br>

<hr>
<hr>
<h1>OLD...</h1>
<hr>
<h1>TODO start by tracking 12 dims (+ 12 of velocity, so 24, kind of) of both hands when near flat palms up for webcam to see both of,
and make that work in a 3d inlineskating/skiiing/etc game with acrobatic movements, that only needs such 12position+12velocity dims.
After thats working, do harder thing of topological manifold.</h1>
<br><br>
Designing scorefunc...
many voxels in 3d each can move small distances at a time, each have x y z position dims and red green blue color dims.
They have no velocity in scorefunc. Score is higher when they change x y z red green blue slowly (or less) and when
the current webcam pixels match (weighted by 1/(1+colorDiff^2) or something like that) the 3d image of what those voxels look like.
It doesnt matter if the same voxel is on the same object or not. It only matters that it models the 2d curved surfaces of 3d objects
using stream of 2d images. Maybe z position should force ordering of webcamA position, adjusting score by that too,
to avoid storing a bunch of voxels of many different colors all at same pixel and changing visibility of them (which is low friction)
instead of whatever is min z (closest to screen) is most visible.
Springs, velocities, etc are likely a good way, or part of a way, to solve that scorefunc well.
Also voxels will have webcamA color dim and score is lower when the sum of webcamA at each pixel differs (by sum of squared err) from 1.0.
This scorefunc seems to be correct EXCEPT THE Z ORDERING AND WEBCAMA DIMS. TODO think more about it.
To fix the zorder problem, maybe each pixel should have a very low friction z dim, so it has to pick a depth "into the screen"
and do weightedsums of color by whatevers nearest to that, and make the z of pixels tend to be near z of adjacent pixels
but allow it to vary sharply since objects do move in front of eachother, rotate out of view, etc.
Maybe having multiple virtual webcams (only 1 physical webcam needed), each with zdim per pixel,
would help with that? No, not needed cuz voxels have x y z, so that info is directly computable.
But it doesnt seem smooth enuf.
UPDATE: Maybe it should be something about all pairs of voxels that overlap at the same pixel,
as a way to smoothly define webcamA position? If voxM.z < voxN.z and both overlap at same pixel(s),
then of the 4 combos of voxM.webcamA and voxN.webcamA being zero vs nonzero (or somehow gradually),
only the one closer to the screen (lower z) can be nonzero? Seems correct, even though its jumpy.
Basically vox.webcamA is 1 iff vox.z is the max z at that pixel.
Write it as an equation predictedPixelBlue = ...; include z ordering in the equation. including all voxels....
..
Keep the webcamA dim but define scorefunc andor energy to include combo of voxels x y z and webcamA, for every pair of voxels,
and separately for every pair<voxel,pixel>. ??? Resist webcamA being in farther away (bigger z) voxels at the same pixel.
..
Or... Each voxel has a dim that predicts the min z of any nearIn2d voxel?
Also, should every voxel have 3 dims for red green and blue of whichever voxel has min z (and these would be directly set by webcam colors)?
But what if that "min z" prediction is smaller (closer to screen) than any voxel near that pixel?
If so, no voxels would be visible there, which scorefunc/energyfunc would handle.
This doesnt seem to help more than each pixel knowing the min z of voxels near it.
..
Try this? each pixel knowing the min z of voxels near it.
..
How about a bunch of lines (like in raytracing, except no bouncing, its not recursive raytracing) that can move around in 3d
and each line has a color and cant intersect any voxels anywhere along itself except if they have the same (or gradually near) its color?
Such lines that intersect the "viewing position" and 1 voxel, are a oneStep raytrace from view to that voxel.
Maybe have a "viewing position" and a "pixel position" and a voxel, so 3 things intersecting the same colored line?
<br><br>
Older...
<br><br>
Designing scorefunc... The model will predict the next pixel colors incoming from webcam (or something like that, maybe only including the changes of color) and its higher score the better that prediction matches observation. But thats not enuf, cuz it also needs to fit 3d voxels to it. Its higher score per voxel when that voxel has matched color more often of what webcam sees, excluding the webcamA dim being low aka transparent in (red green blue webcamA webcamB) dims, and its lower score per voxel if that voxel changes position too much at once or changes its red green or blue too fast but it can change its webcamA position (between hidden behind other voxels vs visible) fast. Its lower score for if any part of 2d webcam pixels have no voxels at them (sum of webcamA color dim there). Ignore springs in this scorefunc since they are just a model of how voxels might solve the scorefunc better. Score is higher when, ...I dont know how to define this exactly... voxels stick to the 3d surface of objects webcam sees even if its all the same color instead of for example  20 voxels moving around mostly randomly inside that area of mostly the same color.
<br><br>
Older...
<br><br>
TODO Define some automated score func (function(sim)->number) for what the sim should do, to measure which possible states of the sim are better or worse.
Even though it may be impractical to explore lots of those (or more than 1 in realtime), it would be useful as a math abstraction to do backprop
or to help a human programmer design potentialEnergy funcs and friction funcs toward it scoring higher.
For example, if each voxel accumulates decaying score for how well its tracking whatever object its on, measured by less color diff is better (and considering how fast it changes its color), and that score might be used by springs to know if what they did recently was good or bad (though thats not a good approximation of qlearning).
<br><br>
Designing scorefunc:
Start with the abstract idea that the system is timeless and positions are in GPSlike coordinates (x y z time),
so each voxel is a path thru 4d space where each (x,y,z) crossSection has just 1 of them.
A voxel is (time)->[x,y,z,red,green,blue,webcamA,webcamB] where (time+dt)->[x+dx,y+dy,z+dz,...], were webcam* dims are how much visible a voxel is to that webcam.
At each point in that 4d space is a vector such as (red,green,blue), which is per webcam since they each have their own webcamAX webcamAY webcamAZ etc.
Friction has to be implemented timelessly, so it just resists a difference of position in some dims (may be derivedpos dims?) by sumOfSquaredErrors etc.
In practice, only 1 or 2 crossSections (all the same 1 or 2 consecutive times, separated by dt) will be stored in memory at once,
and use derivatives of a scorefunc (hopefully, todo) to hillroll to the "next state" aka to generate the next crossSection.
But I'm unsure how to do that optimization since scorefunc is likely to need to know things farther back in time (such as last 5 seconds?)
so it can sacrifice things to gain greater things when not all of those things are happening right now.
If it is to be timeless, then the scorefunc might need to be part of the state which changes from one time to the next,
so the scorefunc might need to refer to changes in the scorefunc such as by diffeq (differential equations)???
That seems hard to do if scorefunc is designed to score a state space that exists across [many things at x y z and time, totalling thousands of dims].
Qlearning AIs are designed to solve those kinds of problems but are an expensive calculation especially for sparse high dimensional things.
If scores could occur at times, at each voxel andOr each spring, then potentially qlearning could be trained to seek such decaying changes in score,
so thats probably a better way to define scorefunc than on the space of all time.
If the score depends only on what its doing at the time, thats something that can be directly represented as a potentialEnergy curve and hillroll on it.
I'm not sure I can describe yet what I want the voxels do exactly, but I know some things I dont want them to do,
such as jump around really fast, be near pixels in 2d that have large weightOfDistanceBetweenVoxelAndPixel*colorDiff^2,
form strong springs between so many pairs of voxels that they all clump together into 1 object, change color faster than change position, etc.
Think of it as theres a few params per spring that can be varied, including wide, restlen, strength, and a few params per voxel that can be varied,
including x y z red green blue webcamA, and these params can be accelerated in (not change position directly) without changing potentialEnergy
in many combos (but some combos total different potentialEnergy, so make sure not to create or destroy en=pen+ken+hen).
Within those possible actions in the "game tree" (actually its a smooth manifold), a qlearning AI or simple hillrolling somehow,
could try to reach higher score, as each game state would give a change in decaying score (maybe per voxel and per spring etc),
so a very very small neuralnet could be trained in realtime (so small it fits in a GPU kernel) to estimate qscore depending on
various possible changes to those params (accel to change velocity to change position of those vars).
The gradient of the qscore func would be how to navigate a manifold of qscore,
though might also need velocity in the qscore func to avoid getting stuck in localmax (or localmin if viewed as energy).
<br><br>
Abbrevs: energy en. potentialEnergy pen. kineticEnergy ken. heatEnergy hen.
<br><br>
TODO separate pen into these:
penVox //attraction between each voxel and near voxels by colors (weight of color is currently a circle but todo 2d bellcurve) proportional to colorDiff^-2.
penSpring //just the 1/(1+x^2) kind of stuff, scaled of course, and including the wide and amountExistsVsCostsToNotExist dims and maybe a few other dims per spring.
penRepel3d //voxels repel when too near in 3d
penRepel2d //resist having more than a few voxels overlapping at the same pixel
<br><br>
TODO some kind(s) of friction on movement in these spring dims:
len
restLen
wide
amountExistsVsCostsToNotExist
<br><br>
Friction on voxel movement (decay velocity? linear friction?).
Prevent voxels from leaving screen rectangle (will turn off this rule later).
<br><br>
<h1>
This next chunk of work to do is to get the basics working of springs fading into and out of existence (sweak sstrength etc) based on potentialEnergy curve only (with a few kinds of friction on len, restlen, wide, and voxel dims). Simplified rewrite of what to try next... Gradient of spring potentialEnergy will be computed using 4 (1+3) instead of 2 (1+1) calls of springPotentialEnergy, since theres 3 dims (len, restlen, and wide) to hillroll in instead of just 1 (len), plus epsilon distance in each. Keep repel as part of potentialEnergy of springs, but dont display it on spring lines. Voxels will start using velocity but not potentialEnergy (yet?) cuz easy to use existing yxrgbDeriv func, instead of making it part of potentialEnergy, but add dt*that to velocity instead of adding dt*testspeed*that to position, then springdampening and other friction applies to those summed velocities. Put in custom friction code for springDampening and for friciton in wide (a dim) and for friction in restlen, and have a few tunable params for each of those kinds of friction including linear, velocityDecay, etc, and put in slidebars for all those. Remove slidebars for fields not used anymore after this small redesign. Tune all the slidebars manually. Repel will have 2d (where they align to pixels) and 3d kinds, potentialEnergy for both. Keep in mind that things designed using a potentialEnergy func (with or without friction) are exponentially better at avoiding overfitting than nonunitary models, since nomatter what the nonunitary friction does, it cant change the unitary potentialEnergy func which it just slows things down while moving along. Add a slider for how much randomness to add to velocities, and maybe also to the wide and restlen dims per spring, instead of only having the restart button. (UPDATE: cuz of how voxels to end to move toward top left corner when they're small, change voxel pixel color interactions to completely potentialEnergyOfVoxel based, and call it 3 times, once at here and here+dy and here+dx, and abstractly represent pixel colors as each pixelr pixelg pixelb is a dim and it has infinite friction (or very high) and webcam just pushes past that friction anyways to move them. Similar for all the Sim.varnameXYZ and sliders/checkboxes of them, they are dims with very high friction, so the state space of the whole system So the whole system is a vector (many thousands of dims, todo sparse later), including vars that vary the friction and potentialenergy etc of other combos of dims which some of the sliders already do. But it still needs some steps to happen before/after others like springDampening must happen after voxel velocities are summed but the potentialEnergy func is a single curve for the whole system and is computed in 1 step as the first step of every timecycle and everything after that is just for updating velocities and stateless friction). Create maybe 2 more arrays, Sim.voxelGradient, Sim.springGradient, (or call them accel instead of gradient?) where the position+dx position+dy position+dwide etc are computed in a loop (easier to GPU.js later) before velocity += dt*that???
<br><br>
If that doesnt work at first (with tuning the slidebars manually), figure out whats wrong using the display of springs, then think about adding a few more manually designed vars to fix that specific thing thats going wrong.<br>
Try some of this stuff only if that doesnt work...
</h1>
<br><br>
The complex disorganized writing: TODO upgrade the potentialEnergy gradient to include spring dims and voxel dims and voxel and webcam colors, and do everything as gradient along that, and just put in custom friction code for springDampening and for friciton in wide (a dim) and for friction in restlen, and have a few tunable params for each of those kinds of friction including linear, velocityDecay, etc, and put in slidebars for all those. Display repel3d and repel2d separately from spring potentialEnergy. Make springs fade in and out based on potentialEnergy, and just have those few kinds of friction. Using potentialEnergy this way will extremely reduce overfitting. Gradient of spring potentialEnergy will be computed using 4 (1+3) instead of 2 (1+1) calls of springPotentialEnergy, since theres 3 dims (len, restlen, and wide) to hillroll in instead of just 1 (len), plus epsilon distance in each. That way I dont have to adjust len, restlen, and wide by manual code, I just have to define potentialEnergy func and a few kinds of friction. Get AI to help tune this based on simple measurements of how well its matching webcam to model. Springs will display potentialEnergy along len. restlen and wide (2 dims) will not be displayed except as affecting the similar-to-ave-and-dev of the spring potentialenergy func along the line between 2 voxels. remove the repel from that display. Next task is simply to make the springs fade in and out based on whether they tend to be recently varying more or less in length, using only potentialEnergy and those few hardcoded kinds of friction. Use existing yxrgbDeriv func, instead of making it part of potentialEnergy, but add dt*that to velocity instead of adding dt*testspeed*that to position, then springdampening and other friction applies to those summed velocities.
<br><br>
TODO make some kind of on screen tool (mathevo-like, see physicsmata code with that grid of colored squares for making a forest of math expressions by clicking, but also todo include weightedsums in that) to compute every dim of diffeq, with various kinds of norming built in related to total sstrength at a voxel, dotProducts maybe, springDampening friction maybe... just find a way to make it flexible enuf to know a solution is somewhere in that possible space, then use it to update spring vars and voxel vars. Use various kinds of AI to help me click thru the space of possible simple diffeqs while seeing what it does on screen instantly. Have a place to "bookmark" nodes in the diffeq forest so can try combos of them again later. Once I get thru these basics, use AI to auto tune it by its performance on making the voxels move with the colors on screen. Remember whatever it comes up with needs to be GPU.js optimizable even though it wont be GPU for now. Or simpler than mathevo ui, put a textarea for js code and compute the diffeq there, seeing it instantly, without needing to type this.springs[ss+SRESTLEN] etc, just use "restlen", and can make up temp vars. Compute drestlen etc at end and automaticly restlen += dt*drestlen. Include buttons to save and load state, like bookmarks. Make it easy to do more experiments faster. Also start making some scorefuncs for different measurements about how good a job the system is doing at modelling what the webcam sees. When a voxel moves to somewhere thats already its own color, excluding its recent change in color (varying decay of its colordims toward near colors is automatic and tunable), thats some evidence that its working right, for example. The more areas of the screen that have no voxels over them, the worse the system is doing. If make enough measures of this, then can in theory auto tune it to score better at the system as a whole which might be a weightedSum of these kind of things. The "test objects" (such as rotating circle(s) whose perimeter is made of colored circles) can help in automating that.
<br><br>
TODO consider this simpler thing than springs: an "inductor of distance" between each 2 voxels, which proportional to sstrength, resists change in distance between them. It doesnt have to hillroll to match the distance. It acts only on their difference in velocities. Theres no potentialenergyfunc of position, but maybe a way to think of it is theres one for velocity at each moment, so in each moment it would act similar to springs on velocities between pairs of voxels. How to choose sstrength, I'm not sure of yet. Problem: it would tend to forget distances as they vary slightly over time and it would just keep resisting change in those. First try just the 1/(1+x^2) potentialEnergy with x=(len-restlen)/wide and have a 3d energy hill for each spring that varies wide and strength (also pushing wide to be bigger for "spring not exist" and smaller for "spring exist" so energy pushes spring to exist when spring stays approx same length recently and pushes spring to not exist when spring varies too much in length. Or maybe some kind of decaying bellcurve. just play with it. too much abstraction is leading to more vars than is needed and I'm getting confused. Or maybe add a few more dims without knowing what they mean and have some small neuralnet choose diffeq (dervs of those dims) which is repeated for every spring to change spring vars, to tune the springDampening friction etc.<br>
<br>
TODO simulate 3 voxels and 3 springs (between all 3 pairs of voxels),<br>
implementing springDampening, velocity decay, friction on a flat surface, and maybe make a fourier frequency detector using such springs (for musical instrument simulation, as an example of what a musical instrument can do, the fourier measurer is an intrument itself)... using...<br>
..<br>
These are constant funcs: heatFraction_vector (a func of position and velocity), potentialEnergy (a func of position).<br>
accelRaw is gradient of potentialEnergy at position, so is derived from potentialEnergy func and is therefore itself a constant func.<br>
potentialEnergy func is sum of 2 funcs, one for the springs+repelNear, and one for the combo of voxels and pixel colors.<br>
The latter ("one for the combo of voxels and pixel colors") varies as new pixels come in from webcam,<br>
or you could say that its just a higher dimensional constant potentialEnergy func that we are moving in to vary pixel colors,<br>
as in 3+numberOfWebcams dimensions for each pixel (red, green, blue, webcamA, webcamB, etc),<br>
but since I dont plan to compute velocities and accelerations in those pixel dims, maybe its better to model it as a varying potentialEnergy func?<br>
..<br>
heatFraction_vector(position,velocity) always returns a vector whose len ranges 0 to 1, for any possible position and velocity.<br>
accelRaw(position) = deriv(potentialEnergy(position));<br>
heatFraction_vector = heatFraction_vector(position,velocity);<br>
heatFraction = dotProd(normToUnitVec(accelRaw),heatFraction_vector).<br>
accelHere(position) = accelRaw*(1-heatFraction);<br>
heatHere = len(accelRaw)*heatFraction;<br>
heat += dt*heatHere;<br>
velocity += dt*accelHere;<br>
position += dt*velocity;<br>
..<br>
That seems right. But think about it more, then simulate it, and make sure the 3 springs between 3 voxels<br>
vibrate as expected and springDampen to vibrate less and less until they stop moving after a few seconds.<br>
<br>
TODO thats not exactly right. make velocity only change along heatFraction_vector or along that normed to unit length, or something like that. Theres still work to do figuring out this springDampening thing, but this is progress.<br>
<br>
TODO this will be used to make the whole thing into a smooth curve of thousands of dimensional position and velocity and heat etc,
especially the swide and srestlen dims per spring etc for those to have various kinds of nonlinear friction so the springs potentialenergy hills tend to get dragged wider faster than they tend to move their center/restlen. the repel part of springs will be more constant but has to be included. the voxelpixelcolor interactions also have to be included. it will all be 1 smooth curve of all possible such manifolds, that every possible thing a webcam could see is already part of, that it hillrolls (with nonlinear friction implementing springdampening of all possible springs, and other kinds of friction), so the whole possible state space of the arvox system will be a constant function, a constant manifold, in which all possible smooth manifolds of this type are a subset, and with friction (nonunitary increasing heat sometimes) and hillrolling, the purpose is for it to fit a 3d topological manifold to whatever a 2d webcam sees at gaming-low-lag and give 30 numbers for 3d positions of all 10 fingertips (and more) many times per second starting within a few seconds of when a webpage running this is loaded and person clicks yes allow webcam.<br>
<br>
TODO simplify that by mainPosition->derivedPosition, where derivedPosition is extra dims that can be any forest of [number,number]->number math ops such as plus multiply tanh etc, and from those can be derived extra dims that are length of a certain spring. Within derivedPosition there is a constant friction (or maybe separate friction per derived dim, so manhattan distance instead of sqrtOfSquares distance) which any movement is friction in, so that can do springDampening as friction since it can put friction on the change in 3d distance between 2 voxels (6 dims) but cant do velocity decay cuz for that it would need velocity to be an input. To have more or less friction, scale the derivedPosition dims to magnify more or less (some function of) what they see in mainPosition. Would this be enuf to do the change of wide in (len-restlen)/wide (wide is a little similar to stddev) and changes in restlen? Or dooes it need friction to decay on velocity too? Its much simpler for friction only to depend on path thru mainPosition and maybe speed at each point in the path. But if theres springDampening, that changes the path. FIXME. allpos = concatVecs(mainpos,derivedpos). If I allow both friction (velocity subtract) and velocityDecay (velocity multiply by 1-decay*dt) on derivedpos directly, then derivs could be taken between mainpos and derivedpos. [position in mainpos, velocity in mainpos] -> [position in derivedpos, velocity in derivedpos]. So if its just normal friction and normal velocity decay in certain dims, then both velocities can be computed by change in both positions, and [mainpos]->[derivedpos] can be used with [mainpos+epsilon*anyDim]->[derivedpos at that position] so can do that and divide the position difference by epsilon to compute velocity in derivedpos. But the nonlinear relation between mainpos and derivedpos (such as a dim of a certain spring's length being sqrt((xa-xb)^2 + (ya-yb)^2 + (za-zb)^2)) might make it hard or inefficient to compute such derivatives in the context of where to apply friction and velocityDecay. springDampening is friction on change in length of a spring, so how can I write that in terms of xa xb ya yb za zb? Also I want velocityDecay ability for springs and other dims of derivedpos. I'd prefer if the amount of friction is more flexible than just linear (normal friction) and decaying (velocityDecay), like I might want friction thats proportional to velocity^2.34 or any arbitrary math expression. The nonlinear relation is NP flexible between mainpos and derivedpos, like you could make a derived dim whose max value depends on a 3sat problem of the dims in mainpos, but its still limited in that the friction is only of the linear movement in that derived dim andOr velocitydecay. Could I make chuasCircuit with this? Could I make a circuit with parallel and series combos of capacitors, inductors, resistors, transistors, combining that with the energy func of springs including springDampening? Is there any existing machine or physics theory ever imagined, that this model could not (however ineffficiently) be used to simulate? With only friction and velocityDecay, its not flexible enough to do that. I want to make it as flexible as I can before I get back to tuning it, so I know that a solution is in that possible space and then I keep narrowing down subsets of subsets of possibilities until the thing works on screen, not to say other solutions dont exist but I only need at least 1 solution that works. An inductor is a resistor of velocity. Whatever velocity there is, an inductor tries to keep it that velocity. Normally of electrons but these dims are not specific to that. I'm hesitant to make it flexible enuf to do inductors cuz then the velocity changes the velocity and it becomes a differential equation including a weighted sum of all possible equations. FIXME how to limit velocity in derivedpos? Velocity in mainpos is limited by energy, but derivedpos could be anything, such as 2^(2^dimABCInMainpos) or dimABCInMainpos*100 or dimABCInMainpos*.02. For a dim thats just the 3d distance between 2 voxels as 6 dims in mainPos, that velocity can never be more than the velocity in mainPos, but some math expressions can be, and I'm not sure what math expressions I'd need for tuning wide, restlen, etc, and I might need to create more dims (vars in springs, and other vars in voxels to help norm those spring vars) for more advanced ways of tuning it and it having state to remember things derived from what happened recently. Maybe it doesnt matter that velocity in derivedpos isnt limited by energy since the worst thing it can do is create friction that exceeds the velocity in mainpos so it would just stop in those parts or whole. Choose the friction-related force at derivedpos later. First, how to do backprop between mainpos and derivedpos (to translate that friction-related force to mainvel)? sqrt((xa-xb)^2 + (ya-yb)^2 + (za-zb)^2)) = springABLen. springABLen is a derivedpos dim. The other 6 are mainpos dims. But consider that it could be sqrt((xa-xb)^2 + (ya-yb)^2 + (za-zb)^2)) + xa*yb - za*ya*yb = springABLen, or any math expression, so its not as easy as using known spring math. Theres more dims in the spring-like-things than just a normal spring. Theres varying its restlen, strength, etc, and other experimental dims to be added later. The backprop is at a known mainpos and mainvel. The ^2 and * etc make multiple possible inputs (mainpos) have the same output (derivedpos), so its important to use the given mainpos. Could replace all xa with (xa+epsilon), and compute the new springABLen, and similar for all 6 input vars at the given mainpos. They would probably give 6 different numbers, that vary depending on which mainpos is input. The sum of those 6 numbers (combined with mainvel, not just mainpos, cuz its a force changing mainvel) can cancelout part or all of eachother such as 2 voxels moving in a circle with constant distance between eachother that always cancelsout so no movement in springABLen, or if moving in an oval then some movement in springABLen, or if vibrating as a spring then alot of movement in springABLen except when its not moving at its longest or shortest while changing direction smoothly. I can compute a math expression to eval to get d(springABLen)/d(xa) etc. But what to do with that? If want to change spring length by 1 (actually it would be velocity of that in mainvel, but consider this simpler example of changing length in mainpos...) and spring is at a randomly chosen angle, then how to know to change those 6 dims of position (xa xb ya yb za zb) in a way that doesnt change that angle but only changes the length, without knowing that represents 3d space since it might be some other energy function such as the internal workings of a musical instrument. Whatever chooses how much to change that position (6d in this case) has to do it using ONLY backprop without knowing what the inputs or outputs mean. Think of springABLen as a 6d heightmap, like if you write "graph z = -sqrt(x^2 + y^2)" in wolframalpha except thats only 2 dims and z is height. Acceleration down that hill would be gradient of the hill, so if x is 8 and y is 6 then gradients (x/sqrt(x^2 + y^2) and y/sqrt..., wolframalpha says) are .8 and .6 which if you add that to (x,y) it preserves the angle. Similar, if its 6d and x=(xa-xb) then equal amounts of gradient go to xa and xb (one is negative of the other). So in theory it works for preserving spring direction. Make sure to only move energy to heat for the total movement in springABLen (and more generally any derivedpos dims) so use the sum of those 6 (or n) derivs (dotProd with velocity (mainvel translated into derivedvel) instead of sum of 6 individual frictions, since 2 voxels can move/rotate/etc without changing the distance between them. Also, such gradient can be different sizes depending on which math expression relates it to mainpos and which position it is. But it seems that calculation isnt needed since it can just be computed from mainpos to change in derivedpos, and pay an amount of friction (or velocity decay or support more advanced math expressions?) of that change along the vector of that 6d gradient in mainpos/mainvel so the springDampening only has friction of the change of spring length. That solves the problem of how to do the backprop. Next, choose what force in derivedpos dims to backprop. It has to be a friction-like force but may be more advanced math expressions such as velocity decay etc. Wait, before I get to that, how are the sum of multiple springDampening frictions on the same voxel (multiple springs on the same voxel) limited to only reduce its velocity (relative to other voxels at the end of those springs) instead of having so much "slowing down from friction" that it accelerates the opposite direction? It would be easier if each thing that adds to the potentialEnergy curve adds an amount of friction/etc thats at most the velocity added by rolling down that, but I'd prefer potentialEnergy and friction to be tunable separately so it can do more flexible equations in general.<br>
<br>
See "parabolas and inverse parabolas for spring potentijalEnergy.txt" for details (TODO include the text leading to these equations).<br>
<br>
<h1>TODO move this bunch of text and earlier text (maybe 6 pages) either all into this file or all out of this file, but dont have some here and some in earlier versions of this file, cuz it might get lost.</h1>
</code>




</body></html>