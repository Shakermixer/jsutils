<!DOCTYPE html>
<html><head>
<meta charset="UTF-8" /> 
<script src="webcamjs_mitLicense_1.0.24.js"></script>
<script src="gpujs_browser_mitLicense_2.11.0.js"></script>
<script>
//This code is opensource MIT license, by Ben F Rayfield 2021-7+, or someone may have forked after that.

"use strict";

var theGpu = null;

var gpu = function(){
	if(!theGpu) theGpu = new GPU(); //gpu*.js
	return theGpu;
};


//2 canvases of same size. webcam goes in a <video> dom object which is copied to canvasIn, then preprocessing (flip horizontal, etc),
//then Sim.io(dt,byteRectIn,byteRectOut) reads canvasIn, does physics/energy calculations, and writes canvasOut,
//then repeat many times per second for realtime augmented reality using webcam.
//ODO Sim.io use GPU.js optimization for springs and nonlinear color pull on voxel near those pixels.
var canvasInContext = null;
var canvasOutContext = null;
var canvasInImageData = null;
var canvasOutImageData = null;
var canvasInPixels = null;
var canvasOutPixels = null;
var canvasIn = null;
var canvasOut = null;
var byteRectIn = null;
var byteRectOut = null;

//utc seconds
var time = function(){
	return Date.now()*.001;
};

var updateCanvasObjects = function(){
	canvasIn = document.getElementById('canvasIn');
	canvasOut = document.getElementById('canvasOut');
	if((canvasIn.width != canvasOut.width) || (canvasIn.height != canvasOut.height)) throw 'Diff size canvases, canvasIn and canvasOut';
	canvasInContext = canvasIn.getContext('2d');
	canvasOutContext = canvasOut.getContext('2d');
	canvasInImageData = canvasInContext.getImageData(0, 0, canvasIn.width, canvasIn.height);
	canvasOutImageData = canvasOutContext.getImageData(0, 0, canvasOut.width, canvasOut.height);
	canvasInPixels = canvasInImageData.data;
	canvasOutPixels = canvasOutImageData.data;
	byteRectIn = new ByteRect(canvasInPixels, canvasIn.height, canvasIn.width);
	byteRectOut = new ByteRect(canvasOutPixels, canvasOut.height, canvasOut.width);
	//console.log('updateCanvasObjects done.');
};

const AX = 0; //affineTransform X
const AY = 1; //affineTransform Y
const AZ = 2; //affineTransform Z
const AS = 3; //affineTransform S. TODO rename to M for Move or P for position.

const AXX = AX*4+AX; //affineTransform X-&gt;X (FIXME or is it <- ?)
const AXY = AX*4+AY;
const AXZ = AX*4+AZ;
const AXS = AX*4+AS;
const AYX = AY*4+AX;
const AYY = AY*4+AY;
const AYZ = AY*4+AZ;
const AYS = AY*4+AS;
const AZX = AZ*4+AX;
const AZY = AZ*4+AY;
const AZZ = AZ*4+AZ;
const AZS = AZ*4+AS;
const ASX = AS*4+AX;
const ASY = AS*4+AY;
const ASZ = AS*4+AZ;
const ASS = AS*4+AS; //TODO rename S to O for offset or P for position, or something like that. its not scale. its for position.

//byte offsets for ByteRect, canvas, etc, in js.
const RED = 0, GREEN = 1, BLUE = 2, ALPHA = 3; //ALPHA isnt used in voxels, so another const also equals alpha's constant.
var colorDimRed = RED;
var colorDimGreen = GREEN;
var colorDimBlue = BLUE;
var colorDimAlpha = ALPHA; //these colorDim* vars are from older code. todo replace them with RED GREEN BLUE ALPHA.

//FIXME position and velocity for all such vars? or just for VX VY VZ?

const NUMWEBCAMS = 1;

if(!(NUMWEBCAMS > 0)) throw 'NUMWEBCAMS='+NUMWEBCAMS+' and must be at least 1. TODO: Each voxel (including baxels on ball surface) has a fraction for how much each webcam can see it, in the simplest case is 0 or 1 but may be between if its on a surface at an angle.';

//voxel dim indexs
const VRED = RED;
const VGREEN = GREEN;
const VBLUE = BLUE;
//const VHEAT = 3; //store heat energy here, moved from spring-dampening friction and velocity decay etc, and adjacent voxels/springs, and taken from here when need to move more.
const VX = 3;
const VY = 4;
const VZ = 5;
//index of the first of n webcams (by default is just 1), which each have a color dim of how much they can see each voxel, so what they see next pushes on those and not whats hidden (from their view) behind other voxels.
//screens count as webcams that do statsistical inference in reverse to generate pixels from voxels instead of generate/update voxels from pixels.
const VWEBCAMS = 6; //index of first webcam. //TODO rename to VWEBCAMSTART or VFIRSTWEBCAM?
const VLASTWEBCAM = VWEBCAMS+NUMWEBCAMS-1; //index of last webcam.
const VARSPERVOXEL = VLASTWEBCAM+1;

//spring dim indexs
//
//OLD (cuz created SWEAK, which used to always be 0):
//sstrength multiplies how much the spring accelerates 2 voxels its between toward or away from eachother.
//This is how sparse springs fade in and out to change topology of the manifold of voxels.

const SWEAK = 0; //potentialEnergy of spring ranges SWEAK to SSTRENGTH.
const SSTRENGTH = 1;
//const SHEAT = 1; //store heat energy here, moved from spring-dampening friction and velocity decay etc, and adjacent voxels/springs, and taken from here when need to move more.
const SAVEDIST = 2; //this decays toward the average distance between the 2 voxels, so when they're near that distance, SSTRENGTH increases else decreases.
const SRESTLEN = 3; //the at-rest-length of the spring, its length if nothing is squashing or stretching it
const SFRICTION = 4; //spring-dampening-friction which resists change in the distance between the 2 ends
const SDOWNFROM = 5; //see comment in potentialEnergyOfSpring
const SWIDE = 6; //see comment in potentialEnergyOfSpring
const VARSPERSPRING = 7;
console.log('VARSPERSPRING='+VARSPERSPRING);

//B vars mean BALLVOXEL aka BAXEL, a point on the surface of a ball (such as a tennis ball with random curves drawn on it to make it easier for webcam to see it turning).
//BX BY and BZ are not included since Ball stores these densely in a rectangle array (Float32Array) that wraps around sphere surface.
const BRED = RED;
const BGREEN = GREEN;
const BBLUE = BLUE;

//TODO: Each voxel (including baxels on ball surface) has a fraction for how much each webcam can see it, in the simplest case is 0 or 1 but may be between if its on a surface at an angle.';
//index of first webcam. This color dim means how much this part of ball is visible to webcam, instead of on back side of ball or behind finger holding ball etc.
const BFIRSTWEBCAM = 3;
const BLASTWEBCAM = BFIRSTWEBCAM+NUMWEBCAMS-1; //index of last webcam
const VARSPERBAXEL = BLASTWEBCAM+1;
console.log('VARSPERBAXEL='+VARSPERBAXEL);

//C vars are pixels in a circle in a ball.
const CRED = RED;
const CGREEN = GREEN;
const CBLUE = BLUE;
//attention, similar to webcamA webcamB webcamC... dims except this is how much influence it has when circles are compared
//to eachother for matching colors at a number of rotations (take the max match) same number as how many pixels in each circle.
//all circles have the same number of pixels, somewhere around 1/4..1/20 as big a circle as the equator of spheres.
const CATTEN = 3;
const VARSPERCIRCLE = CATTEN+1;
console.log('VARSPERCIRCLE='+VARSPERCIRCLE);



//readable and writable pixels as Uint8Array. A canvas is a kind of Uint8Array.
//Single pixel read and write funcs are slow unless you just do a few places.
//TODO Write horizontal lines of same color or 2 colors on end interpolating between,
//and these lines can be derived from triangle which has different color at each corner.
var ByteRect = function(bytes, height, width){
	this.bytes = bytes;
	this.height = height;
	this.width = width;
};

ByteRect.prototype.copy = function(){
	let newBytes = new Uint8Array(this.bytes.length);
	copyBytes(this.bytes, newBytes);
	return new ByteRect(newBytes, this.height, this.width);
};

//TODO choose [y x] vs [x y z scale] order. Swap y and x in ByteRect params order? aftrans is [x y z scale].

ByteRect.prototype.index = function(y, x, colorDim){
	return (y*this.width+x)*4+colorDim;
};

ByteRect.prototype.read = function(y, x, colorDim){
	return this.bytes[(y*this.width+x)*4+colorDim];
};

//TODO bilinear interpolation for smoother color?
ByteRect.prototype.readSafe = function(y, x, colorDim){
	return this.bytes[betweenInt(0,(Math.round(y)*this.width+Math.round(x))*4+colorDim,this.bytes.length-1)];
};

ByteRect.prototype.readBrightnessSafe = function(y, x){
	let i = between(0, (Math.round(y)*this.width+Math.round(x))*4, this.bytes.length-4);
	return (this.bytes[i+RED]+this.bytes[i+GREEN]+this.bytes[i+BLUE])/3;
};

/** same as readBrightnessSafe but as Float32Array whose length is this.bytes.length/4. a copy, not backing. */
ByteRect.prototype.brightnessFloats = function(y, x){
	let ret = new Float32Array(this.bytes.length/4);
	let i = 0;
	for(let j=0; j<this.bytes.length; j+=4){
		ret[i++] = (this.bytes[j+RED]+this.bytes[j+GREEN]+this.bytes[j+BLUE])/3;
	}
	return ret;
};

ByteRect.prototype.write = function(y, x, colorDim, bright){
	this.bytes[(y*this.width+x)*4+colorDim] = bright;
};

ByteRect.prototype.writeSafe = function(y, x, colorDim, bright){
	this.bytes[between(0,(Math.round(y)*this.width+Math.round(x))*4+colorDim,this.bytes.length-1)] = bright;
};

ByteRect.prototype.writeSafeRGBA = function(y, x, redByte, greenByte, blueByte, optionalAlphaByte){
	if(optionalAlphaByte === undefined) optionalAlphaByte = 255; //visible
	let index = between(0,(Math.round(y)*this.width+Math.round(x))*4,this.bytes.length-4);
	this.bytes[index+RED] = redByte;
	this.bytes[index+GREEN] = greenByte;
	this.bytes[index+BLUE] = blueByte;
	this.bytes[index+ALPHA] = optionalAlphaByte;
};

ByteRect.prototype.writeSafeBright = function(y, x, brightByte){
	let index = between(0,(Math.round(y)*this.width+Math.round(x))*4,this.bytes.length-4);
	this.bytes[index+RED] = brightByte;
	this.bytes[index+GREEN] = brightByte;
	this.bytes[index+BLUE] = brightByte;
	this.bytes[index+ALPHA] = 255;
};

ByteRect.prototype.atYXWriteRGB = function(y, x, redByte, greenByte, blueByte){
	let ind = (y*this.width+x)*4;
	this.bytes[ind+RED] = redByte;
	this.bytes[ind+GREEN] = greenByte;
	this.bytes[ind+BLUE] = blueByte;
};

ByteRect.prototype.writeHoriz = function(y, fromX, toXExclusive, colorDim, fromBright, toBright){
	var indexStart = this.index(y, fromX, colorDim);
	var pixelSiz = toXExclusive-fromX;
	var siz = pixelSiz*4;
	var bright = fromBright;
	var brightAdd = (toBright-fromBright)/pixelSiz;
	for(var i=0; i<siz; i+=4){
		bright += brightAdd;
		this.bytes[indexStart+i] = Math.floor(bright) & 0xff;
	}
};

ByteRect.prototype.flipHorizontal = function(){
	let bytes = this.bytes;
	for(let y=0; y<this.height; y++){
		let xMid = Math.floor(this.width/2);
		let offsetA = y*this.width*4; //first byte index of first pixel in row
		let offsetB = ((y+1)*this.width-1)*4; //first byte of last pixel in row
		for(let x=0; x<xMid; x++){
			for(let colorDim=0; colorDim<4; colorDim++){ //swap 2 pixels as 4 bytes each
				let temp = bytes[offsetA+colorDim];
				bytes[offsetA+colorDim] = bytes[offsetB+colorDim];
				bytes[offsetB+colorDim] = temp;
			}
			offsetA += 4;
			offsetB -= 4;
		}
	}
};

ByteRect.prototype.verifySameSizeAs = function(byteRect){
	if(!byteRect) throw 'Param ByteRect = '+byteRect;
	if(this.height != byteRect.height) throw this.height+' == this.height != byteRect.height == '+byteRect.height;
	if(this.width != byteRect.width) throw this.width+' == this.width != byteRect.width == '+byteRect.width;
};

ByteRect.prototype.loopAve = function(loopSize, firstByteIndex, addByteIndex){
	let sum = 0;
	let i = firstByteIndex;
	for(let a=0; a<loopSize; a++){
		sum += this.bytes[i];
		i += addByteIndex;
	}
	return sum/loopSize;
};

ByteRect.prototype.loopFractionOfBytesThatAreAtLeastVal = function(loopSize, firstByteIndex, addByteIndex, brightnessIsAtLeastThisByteVal){
	let count = 0;
	let i = firstByteIndex;
	for(let a=0; a<loopSize; a++){
		if(brightnessIsAtLeastThisByteVal <= this.bytes[i]) count++;
		i += addByteIndex;
	}
	return count/loopSize;
};

ByteRect.prototype.loopWriteByte = function(loopSize, firstByteIndex, addByteIndex, writeByteVal){
	let i = firstByteIndex;
	for(let a=0; a<loopSize; a++){
		this.bytes[i] = writeByteVal;
		i += addByteIndex;
	}
};

ByteRect.prototype.loopWriteBlack = function(loopSize, firstByteIndex, addByteIndex){
	let i = firstByteIndex;
	for(let a=0; a<loopSize; a++){
		this.bytes[i+RED] = 0;
		this.bytes[i+GREEN] = 0;
		this.bytes[i+BLUE] = 0;
		i += addByteIndex;
	}
};

/** stdDev of looping over bytes (a row or column and colorDim).
optionalAve is from loopAve or as optional param it computes that.
*/
ByteRect.prototype.loopDev = function(loopSize, firstByteIndex, addByteIndex, optionalAve){
	if(optionalAve === undefined) optionalAve = this.loopAve(byteRect, firstByteIndex, addByteIndex);
	let sumOfSquares = 0;
	let i = firstByteIndex;
	for(let a=0; a<loopSize; a++){
		let diff = this.bytes[i]-optionalAve;
		sumOfSquares += diff*diff;
		i += addByteIndex;
	}
	return Math.sqrt(sumOfSquares/loopSize);
};

/** ave brightness of a certain row and [RED, GREEN, BLUE, or ALPHA]. Range 0 to 255. */
ByteRect.prototype.rowAve = function(y, colorDim){
	return this.loopAve(this.width, y*this.width*4+colorDim, 4);
};

/** stdDev of brightness of a certain row and [RED, GREEN, BLUE, or ALPHA]. Range 0 to 255. */
ByteRect.prototype.rowDev = function(y, colorDim, optionalAve){
	return this.loopDev(this.width, y*this.width*4+colorDim, 4, optionalAve);
};

/** ave brightness of a certain column and [RED, GREEN, BLUE, or ALPHA]. Range 0 to 255. */
ByteRect.prototype.colAve = function(x, colorDim){
	return this.loopAve(this.height, x*4+colorDim, this.width*4);
};

/** stdDev of brightness of a certain column and [RED, GREEN, BLUE, or ALPHA]. Range 0 to 255. */
ByteRect.prototype.colDev = function(x, colorDim, optionalAve){
	return this.loopDev(this.height, x*4+colorDim, this.width*4, optionalAve);
};

ByteRect.prototype.setRowAndColordimToByte = function(y, colorDim, byteVal){
	this.loopWriteByte(this.width, y*this.width*4+colorDim, 4, byteVal);
};

ByteRect.prototype.setColAndColordimToByte = function(x, colorDim, byteVal){
	this.loopWriteByte(this.height, x*4+colorDim, this.width*4, byteVal);
};

ByteRect.prototype.rowFractionOfBytesThatAreAtLeastVal = function(y, colorDim, brightnessIsAtLeastThisByteVal){
	return this.loopFractionOfBytesThatAreAtLeastVal(this.width, y*this.width*4+colorDim, 4, brightnessIsAtLeastThisByteVal);
};

ByteRect.prototype.colFractionOfBytesThatAreAtLeastVal = function(x, colorDim, brightnessIsAtLeastThisByteVal){
	return this.loopFractionOfBytesThatAreAtLeastVal(this.height, x*4+colorDim, this.width*4, brightnessIsAtLeastThisByteVal);
};

ByteRect.prototype.setRowToBlack = function(y){
	this.loopWriteBlack(this.width, y*this.width*4, 4);
};

ByteRect.prototype.setColToBlack = function(x){
	this.loopWriteBlack(this.height, x*4, this.width*4);
};

//centerY, centerX, and radius can be scalars. Does bounds checking
var paintDonut = function(byteRect, centerY, centerX, minRadius, maxRadius, redByte, greenByte, blueByte){
	if(minRadius > maxRadius) throw 'minRadius='+minRadius+' maxRadius='+maxRadius;
	var minYI = Math.max(0, Math.min(Math.floor(centerY-maxRadius), byteRect.height-1));
	var maxYI = Math.max(0, Math.min(Math.ceil(centerY+maxRadius), byteRect.height-1));
	var minXI = Math.max(0, Math.min(Math.floor(centerX-maxRadius), byteRect.width-1));
	var maxXI = Math.max(0, Math.min(Math.ceil(centerX+maxRadius), byteRect.width-1));
	var minRadiusSq = minRadius*minRadius;
	var maxRadiusSq = maxRadius*maxRadius;
	for(var y=minYI; y<=maxYI; y++){
		var i = byteRect.index(y, minXI, 0);
		for(var x=minXI; x<=maxXI; x++){
			var dy = y-centerY;
			var dx = x-centerX;
			let sq = dy*dy + dx*dx;
			if((minRadiusSq <= sq) && (sq <= maxRadiusSq)){
				//TODO optimize by skipping parts where this isnt true, in the loop before getting here.
				byteRect.bytes[i+colorDimRed] = redByte;
				byteRect.bytes[i+colorDimGreen] = greenByte;
				byteRect.bytes[i+colorDimBlue] = blueByte;
			}
			i += 4;
		}
	}
};

ByteRect.prototype.paintLineYXYXRGB = function(fromY, fromX, toY, toX, redByte, greenByte, blueByte){
	let diffY = toY-fromY;
	let diffX = toX-fromX;
	let len = Math.hypot(diffY, diffX);
	let numPoints = Math.ceil(len*1.5);
	for(let i=0; i<numPoints; i++){
		//TODO optimize
		let y = Math.round(fromY+diffY*i/numPoints);
		let x = Math.round(fromX+diffX*i/numPoints);
		this.atYXWriteRGB(y, x, redByte, greenByte, blueByte);
	}
};

ByteRect.prototype.paintCircleRadiusYXRGBSafe = function(radius, cy, cx, redByte, greenByte, blueByte){
	let circle = 2*Math.PI;
	let numPoints = Math.ceil(radius*circle*1.5);
	let anglePerPoint = 2*Math.PI/numPoints;
	for(let i=0; i<numPoints; i++){
		let angle = anglePerPoint*i;
		let x = cx+radius*Math.cos(angle);
		let y = cy+radius*Math.sin(angle);
		this.writeSafeRGBA(y, x, redByte, greenByte, blueByte);
	}
};


var bytesToFloats = function(bytes){
	let floats = new Float32Array(bytes.length);
	for(let i=0; i<bytes.length; i++) floats[i] = bytes[i];
	return floats;
};

var floatsToBytes = function(floats){
	let bytes = new Uint8Array(floats.length);
	for(let i=0; i<bytes.length; i++) bytes[i] = floats[i];
	return bytes;
};

var floatsAsMonochromeToPic = function(floats, height, width){
	if(floats.length != height*width) throw 'floats.length='+floats.length+' height='+height+' width='+width+' are diff sizes';
	let ret = new ByteRect(new Uint8Array(floats.length*4), height, width);
	let outb = ret.bytes;
	let j = 0;
	for(let i=0; i<ret.bytes.length; i+=4){
		//let bright = floats[j++];
		let bright = asByte(floats[j++]);
		outb[i+RED] = bright;
		outb[i+GREEN] = bright;
		outb[i+BLUE] = bright;
		outb[i+ALPHA] = 255; //visible
	}
	return ret;
};

var isByteRect = function(b){
	return (b.bytes && b.height && b.width);
};


var floats2dToFloats1d = function(floats2d){
	let size = 0;
	for(let i=0; i<floats2d.length; i++) size += floats2d[i].length;
	let ret = new Float32Array(size);
	let j = 0;
	for(let i=0; i<floats2d.length; i++){
		let innerFloats = floats2d[i];
		for(let k=0; k<innerFloats.length; k++){ //TODO optimize by range copy
			ret[j++] = innerFloats[k];
		}
	}
	return ret;
};

/* This is for learning about quarternions (or logging etc), not efficient number crunching. Wouldnt use an object per number for that. */
var Quarternion = function(r, i, j, k){
	this.r = r;
	this.i = i;
	this.j = j;
	this.k = k;
};

Quarternion.prototype.toString = function(){
	return "(new Quarternion("+this.r+","+this.i+","+this.j+","+this.k+"))";
	//return this.r+"+QI*"+this.i+"+QJ*"+this.j+"+QK*"+this.k;
};

Quarternion.prototype.equals = function(q){
	return (this.r==q.r && this.i==q.i && this.j==q.j && this.k==q.k);
};

Quarternion.prototype.plus = function(q){
	return new Quarternion(this.r+q.r, this.i+q.i, this.j+q.j, this.k+q.k);
};

//https://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/arithmetic/index.htm says
//(a + i b + j c + k d)*(e + i f + j g + k h) = a*e - b*f - c*g- d*h + i (b*e + a*f + c*h - d*g) + j (a*g - b*h + c*e + d*f) + k (a*h + b*g - c*f + d*e)
Quarternion.prototype.mul = function(q){
	let a = this.r;
	let b = this.i;
	let c = this.j;
	let d = this.k;
	let e = q.r;
	let f = q.i;
	let g = q.j;
	let h = q.k;
	return new Quarternion(
		a*e - b*f - c*g- d*h,
		b*e + a*f + c*h - d*g,
		a*g - b*h + c*e + d*f,
		a*h + b*g - c*f + d*e
	);
};


/** https://en.wikipedia.org/wiki/Quaternion says "every nonzero quaternion has an inverse with respect to the Hamilton product" */
Quarternion.prototype.inverse = function(){
	let div = this.r*this.r + this.i*this.i + this.j*this.j + this.k*this.k;
	if(div == 0) throw 'FIXME if div is 0, use Infinity, -Infinity, NaN, or throw? this='+this;
	return new Quarternion(
		this.r/div,
		-this.i/div,
		-this.j/div,
		-this.k/div
	);
};

const QR = new Quarternion(1, 0, 0, 0);

const QI = new Quarternion(0, 1, 0, 0);

const QJ = new Quarternion(0, 0, 1, 0);

const QK = new Quarternion(0, 0, 0, 1);


const maxPossibleColorDistanceSquared = 3*255*255;

//distance between observed red and redness of voxel (r g b in param) moving near it. sqrt of sum of square diffs.
//Since colors range 0..255, distance ranges 0..sqrt(3*255^2)=441.6729559300637.
const maxPossibleColorDistance = Math.sqrt(maxPossibleColorDistanceSquared);

//get y x velocity, given a certain color (of a voxel there), at an x, y, and rectangle_or_2d_bellcurve, to accel that voxel, and how to change its color
//View it as a 5d vector field of x y red green blue, or maybe 6d if you count the size of rectangle_or_2d_bellcurve but since it doesnt
//give a derivative for the size, maybe shouldnt include that. Also z dim (into or out of the screen) is a dim in other parts of the system but not here.
//TODO find a more efficient way to do this than 1 at a time and returning a new [5 numbers] each time, but this is early experiments.
//size param is normally 1-20 and must always be at least 1. size is 2*radius.
//r g b are 0..255. Derivatives returned are floats.
//0 <= y < byteRect.height.
//0 <= x < byteRect.width.
//OLD: If isPaintOver, then paints over the area observed, to show what its observing and the weights there.
//byteRectOutOrNull is null to not paint anything, or nonnull to paint at byteRectOutOrNull
ByteRect.prototype.yxrgbDerivs = function(size, y, x, r, g, b, byteRectOutOrNull){
	//FIXME if size is even, or x and y are not integers, then can pull a direction cuz of roundoff?
	//Or will it avoid that to compare weightedSum of x and y to the average x and y of the pixels measured
	//instead of comparing it to the param x and y?

	if(size < 1) throw 'size='+size;
	let radius = size/2;
	let radiusSquared = radius*radius;
	let xStart = Math.max(0,Math.round(x-size/2));
	let xEndExcl = Math.min(xStart+size,this.width);
	let yStart = Math.max(0,Math.round(y-size/2));
	let yEndExcl = Math.min(yStart+size,this.height);
	let numPixels = (yEndExcl-yStart)*(xEndExcl-xStart);
	//do it the simple square way for now, but bellcurve is better todo that
	let dy = 0;
	let dx = 0;
	let dr = 0;
	let dg = 0;
	let db = 0;
	let sumR = 0, sumG = 0, sumB = 0;
	let bytes = this.bytes;
	//use Math.pow (such as of 2 for leastSquares, or 2.1 for a little stronger matching (ignore more colors that differ slightly), 1 for linear, etc.
	let colorMatchExponent = 2;
	//let colorMatchExponent = 1;
	let sumYByWeight = 0;
	let sumXByWeight = 0;
	let sumWeight = 0;
	let aveYUnweighted = (yStart+(yEndExcl-1))/2;
	let aveXUnweighted = (xStart+(xEndExcl-1))/2;
	let paintBytes = (byteRectOutOrNull ? byteRectOutOrNull.bytes : null);
	for(let yy=yStart; yy<yEndExcl; yy++){
		for(let xx=xStart; xx<xEndExcl; xx++){
			let ptr = (yy*this.width+xx)*4; //pixel starts at which byte (and is 4 bytes)
			let rr = bytes[ptr+RED];
			let gg = bytes[ptr+GREEN];
			let bb = bytes[ptr+BLUE];
			sumR += rr;
			sumG += gg;
			sumB += bb;
			let colorDistanceFraction = Math.hypot(rr-r, gg-g, bb-b)/maxPossibleColorDistance; //TODO optimize
			//weightedSum of colors accelerates voxel in x and y dims toward colors similar to its current color,
			//and TODO its current color is accelerated (or just decay toward?) toward whatever colors its near.
			let weight = Math.pow(1-colorDistanceFraction,colorMatchExponent); //TODO optimize
			//let distanceXYFromCenterPointAskedAbout = Math.hypot(yy-aveYUnweighted, xx-aveXUnweighted);
			let diffY = yy-aveYUnweighted;
			let diffX = xx-aveXUnweighted;
			if(diffY*diffY + diffX*diffX <= radiusSquared){ //only whats inside the circle within radius of param 2d point, to be angle invariant.
			
				//let distanceSquaredXYFromCenterPointAskedAbout = diffY*diffY + diffX*diffX;
				//let weightMulForShapeOfMovingWindow = ((distanceSquaredXYFromCenterPointAskedAbout <= radiusSquared) ? 1 : 0);
				//weight *= weightMulForShapeOfMovingWindow;
			
			
				sumYByWeight += yy*weight;
				sumXByWeight += xx*weight;
				sumWeight += weight;
				if(paintBytes){
					//let mult = weight; //weight ranges 0 to 1 (or 0 to 1/sqrt(3) if norming color to sum to constant?)
					//let mult = weight*2; //FIXME
					/* //paint weight as grayscale
					paintBytes[ptr+RED] = weight*255;
					paintBytes[ptr+GREEN] = weight*255;
					paintBytes[ptr+BLUE] = weight*255;
					*/
					//paint weight as varying brightness of the color of the voxel
					paintBytes[ptr+RED] = weight*r;
					paintBytes[ptr+GREEN] = weight*g;
					paintBytes[ptr+BLUE] = weight*b;
				}
			}
		}
	}
	if(sumWeight > 0){
	//if(sumWeight > 10){ //FIXME
		let aveYByWeight = sumYByWeight/sumWeight;
		let aveXByWeight = sumXByWeight/sumWeight;
		dy += (aveYByWeight-aveYUnweighted)/size;
		dx += (aveXByWeight-aveXUnweighted)/size;
		let aveR = sumR/numPixels;
		let aveG = sumG/numPixels;
		let aveB = sumB/numPixels;
		dr += aveR-r; //diff of average color of the square of pixels observed and the param voxel color
		dg += aveG-g;
		db += aveB-b;
	}else{
		//console.log("yxrgbDerivs.sumWeight="+sumWeight);
	}
	return Float32Array.of(dy, dx, dr, dg, db);
};

var dom = (id)=>document.getElementById(id);

var prevTime = time();

var webcamFrames = 0;
var webcamFpsObserved = 1;

//targetSum is target red+green+blue to norm each pixel to. returns new ByteRect.
var normPixelsAllToSameBrightness = function(byteRect, targetSum){
	let inb = byteRect.bytes;
	let ret = new ByteRect(new Uint8Array(inb.length), byteRect.height, byteRect.width);
	let retb = ret.bytes;
	for(let i=0; i<inb.length; i+=4){
		let sum = inb[i+RED]+inb[i+GREEN]+inb[i+BLUE];
		if(sum == 0){
			let bright = targetSum/3;
			retb[i+RED] = bright;
			retb[i+GREEN] = bright;
			retb[i+BLUE] = bright;
		}else{
			let mul = targetSum/sum;
			retb[i+RED] = inb[i+RED]*mul;
			retb[i+GREEN] = inb[i+GREEN]*mul;
			retb[i+BLUE] = inb[i+BLUE]*mul;
		}
		retb[i+ALPHA] = 255; //visible
		//FIXME? floor ceil round range as its probably a Uint8ClampedArray?
	}
	return ret;
};

var take_snapshot = function(sim){
	// play sound effect
	//shutter.play();

	// take snapshot and get image data
	Webcam.snap(
		function(data_uri){
			let video = Webcam.video;
			if(video !== undefined){
				canvasInContext.drawImage(video, 0, 0, canvasIn.width, canvasIn.height);
				updateCanvasObjects();
				let now = time();
				let dt = now-prevTime;
				prevTime = now

				webcamFrames++;
				webcamFpsObserved = webcamFpsObserved*(1-dt) + 1; //TODO adjustable decay rate
				let fpsDisplay = (57 < webcamFpsObserved && webcamFpsObserved < 63) ? 'around 60 where it should be' : ''+webcamFpsObserved;
				dom('fpsLabel').innerHTML = 'fps='+fpsDisplay;

				byteRectIn.flipHorizontal(); //part of preprocessing
				//TODO move color norming here, so sim.io doesnt modify byteRectIn. part of preprocessing.
				if(sim.paintTestObjectsAsInput){
					//FIXME also paint them onto output (in sim.io(...) if !sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack ?
					paintTestsOntoByteRectIn(now,byteRectIn);
				}
				let pic = byteRectIn;
				let h = byteRectIn.height;
				let w = byteRectIn.width;
				if(sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU){
					//pic = normPixelsAllToSameBrightness(pic, 255);
					pic = normPixelsAllToSameBrightness(pic, 500);
				}
				
				if(sim.isFindEdgesAndKeepTheirColor){
					sim.findEdgesAndKeepTheirColor_modifyByterect(pic, sim.minColorDiffFractionToBeADot);
				}
				
				if(sim.isFindDots){
					pic = sim.findDots(pic, sim.findDots_maxDotSize_param);
				}
				
				
				
				if(sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU){
					pic = sim.doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls(pic);
				}
				if(sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG){
					let allowBytesIntoGpu = sim.allowBytesIntoGpuElseCopyBytesToFloats_thisMayBeBuggy;
					pic = sim.doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu(pic, true, allowBytesIntoGpu);
					//TODO optimize: let pic be monochrome Float32Array here (gpujs outputs that)
					//so preprocessPicToRemoveHorizontalAndVerticalLines_usingGpu can take Float32Array as input,
					//skipping a step of copying each float into 3 equal bytes then back to float.
				}
				
				if(sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic){
					//these lines seem to be caused by camera norming color in a grid of many small rectangles, and the
					//code to norm colors is so good that it finds them which are otherwise not much visible to the naked eye.
					sim.preprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic(
						pic, //modifies pic
						sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright,
						sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction
					);
				}
				if(sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_usingGpu){
					pic = sim.preprocessPicToRemoveHorizontalAndVerticalLines_usingGpu(
						pic, //this can be ByteRect or  (TODO?)[Float32Array as monochrome]
						h,
						w,
						sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright,
						sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction,
						true //isModifyByteRectIn
						//true //true return ByteRect (else Float32Array)
					);
				}
				
				if(pic != byteRectIn){
					copyBytes(pic.bytes, byteRectIn.bytes);
					//TODO optimize: by not creating another ByteRect?
					//TODO optimize: is bytaeRectIn from canvasIn? Does it need to be? Or just call sim.io(dt, pic, byteRectOut) to skip this copyBytes?
				}
				sim.io(dt, byteRectIn, byteRectOut);
				//canvasInContext.putImageData(canvasInImageData, 0, 0);
				canvasOutContext.putImageData(canvasOutImageData, 0, 0);
				//if((webcamFrames%10)==0) console.log("webcamFpsObserved="+webcamFpsObserved+"    frames="+webcamFrames+" time="+now);
			}
			// display results in page
			//document.getElementById('results').innerHTML =  '<img src="'+data_uri+'"/>';
		}
	);
};

var rrr=0;

var between = (min, val, max)=>Math.max(min,Math.min(val,max));

var betweenInt = (min, val, max)=>Math.round(Math.max(min,Math.min(val,max)));

var asByte = (x)=>Math.max(0,Math.min(Math.floor(x),255));

var warnIfStrangeDt = function(dt){
	//a good dt is .02 for 50 fps, or .01 is better, but anything less than .01 wont be much noticable improvement in graphics,
	//but it might improve the convergence of the physics energy equations
	//(springs, color matching, etc, all part of a single energy equation, TODO)
	//to run multiple physics/energy/puzzleSolving cycles per display/webcam cycle.
	if((dt <= 0) || (dt > .2)) console.log('dt='+dt);
};

var rand = function(min,max){
	return min+(max-min)*Math.random();
};

//0 to maxExcl-1, if 0<=maxExcl<approx_2pow53minusALittleForRoundoffSoMaybe2pow50 after that doubles cant represent all possible integers.
var randInt = (maxExcl)=>Math.floor(Math.random() * maxExcl);

/*var Slidebar = function(){
	this.getFraction = 
	<input type="range" id="vol" min="0" max="1000000" value="777777" oninput="console.log(this.valueAsNumber/1000000);">
};*/

//0..255
var randByte = ()=>Math.floor(Math.random()*256);

var onceRandomBytes = [];
var testPointEnabled = [];
for(let i=0; i<30000; i++){
	onceRandomBytes.push(randByte());
	//onceRandomBytes.push(Math.floor(Math.random()*256));
	testPointEnabled.push(true);
}

var paintTestsOntoByteRectIn = function(now, byteRect){
	let circleRadius = 15;
	let which_onceRandomBytes = 0;
	let isDisplaying = true;
	let numTestPoints = 70;
	let freq = .05; //turns of this test object per second
	/*if(Math.random()<.15){
		for(let j=0; j<numTestPoints; j++){
			if(Math.random() < .3){
				//randomly display or not display some parts of this object, to test if the voxels move there anyways cuz of springs
				isDisplaying = !isDisplaying;
			}
			testPointEnabled[j] = isDisplaying;
		}
	}*/
	for(let i=0; i<numTestPoints; i++){
		
		if(testPointEnabled[i]){
			let a = 2*Math.PI*(i/numTestPoints+now*freq);
			let yFraction = .5+.3*Math.sin(a);
			let xFraction = .5+.3*Math.cos(a);
			let red = onceRandomBytes[which_onceRandomBytes];
			let green = onceRandomBytes[which_onceRandomBytes+1];
			let blue = onceRandomBytes[which_onceRandomBytes+2];
			paintDonut(
				byteRect,
				byteRect.height*yFraction,
				byteRect.width*xFraction,
				0, //inner radius
				circleRadius,
				red,
				green,
				blue
			);
		}
		which_onceRandomBytes += 3;
	}
};

//These epsilons are meant to be multiplied by the number they're used with, like if distance between 2 voxels is 507.3
//and you want potentialEnergy derivative there, use 507.3 and 507.3*(1+EPSILON) and divide that difference by EPSILON,
//else you will (more often than not, probably) lose more precision than the EPSILON was designed for, compared to 507.3+EPSILON.
//
const EPSILON_FOR_FLOAT = Math.pow(.5,13); //float is exact for all integers in plus/minus 2^24. Browser GPU.js uses floats, unknown if its IEEE754 deterministic.
const EPSILON_FOR_DOUBLE = Math.pow(.5,27); //double is exact for all integers in plus/minus 2^53. Unknown if browser javascript is IEEE754 deterministic.
const EPSILON = EPSILON_FOR_FLOAT; //even though using doubles 2021-7-25, planning to use GPU.js which creates Float32Arrays.

/** 4x4 identityFunc affine transform */
var newIdentAftrans = function(){
	return Float32Array.of(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);
	/*let a = new Float32Array(16);
	a[AXX] = 1;
	a[AYY] = 1;
	a[AZZ] = 1;
	a[ASS] = 1;
	return a;
	*/
};

var newRandAftransNearIdent = function(){
	let a = newIdentAftrans();
	for(let i=0; i<a.length; i++){
		a[i] += .1*(Math.random()*2-1);
	}
	return a;
};

var newRandAftrans = function(){
	let a = new Float32Array(16);
	for(let i=0; i<a.length; i++){
		a[i] = Math.random()*4-2; //-2 to 2. TODO unit bellcurve
	}
	return a;
};

var defaultNumAnglesOfCircle = 100;

var newCirclePixels = function(optionalNumAngles, optionalRedByte, optionalGreenByte, optionalBlueByte, optionalAttention){
	if(!optionalNumAngles) optionalNumAngles = defaultNumAnglesOfCircle;
	verifyNumAngles(optionalNumAngles,true); //true allow odd
	this.numAngles = optionalNumAngles;
	
	if(!optionalRedByte) optionalRedByte = randByte();
	if(!optionalGreenByte) optionalGreenByte = randByte();
	if(!optionalBlueByte) optionalBlueByte = randByte();
	if(!optionalAttention) optionalAttention = 1;
	let a = new Float32Array(optionalNumAngles*VARSPERCIRCLE); //TODO rename VARSPERCIRCLE to mean vars per pixel in a circle
	for(let i=0; i<a.length; i+=VARSPERCIRCLE){
		a[i+CRED] = optionalRedByte;
		a[i+CGREEN] = optionalGreenByte;
		a[i+CBLUE] = optionalBlueByte;
		a[i+CATTEN] = optionalAttention;
	}
	return a;
};

var verifyNumAngles = function(numAngles, optionalAllowOdd){
	if(!optionalAllowOdd) optionalAllowOdd = false; //TODO remove this line? !undefined and !false are both true
	if((numAngles < 8) || (4096 < numAngles)) throw 'numAngles='+numAngles+' is far too small or big';
	if(optionalAllowOdd){
		if(numAngles != Math.floor(numAngles)) throw 'Not integer, numAngles='+numAngles;
	}else{
		if((numAngles&1) != 0) throw 'Not even, numAngles='+numAngles;
	}
};

var verifyAftrans = function(aftrans){
	if(!aftrans) throw 'aftrans='+aftrans;
	//if(!(aftrans.length)) throw 'aftrans.length='+aftrans.length;
	if(aftrans.length != 16) throw 'aftrans.length='+aftrans.length+' but must be 16 cuz 4x4';
};

const emptyArray = new Float32Array(0);

//ab is Float32Array(a*b). bc is Float32Array(b*c). Returns Float32Array(a*c).
//TODO GPU.js if its big, but might want to merge multiple kernels to happen at once for intheory lower lag.
//Theres some func to "combine kernels" in GPU.js.
var matmul = function(ab, bc, a, b, c){
	return matmulCpu(ab, bc, a, b, c);
};

var aftransOfAftrans = function(outerAftrans, innerAftrans){
	//FIXME is this right? Use transpose or not? Swap the order of outer and inner?
	//return matmul(outerAftrans,transpose4x4(innerAftrans),4,4,4);
	return matmul(outerAftrans,innerAftrans,4,4,4);
};

var copyBytes = function(bytesIn, bytesOut){
	for(let i=0; i<bytesOut.length; i++){
		bytesOut[i] = bytesIn[i];
	}
};

/*
//matmul(aftransA,aftransB,4,4,4) them in sequence, or identityFunc if theres none of them
var aftransOfAftrans = function(...aftranses){
	if(aftranses.length == 0) return newIdentAftrans();
	let a = aftranses[0];
	for(let i=1; i<aftranses.length; i++){
		a = matmul(a,aftranses[i],4,4,4);
	}
	return a;
};*/

var matmulCpu = function(ab, bc, aSize, bSize, cSize){
	let ret = new Float32Array(aSize*cSize);
	for(let a=0; a<aSize; a++){
		for(let c=0; c<cSize; c++){
			//TODO this will be most of the GPU code in matmulGpu:
			let sum = 0; //double*double then cast to float differs from [float*float which is intheory what you get in GPU.js. TODO align with lazycl]
			for(let b=0; b<bSize; b++){
				sum += ab[a*bSize+b]*bc[b*cSize+c];
			}
			ret[a*cSize+c] = sum;
		}
	}
	return ret;
};

var matmulGpu = function(ab, bc, a, b, c){
	throw 'TODO';
};

/** TODO just do matmul instead. need way to mark a Float32Array as an array instead of a 1d.
//aftrans is a Float32Array(16). points is a Float32Array(any multiple of 4). Modifies points to transform those.
var aftransPoints = function(aftrans, points){
	let temp = new Float32Array(4);
	for(let p=0; p<points.length; p+=4){
		for(let n=0; n<4; n++){
			for(let m=0; m<4; m++){
			temp[d] 
			FIXME
		}
	}
};
*/



/** OLD, this isnt used anymore, cuz will just use the pixels on ball surface directly
and try 50*100*100=500k rotations to find nearest match, before adjust for sub-pixel accuracy.
<br><br>
a circle of cached (bilinear-interpolated?) pixels viewed at sphere surface points on a Ball,
from a certain center point on its surface and a certain radius (surface distance? or from center of circle in 3d?),
which is a cache of the rectangle of pixels (baxels) wrapped around the sphere surface.
The circle has CATTEN (attention at that pixel in circle 1d coordinates) and has low CATTEN for things at a sharp angle
viewed near edges of sphere they're so thin cant see much there, while sideways along that same part of circle can be much higher CATTEN
cuz its how much distance on 2d screen vs distance in circle coordinates.
*/
var Circle = function(numAngles, optionalAftrans, optionalPixels){
	this.numAngles = numAngles;

	if(!optionalAftrans) optionalAftrans = newIdentAftrans();
	this.aftrans = optionalAftrans;
	
	if(!optionalPixels) optionalPixels = newCirclePixels(numAngles);
	this.pixels = optionalPixels;

	//OLD...
	//FIXME what datastruct for CIRCLE? Its an array of C vars but also an aftrans (4x4? 4x3? rel to the ball or absolute?) Should it be its own class?
	//Or should it all go in 1 Float32Array for the C vars and 1 Float32Array for the aftranses?
	//How will that go into GPU.js, when calling a func to find the aftrans that best aligns 2 Balls?
	//The CIRCLES  are stored in Ball, and Balls stored in Sim, so the circles and balls can be displayed on screen for debugging.
	//If I put it in separate Circle objects, with a Float32Array(16) (the 4x4 aftrans) and a Float32Array(VARSPERC..something * circlesizesomething)
	//could be put in [aftranses] and [pixelsEtc] as 2 of 2d arrays. GPU.js can do 2d arrays. Yes do that.
	//...  this.circles = 
	//TODO
};

//Circle doesnt have childs, but here for consistency of the this.childs[whichChild].aftrans being relative to this.aftrans.
Circle.prototype.childs = emptyArray;

var transpose4x4 = function(aftrans){
	let a = new Float32Array(16);
	for(let i=0; i<4; i++){
		for(let j=0; j<4; j++){
			a[4*i+j] = aftrans[4*j+i];
		}
	}
	return a;
};


/** matrix inverse for Float32Array(16) as 4x4. Throws if matrix is not invertible (happens when it has 0s in certain places, etc) Example:
<br><br>
Float32Array(16) [40, -40, 0, 0, 40, 80, 0, 0, 50, -40, 10, 0, 190, 200, 0, 0]
for(i in af) if(af[i] == 0) af[i] = 1
<br><br>
1
inverse4x4(af)
Float32Array(16) [0.006666666828095913, -0.013333333656191826, -0, 0.006666666828095913, -0.008333333767950535, 0.008333333767950535, -0, -0, -0.11851851642131805, 0.014814814552664757, 0.1111111119389534, -0.007407407276332378, 0.5185185074806213, 0.8518518805503845, -0.1111111119389534, -0.25925925374031067]
aftransOfAftrans(inverse4x4(af),af)
Float32Array(16) [1, 0, 0, 0, 0, 1, 0, 0, 1.3969838619232178e-7, -1.1175870895385742e-7, 1, 2.7939677238464355e-9, 0.0000017136335372924805, 0.000003874301910400391, 1.4901161193847656e-8, 1]
<br><br>
af
Float32Array(16) [38.17185974121094, -37.34263610839844, 0.567450225353241, 0.9653493165969849, 44.762725830078125, 75.62342834472656, 2.032400608062744, 1.092972755432129, 47.32026290893555, -49.86602020263672, 9.876603126525879, 0.9346176981925964, 314.396484375, 233.5746307373047, 4.626655578613281, 4.095148086547852]
aftransOfAftrans(af,inverse4x4(af))
Float32Array(16) [1, -2.8939762586333018e-8, -6.901840432504969e-9, 6.330946877852739e-9, 6.891576731504756e-8, 0.9999999403953552, -4.097648442780155e-9, 7.388507139438616e-9, 2.5632354905269494e-8, -1.2609987720679783e-8, 1, 7.609613383863234e-9, 2.213476051338148e-7, -1.2695329587586457e-7, -1.5567275468697517e-8, 1.0000001192092896]
aftransOfAftrans(inverse4x4(af),af)
Float32Array(16) [1.0000001192092896, 6.570027011321145e-8, 1.0449441312232466e-9, 1.00316499551667e-9, 1.7116050798904325e-8, 1, 6.754415915466438e-10, 4.2082873297211165e-10, 2.8648202032854897e-8, 9.683519408554275e-8, 1, 1.570354069002633e-9, -0.0000015082332538440824, -0.000004397804332256783, -1.0071694589441904e-7, 1]
<br><br>
got this from asking wolframalpha "inverse {{a, b, c, d}, {e, f, g, h}, {i, j, k, l}, {m, n, o, p}}", and it responded with the fact of math in this code.
https://www.wolframalpha.com/input/?i=inverse+%7B%7Ba%2C+b%2C+c%2C+d%7D%2C+%7Be%2C+f%2C+g%2C+h%7D%2C+%7Bi%2C+j%2C+k%2C+l%7D%2C+%7Bm%2C+n%2C+o%2C+p%7D%7D
*/
var inverse4x4 = function(aftrans){
	let a = aftrans[0];
	let b = aftrans[1];
	let c = aftrans[2];
	let d = aftrans[3];
	let e = aftrans[4];
	let f = aftrans[5];
	let g = aftrans[6];
	let h = aftrans[7];
	let i = aftrans[8];
	let j = aftrans[9];
	let k = aftrans[10];
	let l = aftrans[11];
	let m = aftrans[12];
	let n = aftrans[13];
	let o = aftrans[14];
	let p = aftrans[15];
	let W = a*f*k*p - a*f*l*o - a*g*j*p + a*g*l*n + a*h*j*o - a*h*k*n - b*e*k*p + b*e*l*o + b*g*i*p - b*g*l*m - b*h*i*o + b*h*k*m;
	let X = c*(e*j*p - e*l*n - f*i*p + f*l*m + h*i*n - h*j*m);
	let Y = d*(- e*j*o + e*k*n + f*i*o - f*k*m - g*i*n + g*j*m);
	let mul = 1/(W + X + Y);
	if(mul == Infinity) throw 'Not invertible matrix';
	return Float32Array.of(
		(f*k*p - f*l*o - g*j*p + g*l*n + h*j*o - h*k*n)*mul,
		( - b*k*p + b*l*o + c*j*p - c*l*n - d*j*o + d*k*n)*mul,
		(b*g*p - b*h*o - c*f*p + c*h*n + d*f*o - d*g*n)*mul,
		( - b*g*l + b*h*k + c*f*l - c*h*j - d*f*k + d*g*j)*mul,
		( - e*k*p + e*l*o + g*i*p - g*l*m - h*i*o + h*k*m)*mul,
		(a*k*p - a*l*o - c*i*p + c*l*m + d*i*o - d*k*m)*mul,
		( - a*g*p + a*h*o + c*e*p - c*h*m - d*e*o + d*g*m)*mul,
		(a*g*l - a*h*k - c*e*l + c*h*i + d*e*k - d*g*i)*mul,
		(e*j*p - e*l*n - f*i*p + f*l*m + h*i*n - h*j*m)*mul,
		( - a*j*p + a*l*n + b*i*p - b*l*m - d*i*n + d*j*m)*mul,
		(a*f*p - a*h*n - b*e*p + b*h*m + d*e*n - d*f*m)*mul,
		( - a*f*l + a*h*j + b*e*l - b*h*i - d*e*j + d*f*i)*mul,
		( - e*j*o + e*k*n + f*i*o - f*k*m - g*i*n + g*j*m)*mul,
		(a*j*o - a*k*n - b*i*o + b*k*m + c*i*n - c*j*m)*mul,
		( - a*f*o + a*g*n + b*e*o - b*g*m - c*e*n + c*f*m)*mul,
		(a*f*k - a*g*j - b*e*k + b*g*i + c*e*j - c*f*i)*mul
	);
};

/** given a Float32Array(prevCols*prevRows) viewed as [prevCols][prevRows], returns a new Float32Array to be viewed as [prevRows][prevCols]. */
var transpose = function(matrix, prevCols, prevRows){
	if(matrix.length != (prevCols*prevRows)) throw 'matrix.length='+matrix.length+' prevCols='+prevCols+' prevRows='+prevRows;
	let ret = new Float32Array(matrix.length);
	for(let pc=0; pc<prevCols; pc++){
		for(let pr=0; pr<prevRows; pr++){
			ret[pr*prevCols+pc] = matrix[pc*prevRows+pr];
		}
	}
	return ret;
};

//A point thats just an aftrans, displayed as 3 lines joined one one side for the 3 axis, red green and blue,
//and it can have any kind of child objects.
var AfPoint = function(optionalAftrans){
	if(!optionalAftrans) optionalAftrans = newIdentAftrans();
	this.aftrans = optionalAftrans;
	this.childs = [];
};

AfPoint.prototype.paint = function(byteRect, aftrans){
	//let displayIdent = newIdentAftrans(); //todo optimize by not creating this ever time or not even transforming it. Is it just aftrans?
	//let d = aftransOfAftrans(aftrans,displayIdent); //paint these 3 lines, and display childs in those coordinates
	//FIXME is this the wrong order of using the 4x4 dims, swap the inner/outer 4?
	let centerXFloat = aftrans[ASX];
	let centerYFloat = aftrans[ASY];
	let centerX = Math.floor(centerXFloat);
	let centerY = Math.floor(centerYFloat);
	let redX = Math.floor(centerXFloat+aftrans[AXX]);
	let redY = Math.floor(centerYFloat+aftrans[AXY]);
	let greenX = Math.floor(centerXFloat+aftrans[AYX]);
	let greenY = Math.floor(centerYFloat+aftrans[AYY]);
	let blueX = Math.floor(centerXFloat+aftrans[AZX]);
	let blueY = Math.floor(centerYFloat+aftrans[AZY]);
	byteRect.paintLineYXYXRGB(centerY, centerX, redY, redX, 255, 0, 0);
	byteRect.paintLineYXYXRGB(centerY, centerX, greenY, greenX, 0, 255, 0);
	byteRect.paintLineYXYXRGB(centerY, centerX, blueY, blueX, 0, 0, 255);
	for(let i in this.childs){
		let child = this.childs[i];
		let childAftrans = aftransOfAftrans(aftrans, child.aftrans);
		child.paint(byteRect, childAftrans);
	}
};

//Example: tennis ball with random curved lines drawn on it with pens andOr markers of various color(s),
//used as a 6 dimensional joystick. Example: 20 of these, 2 in hands of each of 10 people, all playing a game together in front of 1 webcam.
//numAngles is the distance around its equator, and from one pole to the other is numAngles/2, so it must be even.
//Recommended range for numAngles is 30-300.
var Ball = function(numAngles){
	verifyNumAngles(numAngles,false); //false, dont allow odd
	
	this._testIsInSetBaxels = false;
	
	//TODO rename numAngles to numEquatorAngles, cuz theres numPoleAngles func.
	this.numAngles = numAngles; //2*pi radians around equator in polar coordinates
	//this.halfAngles = numAngles/2; //pi radians between poles in polar coordinates
	this.baxels = new Float32Array(this.numAngles*this.numAngles/2*VARSPERBAXEL); //FIXME fill these. FIXME if numPoleAngles() is not numAngles/2.
	
	//put radius in here. TODO choose between radius being in the x y z vs in the fourth dim of 4x4 aftrans.
	this.aftrans = newIdentAftrans();
	
	//as of 2021-8 these are all Circle objects, but in general the childs field of an object in 3d can be any objects,
	//and this.childs[whichChild].aftrans is relative to this.aftrans.
	this.childs = [];
	
	this.randomizeColors();
	
	//TODO do circles (C* vars) go here or are they just temporary to align 2 balls to eachother? Each circle needs baxels and a 3x4 aftrans.

	/*TODO m*n ByteRect or Float32Array for pixel colors etc of ceil(radius*pi)*ceil(radius*2*pi) floats (scale radius first)
		that wraps around sphere in polar coordinates. Costs pi/2-1 = 57% more array size than the sphere surface itself,
		which is not too wasteful for the optimization of it being in a regular grid.
		Circles on the sphere surface are (todo) bilinear interpolated on that, keeping red green and blue,
		and compared between 2 spheres, 1 here and 1 (bent using known centerX centerY and radius of ball (find the yellow circles) from webcam.
	*/
	//throw 'TODO';
};

Ball.prototype.numBaxels = function(){
	return this.numAngles*this.numPoleAngles();
};

Ball.prototype.numPoleAngles = function(){
	return this.numAngles/2;
};

Ball.prototype.randomizeColors = function(){
	for(let i=0; i<this.baxels.length; i+=VARSPERBAXEL){
		this.baxels[i+BRED] = randByte();
		this.baxels[i+BGREEN] = randByte();
		this.baxels[i+BBLUE] = randByte();;
	}
};

/** x where Math.hypot(x,y,z)==1 except roundoff. This is one of the 3 partial inverses of xyzToBaxelIndexIgnoringAftrans(x,y,z). *
Ball.prototype.normXOfBaxelIndex function(baxelIndex){
};
*/

/** returns [normX, normY, normZ] where Math.hypot(normX,normY,normZ)==1 except roundoff */
Ball.prototype.normXYZOfBaxelIndex = function(baxelIndex){
	//FIXME test this is inverse (except roundoff) of xyzToBaxelIndexIgnoringAftrans.
	let poleAngles = this.numPoleAngles();
	let picX = baxelIndex%this.numAngles; //rectangle pic (numAngles * numPoleAngles) wrapped around sphere.
	let picY = (baxelIndex-picX)/this.numAngles;
	let equatorAngle = twoPi*picX/this.numAngles; //0(inclusive)..2*pi(exclusive)
	let poleAngle = Math.PI*picY/this.numPoleAngles(); //0(inclusive)..pi(exclusive)
	let z = Math.cos(poleAngle); //FIXME negative of some of those? swap sin/cos?
	let otherThanZ = Math.sqrt(1-z*z);
	let x = otherThanZ*Math.cos(equatorAngle);
	let y = otherThanZ*Math.sin(equatorAngle);
	return [x,y,z];
};

/** func(prevVal,x,y,z,baxelDim)-&gt;nextVal, where Math.hypot(x,y,z)==1 except roundoff, and baxelDim is BRED BGREEN BBLUE and other B* vars.
To do nothing, func returns prevVal, or similar to change just some parts.
*/
Ball.prototype.setBaxels = function(func){
	if(this._testIsInSetBaxels) throw 'already in setBaxels';
	try{
		this._testIsInSetBaxels = true;
		let numBaxels = this.numBaxels();
		//for(let i=0; i<this.baxels.length; i+=VARSPERBAXEL){
		for(let b=0; b<numBaxels; b++){
			let i = b*VARSPERBAXEL;
			let normXYZ = this.normXYZOfBaxelIndex(b);
			for(let baxelVar=0; baxelVar<VARSPERBAXEL; baxelVar++){ //Examples: BRED BGREEN BBLUE BLASTWEBCAM
				this.baxels[i+baxelVar] = func(this.baxels[i+baxelVar], normXYZ[0], normXYZ[1], normXYZ[2], baxelVar);
			}
		}
	}finally{
		this._testIsInSetBaxels = false;
	}
};

const twoPi = 2*Math.PI;

//ball.baxels[ball.baxelIndexIgnoringAftrans(...)*VARSPERBAXEL+whichBaxelVar], of the closest baxel to the point,
//where a line from ball center to that point intersects ball surface.
//TODO bilinear interpolation, so would need 4 adjacent baxels in a 2x2 in the rectangle of baxels wrapped around sphere.
//The rectangle (numAngles around equator * (numAngles/2 between the poles)) is in polar coordinates.
//This is a slow way to access surface contents of Ball. Its faster to loop over equator and pole angles (TODO aftrans, call sine, quarternion, or what to do in loop?).
Ball.prototype.xyzToBaxelIndexIgnoringAftrans = function(x, y, z){
	let len = Math.hypot(x,y,z);
	if(len == 0) return 0;
	//TODO x should be horizontal on screen, y vertical, and z into/outOf screen.
	x /= len; //become unit vec. FIXME what if roundoff lets it be slightly outside range -1 to 1 so Math.asin/acos breaks?
	y /= len;
	z /= len;
	let equatorAngle = Math.acos(x);
	if(y < 0) equatorAngle = twoPi-equatorAngle; //range 0 to 2pi. FIXME?
	let poleAngle = Math.acos(z); //range 0 to pi. FIXME?
	let equatorIndex = Math.floor(equatorAngle/twoPi*this.numAngles);
	let poleAngles = this.numPoleAngles();
	let poleIndex = Math.floor(poleAngle/Math.PI*poleAngles);
	return between(0, equatorIndex*poleAngles+poleIndex, this.numBaxels()-1);
};

//x y z and whichBaxelVar -> value of that var, or if optionalValue!==undefined then sets value there. Either way returns value.
//This is a slow way to access surface contents of Ball. Its faster to loop over equator and pole angles (TODO aftrans, call sine, quarternion, or what to do in loop?).
Ball.prototype.xyzvIgnoringAftrans = function(x, y, z, whichBaxelVar, optionalValue){
	let index = this.xyzToBaxelIndexIgnoringAftrans(x,y,z)*VARSPERBAXEL+whichBaxelVar;
	if(optionalValue !== undefined){ //write
		this.baxels[index] = optionalValue;
		return optionalValue;
	}else{ //read
		return this.baxels[index];
	}
};

/*
//aftrans can be any FloatBuffer(16), such as aftrans called on aftrans for objects inside objects. See .childs and .aftrans and .paint.
Ball.prototype.paintSlow = function(byteRect, aftrans){
	
	TODO
};
*/

let aftransStr = function(aftrans){
	return 'Float32Array.of('+aftrans[0]+', '+aftrans[1]+', '+aftrans[2]+', '+aftrans[3]+', '
		+aftrans[4]+', '+aftrans[5]+', '+aftrans[6]+', '+aftrans[7]+', '
		+aftrans[8]+', '+aftrans[9]+', '+aftrans[10]+', '+aftrans[11]+', '
		+aftrans[12]+', '+aftrans[13]+', '+aftrans[14]+', '+aftrans[15]+')';
};


/*Ball.prototype.copyFromByterect = function(byteRect, optionalAftransElseUseMine){
	let aftrans = optionalAftransElseUseMine || this.aftrans; //cuz might be object inside object
	//TODO optimize by only looping over the smallest rectangle the ball fits in on the byterect, instead of the whole byterect. Will be many times faster.
	for(let y=0; y<byteRect.height; y++){
		for(let x=0; x<byteRect.width; x++){
			let rectByteIndex = (y*byteRect.width+x)*4;
			
		}
	}
	
	throw 'TODO';
};

Ball.prototype.copyToByterect = function(byteRect, optionalAftransElseUseMine){
	let aftrans = optionalAftransElseUseMine || this.aftrans; //cuz might be object inside object
	throw 'TODO';
};*/

/** 
*
Ball.prototype.reversePaint = function(byteRect, aftrans){	
};*/


/** aftrans can be any FloatBuffer(16), such as aftrans called on aftrans for objects inside objects.
<br><br>
The optionalIsReversePaint param has to be optional cuz of the API of gameObject.paint(byteRect,aftrans)
in multiple kinds of gameObject (such as Ball and AfPoint).
<br><br>
reversePaint copies from byteRect to ball. forward is from ball to byteRect.
Paints transparent color (each webcam dim is another kind of transparency, like if 5 webcams are seeing the same ball,
the ball has 5 vars for which of them can see each pixel on its surface how much, but as of 2021-9 its just 1 webcam, TODO).
*/
Ball.prototype.paint = function(byteRect, aftrans, optionalIsReversePaint){
	const isReverse = (optionalIsReversePaint ? true : false);
	//const isReverse = ((Math.random()<.5) ? true : false); //FIXME
	//const isReverse = (((time()%.4)<.2) ? true : false); //FIXME
	//const isReverse = false; //FIXME
	//console.log('Ball paint at '+aftransStr(aftrans));
	//let halfangs = this.numAngles/2;
	let halfangs = this.numPoleAngles(); //normally this.numAngles/2, and the other size is this.numAngles (equatorAngles), of 2d pic
	let numPoints = this.numBaxels();
	//put x y z 1 coordinates (or is it 1 x y z? how does opengl order that?) of sphere surface in here,
	//then aftrans them, then paint colors in byteRect there.
	let points = new Float32Array(4*numPoints);
	let p = 0;
	for(let equatorIndex=0; equatorIndex<this.numAngles; equatorIndex++){
		for(let poleIndex=0; poleIndex<halfangs; poleIndex++){
			//https://gamedev.stackexchange.com/questions/72044/why-do-we-use-4x4-matrices-to-transform-things-in-3d
			//and http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/ both say its x y z 1 in opengl.
			let equatorAngle = (equatorIndex+.5)/this.numAngles*twoPi;
			let poleAngleFraction = (poleIndex+.5)/halfangs; //FIXME sometimes I +.5 to round, and sometimes I dont.
			//let poleAngle = (poleAngleFraction*.5-1)*Math.PI;
			//let z = Math.sin(poleAngle);
			let poleAngle = poleAngleFraction*Math.PI;
			//let z = -Math.cos(poleAngle);
			let z = Math.cos(poleAngle);
			//let xyRadius = (1-z*z);
			let xyRadius = Math.sqrt(1-z*z);
			//let len_z_xyRadius = Math.hypot(z, xyRadius);
			let xBeforeMul = Math.cos(equatorAngle);
			let yBeforeMul = Math.sin(equatorAngle);
			//let lenXYBefore = Math.hypot(xBeforeMul, yBeforeMul);
			let x = xyRadius*xBeforeMul;
			let y = xyRadius*yBeforeMul;
			//let len = Math.hypot(x, y, z);
			//if(Math.random() < .0001) console.log(
			//	'ballpaint test len='+len+' x='+x+' y='+y+' z='+z+' poleAngle='+poleAngle+' xyRadius='+xyRadius+' equatorAngle='+equatorAngle+' poleAngleFraction='+poleAngleFraction+' len_z_xyRadius='+len_z_xyRadius+' xBeforeMul='+xBeforeMul+' yBeforeMul='+yBeforeMul+' lenXYBefore='+lenXYBefore);
			points[p++] = x;
			points[p++] = y;
			points[p++] = z; //z. FIXME sin vs cos here?
			points[p++] = 1; //TODO? 0, dont move the unit sphere
			//if(Math.random() < .0001) console.log('Ball.paint x='+x+' y='+y+' z='+z);
		}
	}
	
	//FIXME shouldnt have to transpose the incoming aftrans
	//points = matmul(transpose4x4(aftrans), points, 4, 4, numPoints); //move and rotate the ball. Its nearly in byteRect coordinates, but without a horizon or viewing position.
	
	
	/*
	points = matmul(aftrans, points, 4, 4, numPoints); //move and rotate the ball. Its nearly in byteRect coordinates, but without a horizon or viewing position.
	points = transpose(points, 4, numPoints); //FIXME remove this?
	*/
	
	
	points = matmul(points, aftrans, numPoints, 4, 4);
	
	if(NUMWEBCAMS != 1) throw 'NUMWEBCAMS='+NUMWEBCAMS+' so TODO at every baxel and voxel etc (various kinds of pixels) theres a color dimension per webcam thats how much that webcam can see that pixel, but as of 2021-9 its only 1 webcam.';
	

	p = 0;
	let baxelArrayIndex = 0;
	//for(let poleIndex=0; poleIndex<halfangs; poleIndex++){
		//for(let equatorIndex=0; equatorIndex<this.numAngles; equatorIndex++){
	for(let equatorIndex=0; equatorIndex<this.numAngles; equatorIndex++){
		for(let poleIndex=0; poleIndex<halfangs; poleIndex++){
	
			baxelArrayIndex = (poleIndex*this.numAngles+equatorIndex)*VARSPERBAXEL; //FIXME remove this line, count baxelArrayIndex += 4 instead to optimize.
		
			//TODO optimize by writing byteRect.bytes as array instead of calling writeSafeRGBA
			
			let x = Math.floor(points[p++]);
			let y = Math.floor(points[p++]);
			let z = Math.floor(points[p++]);
			
			//FIXME? use VARSPERBAXEL here? Or what kind of object is p looping thru? x y z 1?
			//p += 2; //ignore z and m (x y z m, renaming s to m)
			p += 1; //ignore z and m (x y z m, renaming s to m)
	
			/*
			let x = Math.floor(points[p++]*70) + 200; //FIXME dont + 200, do that in aftrans. And dont multiply inside the floor(...)
			let y = Math.floor(points[p++]*70) + 200;
			//y *= 200; x *= 200; //FIXME do this in aftrans instead
			let z = Math.floor(points[p++]*10);
			x += z;
			y -= 2*z;
			p++; //ignore scale (x y z scale)
			//p += 2; //ignore z and scale
			*/
			
			let drawPoint = (!sim.hidePointsThatAreBehindOtherPoints || (z < 0)); //FIXME use ball center z
			if(isReverse){ //reverse paint, copy from byteRect to ball.
				let byteRectIndex = byteRect.index(y, x, 0);
				let redByte = 0;
				let greenByte = 0;
				let blueByte = 0;
				let visibleByte = 0; //0 is invisible, that webcam cant see it
				if(drawPoint){
					redByte = byteRect.bytes[byteRectIndex+RED];
					greenByte = byteRect.bytes[byteRectIndex+GREEN];
					blueByte = byteRect.bytes[byteRectIndex+BLUE];
					//FIXME visibleByte should vary depending on angle of ball. Things on a surface you can barely see cuz of angle should
					//be less visible so they have less influence on finding rotation by looking through many possible rotations.
					visibleByte = 255; //255 is visible.
				}
				this.baxels[baxelArrayIndex+BRED] = redByte;
				this.baxels[baxelArrayIndex+BGREEN] = greenByte;
				this.baxels[baxelArrayIndex+BBLUE] = blueByte;
				//FIXME do multiple webcams (each has a different visibility var per baxel), but for now its just the first webcam,
				//and cant just copy the same visibility byte here since they see it at different angles.
				this.baxels[baxelArrayIndex+BFIRSTWEBCAM] = visibleByte;
			}else{ //forward/normal paint, copy from ball to byteRect
				if(drawPoint){
					let redByte = this.baxels[baxelArrayIndex+BRED];
					let greenByte = this.baxels[baxelArrayIndex+BGREEN];
					let blueByte = this.baxels[baxelArrayIndex+BBLUE];
					//if((equatorIndex == 0) && (poleIndex == 0)){ //FIXME remove this test code
					//if(Math.random() < .0001){ //FIXME remove this test code
					//	console.log('Ball.paint x='+x+' y='+y+' redByte='+redByte+' greenByte='+greenByte+' blueByte='+blueByte);
					//}
					byteRect.writeSafeRGBA(y, x, redByte, greenByte, blueByte);
					
					//paint it as 2x2 instead of 1 pixel.
					byteRect.writeSafeRGBA(y, x+1, redByte, greenByte, blueByte);
					byteRect.writeSafeRGBA(y+1, x, redByte, greenByte, blueByte);
					byteRect.writeSafeRGBA(y+1, x+1, redByte, greenByte, blueByte);
					
					
					//byteRect.writeSafeRGBA(y, x, 255, 255, 255); //FIXME use redByte...
				}
			}
			
			//baxelArrayIndex += VARSPERBAXEL;
		}
	}
	
	/*for(let i=0; i<256; i++){ //FIXME remove this test code
		byteRect.writeSafeRGBA(i, i, i, i, 255-i);
	}*/
};
//Ball.prototype.paint = Ball.prototype.paintSlow; //TODO optimize using loop






//Does not modify anything.
//TODO is this nondeterministic, or should that part be in the creation and maybe nonstrictfp updating of Ball.circles of both balls?
//Or should the creation of circles be a separate func, and this func would just call that then call another func to compare the circles?
//
//Return aftrans (4x4 affine transform) that aligns the pixels of this Ball to the param Ball,
//optionally with a given last known or last estimated aftrans, after which it might have moved,
//and optionally with an estimated ave number of turns it might have done (0..1) since then.
//Else check all possible rotations equally often (3 kinds of turning),
//except its randomly sampled rotations (such as 1 million rotations),
//and the number of rotations checked is numCirclesInBallA*numCirclesInBallB*numAnglesSameInEachCircle*fractionOfThoseWhichArentDuplicates,
//and fractionOfThoseWhichArentDuplicates is normally around .95 (in theory, todo verify).
Ball.prototype.aftransBetween = function(otherBall, optionalAftrans, optionalEstimatedTurns){
	if(optionalAftrans){ //randomly sample from rotations near optionalAftrans, how near depending on optionalEstimatedTurns
		if(optionalEstimatedTurns && ((optionalEstimatedTurns < 0) || (1 < optionalEstimatedTurns)))
			throw 'optionalEstimatedTurns='+optionalEstimatedTurns+' but must range 0 to 1';
		verifyAftrans(optionalAftrans);
		throw 'TODO';
	}else{ //randomly sample from all rotations
		throw 'TODO';
	}
};


//Copies this Ball, so its aftrans is similar to an identityMatrix except
//the same size (TODO, just making up a size for now) and position (TODO) as this ball but rotated like identity,
//and it displays nearly the same cuz the spherical image
//is adjusted to be in those coordinates.
//This is "* TODO Ball.prototype func to create Ball.numAngles or poleAngles (numAngles/2) number of Balls whose
//poles are at each of those angles, so if its a 100x50 image on a Ball, then you would either create 50 or 100 Balls
//that are copies of those pixels but rotated. Display these other Balls and move and rotate them using gamepad as a test."
Ball.prototype.copyRotated = function(){
	let ret = new Ball(this.numAngles);
	//ret.aftrans is already newIdentAftrans()
	//Copy this.baxels to ret.baxels but transformed (FIXME or inverse transformed?) by this.aftrans
	
	
	
	let halfangs = this.numPoleAngles(); //normally this.numAngles/2, and the other size is this.numAngles (equatorAngles), of 2d pic
	let numPoints = this.numBaxels();
	//put x y z 1 coordinates (or is it 1 x y z? how does opengl order that?) of sphere surface in here,
	//then aftrans them, then paint colors in byteRect there.
	let points = new Float32Array(4*numPoints);
	let p = 0;
	for(let equatorIndex=0; equatorIndex<this.numAngles; equatorIndex++){
		for(let poleIndex=0; poleIndex<halfangs; poleIndex++){
			//https://gamedev.stackexchange.com/questions/72044/why-do-we-use-4x4-matrices-to-transform-things-in-3d
			//and http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/ both say its x y z 1 in opengl.
			let equatorAngle = (equatorIndex+.5)/this.numAngles*twoPi;
			let poleAngleFraction = (poleIndex+.5)/halfangs; //FIXME sometimes I +.5 to round, and sometimes I dont.
			//let poleAngle = (poleAngleFraction*.5-1)*Math.PI;
			//let z = Math.sin(poleAngle);
			let poleAngle = poleAngleFraction*Math.PI;
			//let z = -Math.cos(poleAngle);
			let z = Math.cos(poleAngle);
			//let xyRadius = (1-z*z);
			let xyRadius = Math.sqrt(1-z*z);
			//let len_z_xyRadius = Math.hypot(z, xyRadius);
			let xBeforeMul = Math.cos(equatorAngle);
			let yBeforeMul = Math.sin(equatorAngle);
			//let lenXYBefore = Math.hypot(xBeforeMul, yBeforeMul);
			let x = xyRadius*xBeforeMul;
			let y = xyRadius*yBeforeMul;
			points[p++] = x;
			points[p++] = y;
			points[p++] = z; //z. FIXME sin vs cos here?
			points[p++] = 1; //TODO? 0, dont move the unit sphere
			//if(Math.random() < .0001) console.log('Ball.paint x='+x+' y='+y+' z='+z);
		}
	}
	
	
	
	//FIXME shouldnt have to transpose the incoming aftrans
	//points = matmul(transpose4x4(aftrans), points, 4, 4, numPoints); //move and rotate the ball. Its nearly in byteRect coordinates, but without a horizon or viewing position.
	points = matmul(this.aftrans, points, 4, 4, numPoints); //move and rotate the ball. Its nearly in byteRect coordinates, but without a horizon or viewing position.
	points = transpose(points, 4, numPoints); //FIXME remove this?
	
	//TODO optimize using quarternions andOr complexnums?
	if(ret.baxels.length != numPoints*VARSPERBAXEL) throw 'sizes not match a';
	if(ret.baxels.length != this.baxels.length) throw 'sizes not match b';
	if(points.length != numPoints*4) throw 'sizes not match c';
	//for(let b=0; b<ret.baxels.length; b+=VARSPERBAXEL){
	for(let b=0; b<numPoints; b++){
		let x = points[b*4+AX];
		let y = points[b*4+AY];
		let z = points[b*4+AZ];
		//xyzToBaxelIndexIgnoringAftrans... FIXME rotate using this.aftrans or is it inverse of that?
		let fromBaxelIndex = this.xyzToBaxelIndexIgnoringAftrans(points[b*4],points[b*4+1],points[b*4+2]);
		for(let c=0; c<VARSPERBAXEL; c++){
			//TODO multiply by VARSPERBAXEL outside this loop?
			//TODO bilinear interpolation for more precision?
			ret.baxels[b*VARSPERBAXEL+c] = this.baxels[fromBaxelIndex*VARSPERBAXEL+c];
		}
	}
	
	let radius = 87; //FIXME
	ret.aftrans[AXX] = ret.aftrans[AYY] = ret.aftrans[AZZ] = radius/Math.sqrt(3);
	ret.aftrans[ASX] = this.aftrans[ASX]; //copy x position
	ret.aftrans[ASY] = this.aftrans[ASY]; //copy y position
	ret.aftrans[ASZ] = this.aftrans[ASZ]; //copy z position
	
	return ret;
};






/** compare red, green, and blue at same indexs in baxels arrays of both balls, weighted by the attention/opacity at webcamIndex *
//Ball.prototype.similarityWithNoRotationOrMovement = function(ball, FIXME which webcam B* var (BFIRSTWEBCAM+webcamIndex) to use as attention/opacity?)){
	let a = this.baxels;
	let b = ball.baxels;
	if(a.length != b.length) throw 'Diff sizes';
	for(let i=0; i<a.length; i+=VARSPERBAXEL){
		
	}
};
*/

//Ball.prototype.compareAtAllEquatorRotations = function(){
//};


/** Returns sqrt of weightedAve squared color diff, so 0 is equal, and 1 is the most different it could be. 
Compare red, green, and blue at same indexs in baxels arrays of both balls, weighted by the attention/opacity at webcamIndex.
BFIRSTWEBCAM <= webcamIndex < BFIRSTWEBCAM+NUMWEBCAMS. Normally webcamIndex==BFIRSTWEBCAM.
Weights should range 0 to 1. TODO verify.
*/
var compare2BallsAtWebcamIndex = function(ballA, ballB, webcamIndex){
	let a = ballA.baxels;
	let b = ballB.baxels;
	if(baxelsA.length != baxelsB.length) throw 'Diff sizes';
	let sumOfWeights = 0;
	let weightedSumOfVals = 0;
	for(let i=0; i<a.length; i+=VARSPERBAXEL){
		let weightA = baxelsA[i+webcamIndex];
		let weightB = baxelsb[i+webcamIndex];
		let weight = weightA*weightB; //TODO should this be sqrt(weightA*weightB) or min(weightA*weightB) etc? sqrt would probably be best but its expensive.
		let redDiff = baxelsB[i+BRED]-baxelsA[i+BRED];
		let greenDiff = baxelsB[i+BGREEN]-baxelsA[i+BGREEN];
		let blueDiff = baxelsB[i+BBLUE]-baxelsA[i+BBLUE];
		
		let colorDiffSquared = redDiff*redDiff + greenDiff*greenDiff + blueDiff*blueDiff;
		
		let colorDiffSquaredAsFraction = colorDiffSquared/maxPossibleColorDistanceSquared;
		
		/*FIXME yxrgbDeriv does it as...
		let colorDistanceFraction = Math.hypot(rr-r, gg-g, bb-b)/maxPossibleColorDistance; //TODO optimize
		Math.pow(1-colorDistanceFraction,colorMatchExponent); //TODO optimize
		...but that might slow this too much since this is computed many more times than yxrgbDeriv,
		or maybe since it will (TODO) be done in GPU.js the sqrt wont be the bottleneck. Try both
		*
		
		let colorSimilarityFraction = 1-colorDiffSquaredAsFraction; //FIXME yxrgbDeriv does it as ()
		*/

		let val = colorDiffSquaredAsFraction;
		sumOfWeights += weight;
		weightedSumOfVals += weight*val;
	}
	if(!sumOfWeights) throw 'sumOfWeights='+sumOfWeights;
	//sqrt of weightedAve of colorDiffSquaredAsFraction. Returns a fraction. 0 is equal. 1 is the most different they could be.
	return Math.sqrt(weightedSumOfVals/sumOfWeights);
};

var copyFloat32Array = function(arr){
	return Float32Array.from(arr);
};

var copyFloat32ArrayFromTo = function(from, to){
	if(from.length != to.length) throw 'Diff sizes';
	for(let i=0; i<from.length; i++) to[i] = from[i]; //TODO optimize by calling Float32Array func to do this
};

/** a dimension on a gamepad, such as right joystick horizontal (-1 to 1) or left analog trigger (0 to 1),
except the part near 0 is ignored and farther away is moved to be the new 0 so it feels smooth,
but with deadzone so if you arent holding it, it doesnt drift a little.
<br><br>
TODO fix this with better statistics, automatic calibration of center position and size of deadzone.
Statistically, theres a small range of possible joystick positions that the joystick will be in that range unusually often,
and those are either as far as it can be pushed in some direction or when person is not touching the joystick.
If, for each dimension separately, take stats in a float[10000], which is 10000 positions between -1 and 1,
and for each, decay toward the fraction of the time the joystick has been below that position (such as between -1 and .312, is the .312 position),
then can get the fraction of the time it has been in any range by subtracting the 2 ends, such as range .029 to .312 (joystick position)
happened float[indexOf(.312)]-float[indexOf(.029)] fraction of the time (which will always range 0 to 1).
The deadzone of the joystick should be a range somewhere near the middle thats a range its at more often than any other range of the same size.
Instead of decay rate (which could use DecayBell.java, todo copy that code here, for faster decay when have less data)...
Instead of that, could just add to stats whenever the joystick has moved in the last t time (such as 1 second).
<br><br>
TODO make auto joystick calibration while playing be a separate js library,
which could lead to nobody ever having to calibrate any joystick again in any system,
and it would increase precision of the joystick by making the deadzone smaller and the deadzone would vary its position instead of just its size.
*/
var controlWithDeadzone = function(name, deadZone){
	let val = control(name);
	if(Math.abs(val) < deadZone){
		return 0;
	}else{
		if(val > 0){
			return val-deadZone; //dont jump, it starts as 0 movement at border of deadzone and gradually more
		}else{
			return val+deadZone;
		}
	}
};

//returns [valA, valB] with circle of deadzone.
//Not jumpy. It doesnt jump from 0 to deadZone at deadZone. There, its 0, and gradually more.
var control2WithDeadzone = function(deadZone, nameA, nameB){
	let valA = control(nameA);
	let valB = control(nameB);
	let len = Math.hypot(valA,valB);
	if(len < deadZone) return [0, 0];
	let newLen = len-deadZone;
	let mul = newLen/len;
	return [valA*mul, valB*mul];
};

//af is normally selectedOb.aftrans such as a ball to move and rotate.
var controllerTransformsAftrans = function(controllerName, afIn, dt){
	
	//TODO optimize: can this be done by returning an aftrans thats reusable, such as to rotate all the points on the ball?
	
	let mulRotate = 6*dt;
	let mulResize = 2.5*dt;
	let mulMove = 620*dt;
	
	let af = copyFloat32Array(afIn);
	
	for(let i=12; i<16; i++) af[i] = 0; //centered at origin. Put these back after rotations.
	
	
	
	
	let deadZone = .1; //FIXME get this statistically
	let mAndN = control2WithDeadzone(deadZone, controllerName+'_dim0', controllerName+'_dim1'); //left joystick
	let m = mAndN[0];
	let n = mAndN[1];
	let oAndP = control2WithDeadzone(deadZone, controllerName+'_dim2', controllerName+'_dim3'); //right joystick
	let o = oAndP[0];
	let p = oAndP[1];
	let q = controlWithDeadzone(controllerName+'_btn6',deadZone); //left analog trigger, 0..1
	let r = controlWithDeadzone(controllerName+'_btn7',deadZone); //right analog trigger, 0..1
	let qr = r-q; //-1..1
	
	let lb = controlWithDeadzone(controllerName+'_btn4',deadZone);
	let rb = controlWithDeadzone(controllerName+'_btn5',deadZone);
	let mulSize = 1+(rb-lb)*mulResize;
	
	let angleB = m*mulRotate;
	
	let angleC = n*mulRotate;
	
	let angleD = qr*mulRotate;
	
	console.log('angleB='+angleB+' angleC='+angleC+' angleD='+angleD);
	
	
	/*c[AYY] = Math.cos(angleD);
	c[AYX] = -Math.sin(angleD);
	c[AXY] = Math.sin(angleD);
	c[AXX] = Math.cos(angleD);
	*/
	
	//let dimA = AX;
	//let dimB = AY;

	let dimA = 0;
	let dimB = 0;
	let angle = 0;
	for(let kindOfRotation=0; kindOfRotation<3; kindOfRotation++){
		switch(kindOfRotation){
		case 0:
			dimA = AX;
			dimB = AZ;
			angle = angleB;
		break;case 1:
			dimA = AY;
			dimB = AZ;
			angle = angleC;
		break;case 2:
			dimA = AX;
			dimB = AY;
			angle = angleD;
		}
		for(let i=0; i<4; i++){
			//if((i == dimA) || (i == dimB)){
			
				//let indexJ = dimA*4+i; //FIXME i*4+dimA?
				//let indexK = dimB*4+i; //FIXME i*4+dimB?
				let indexJ = i*4+dimA;
				let indexK = i*4+dimB;
				let prevValJ = af[indexJ];
				let prevValK = af[indexK];
				af[indexJ] = prevValJ*Math.cos(angle) - prevValK*Math.sin(angle); //TODO optimize by reusing sin and cos
				af[indexK] = prevValJ*Math.sin(angle) + prevValK*Math.cos(angle);
			//}
		}
		
		/*
		[dimA*4+dimB] = Math.cos(angleD);
		c[dimA*4+dimB] = -Math.sin(angleD);
		c[dimA*4+dimB] = Math.sin(angleD);
		c[dimA*4+dimB] = Math.cos(angleD);
		*/
	}
	
	af[AXX] *= mulSize;
	af[AXY] *= mulSize;
	af[AXZ] *= mulSize;
	af[AYX] *= mulSize;
	af[AYY] *= mulSize;
	af[AYZ] *= mulSize;
	af[AZX] *= mulSize;
	af[AZY] *= mulSize;
	af[AZZ] *= mulSize;
	
	for(let i=12; i<16; i++) af[i] = afIn[i]; //get original position back. keep rotation.
	
	af[ASX] += o*mulMove;
	af[ASY] += p*mulMove;
	
	return af;
};


/*
//Example controllerName: 'gamepad0'
//Example mul: .03, normally proportional to dt (change in time since last used this to aftrans something)
//var controllerToAftrans = function(controllerName, mulRotate, multResize, mulMove){
	
//FIXME can this be done by returning an aftrans without having to take one as param?
var controllerModifiesAftrans = function(controllerName, mulRotate, multResize, mulMove){ //this never worked right
	let deadZone = .1; //FIXME get this statistically
	let mAndN = control2WithDeadzone(deadZone, controllerName+'_dim0',deadZone, controllerName+'_dim1',deadZone); //left joystick
	let m = mAndN[0];
	let n = mAndN[1];
	let oAndP = control2WithDeadzone(deadZone, controllerName+'_dim2',deadZone, controllerName+'_dim3',deadZone); //right joystick
	let o = oAndP[0];
	let p = oAndP[1];
	let q = controlWithDeadzone(controllerName+'_btn6',deadZone); //left analog trigger, 0..1
	let r = controlWithDeadzone(controllerName+'_btn7',deadZone); //right analog trigger, 0..1
	let qr = r-q; //-1..1
	
	let lb = controlWithDeadzone(controllerName+'_btn4',deadZone);
	let rb = controlWithDeadzone(controllerName+'_btn5',deadZone);
	let multSize = 1+(rb-lb)*multResize;
	
	let angleB = m*mulRotate;
	
	let angleC = n*mulRotate;
	
	let angleD = qr*mulRotate;
	
	/*let a = newIdentAftrans();
	a[AXX] = Math.cos(angleB);
	a[AXZ] = -Math.sin(angleB);
	a[AZX] = Math.sin(angleB);
	a[AZZ] = Math.cos(angleB);
	
	let b = newIdentAftrans();
	b[AYY] = Math.cos(angleC);
	b[AYZ] = -Math.sin(angleC);
	b[AZY] = Math.sin(angleC);
	b[AZZ] = Math.cos(angleC);
	*
	
	
	let c = newIdentAftrans();
	
	/*c[AYY] = Math.cos(angleD);
	c[AYX] = -Math.sin(angleD);
	c[AXY] = Math.sin(angleD);
	c[AXX] = Math.cos(angleD);
	*
	
	let dimA = AX;
	let dimB = AY;
	for(let i=0; i<4; i++){
		if(i != AS){ //dont rotate position offset, just rotate the rotations.
			//let indexJ = dimA*4+i; //FIXME i*4+dimA?
			//let indexK = dimB*4+i; //FIXME i*4+dimB?
			let indexJ = i*4+dimA;
			let indexK = i*4+dimB;
			let prevValJ = c[indexJ];
			let prevValK = c[indexK];
			c[indexJ] = prevValJ*Math.cos(angleD) - prevValK*Math.sin(angleD);
			c[indexK] = prevValJ*Math.sin(angleD) + prevValK*Math.cos(angleD);
		}
	}
	
	/*for(let g=0; g<4; g++){
		for(let h=0; h<4; h++){
			let index = g*4+h;
			//if((g == AS) || (h == AS)) c[index] = 0;
			if(g == AS){
				if(h == AS){
					c[index] = 10;
				}else{
					c[index] = 0;
				}
			}else{ //g != AS
				if(h == AS){
					c[index] = 1;
				}else{
					//leave as it is
				}
			}
		}
	}*
	
	
	
	/*
	c[AYY] = Math.cos(angleD);
	c[AYX] = -Math.sin(angleD);
	c[AXY] = Math.sin(angleD);
	c[AXX] = Math.cos(angleD);
	*
	
	/*
	let d = newIdentAftrans();
	d[AXX] = multSize;
	d[AYY] = multSize;
	d[AZZ] = multSize;
	
	
	let e = newIdentAftrans();
	d[ASX] = o*mulMove;
	d[ASY] = p*mulMove;
	*
	
	//let ret = aftransOfAftrans(aftransOfAftrans(aftransOfAftrans(aftransOfAftrans(a,b),c),d),e);
	let ret = c;
	
	//console.log('controllerToAftrans', controllerName+' '+m+' '+n+' '+o+' '+p);
	return ret;
};
*/

//Sim is designed to not touch webcam, mouse, game controllers, or any other inputs and outputs, and do everything thru ByteRect
//(and TODO map of string to number for gamepad, mouse, keyboard, etc, and maybe also ScriptNode in WebAudioAPI)
//dim means dimension.
var Sim = function(){

	//TODO? returns deepest child at that, in the this.childs[...].childs[...].whatsAtYx(yx) etc. Returns this if no child matches that.
	//FIXME for now, just checks 1 level deep, since thats where the Balls are, else returns null.
	this.whatsAtYx = function(yx){
		let minDistance = Infinity;
		let nearestBall = null;
		for(let i in this.childs){
			let child = this.childs[i];
			//if(child instanceof Ball){
				//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof
				//The instanceof operator tests to see if the prototype property of a constructor appears anywhere in the prototype chain of an object. The return value is a boolean value.
				//throw 'TODO put AfPoint at mouse instead, centered on first ball';
				let distance2dMouseToBallCenter = Math.hypot(child.aftrans[ASX]-yx[1], child.aftrans[ASY]-yx[0]);
				if(distance2dMouseToBallCenter < minDistance){
					minDistance = distance2dMouseToBallCenter;
					nearestBall = child;
				}
			//}
		}
		return nearestBall; //FIXME check if its inside the balls oval area on screen
	};

	this.isPaused = false;

	//FIXME? Sim is top level so maybe doesnt need aftrans? Would be more consistent to have it,
	//but it would interfere with older code in Sim.io(...byterects etc...) not using aftrans (yet?).
	//this.aftrans = newIdentAftrans()

	//direct childs, which as of 2021-8 are just Balls, and direct childs of Ball are Circles, so this.childs[0].childs[0] is a Circle unless empty.
	this.childs = [];

	this.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU = false;
	
	this.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	
	this.displaySprings = false;
	//brightness 0 (if 0 were allowed in slider-controlled vars, which its not), contrast 1, is no adjustment, but it seems to make the springs black nearly everywhere.
	this.displaySpringBrightnessSubtract = 3;
	//this.displaySpringBrightness = 0;
	this.displaySpringContrast = 6;
	
	this.ifDisplaySpringsThenOnlyThoseFromThisVoxelIndexOrNullToDisplayAll = 0;
	
	this.enable_holdVoxelsYXAtSingleRadius = true;
	this.holdVoxelsYXAtSingleRadius = 160;
	
	this.allowChangeSelectedObIfSomethingAlreadySelected = true;
	
	this.isFindDots = false;
	this.minColorDiffFractionToBeADot = .3;
	
	this.findDots_maxDotSize_param = 5;
	
	this.isFindEdgesAndKeepTheirColor = false;
	
	this.isMoveAndResizeSelectedObToStrongestCircleFoundByGPU = false;
	this.isRotateAndAdjustSphericalPicOnOfAllBallsFromBallsCurrentApproxPositionButManyPossibleRotations = false;
	
	//for xbox dual joystick dual analog trigger controller (for example),
	//but may work on other controllers right away or maybe if you adjust what axis does what (TODO)
	//If true, then its moved by controllerToAftrans, so you can adjust what axis does what there.
	this.gamepadMovesAndRotatesSelectedBall = true;
	
	this.hidePointsThatAreBehindOtherPoints = true;
	
	this.doTestCirclesDetect_oneCenterMultiSizes = false;
	this.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu = false;

	this.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked = false;
	
	this.randomlyChangeFirstBallsAftransGradually = true;
	
	this.holdVoxelsYXInByteRect = true;
	
	this.paintTestObjectsAsInput = true;
	
	this.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU = true;
	this.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG = false;
	
	this.allowBytesIntoGpuElseCopyBytesToFloats_thisMayBeBuggy = false;
	
	this.pixelColorAcceleratesVoxelsInsteadOfMovesThem = false;
	
	this.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	
	this.addABallIfThereIsNoneWhenRestart = false;
	
	//when display lines between voxels, brightness is the potentialEnergy hill of that spring depending on their distance,
	//but it needs the whole distance between them (and outward to infinity, though only 100 pixels or so past them is displayed)
	//as if 1 of them is at constant position and the potentialEnergy of the other is displayed at those possible positions.
	//Do you want it to display relative to the selected voxel vs the other voxel (for all other voxels, a line displayed for each)?
	this.displayPotentialEnergyFromSelectedVsTo = false;
	
	/*
	//learnRate of SRESTLEN (spring at-rest-length) decaying toward SAVEDIST (spring recent average length) when dist is near SAVEDIST.
	this.decaySRESTLEN = 1;
	//FIXME SRESTLEN and SAVEDIST are the same val as of 2021-7-17 but wont 	always be that way, TODO
	this.decaySAVEDIST = 1;
	*/
	//this.decaySAVEDIST = .01;
	//this.decaySAVEDIST = .03;
	this.decaySAVEDIST = .1;
	//this.decaySAVEDIST = 0; //FIXME
	
	this.decaySSTRENGTH = .01;
	//this.decaySSTRENGTH = 0; //FIXME
	
	//somewhere in the middle of repelling alot vs repelling a little. The closer they get, the more they repel.
	this.repelMidDist = 10;
		
	//how many times SSTRENGTH is potentialEnergy from repelling (compared to potentialEnergy from spring vibrating has a max of SSTRENGTH).
	this.repelTimesMoreThanSpring = 2.1;
	//this.repelTimesMoreThanSpring = .00001;
	
	/** velocity *= decayVelocities*dt. This isnt correct physics but is a fast way to get started.
	Correct physics friction subtracts from velocity instead of decays it,
	subtracts proportional to how much the frictioning objects are pushing against eachother etc,
	but if objects start going really fast, as they often do in simulations, its useful to decay instead of subtract.
	Explore both later, after the basics are working.
	*/
	this.decayVoxelVelocities = .4;
	
	//0..255. Only keep rows (red green or blue of separately) at most this bright on average
	this.brightLimitForRowsAndColsToNotBeSetToBlack_bright = 70;
	
	//0..1
	this.brightLimitForRowsAndColsToNotBeSetToBlack_fraction = .2;

	
	/*
	//the test* (testX testB testSize etc) vars will be removed after grid of voxels is working. that was the first voxel.
	//a point that sees color and tries to stay the same color
	this.testX = 200; //voxel x
	this.testY = 200; //voxel y
	this.testR = 0; //voxel red
	this.testG = 0; //voxel green
	this.testB = 255; //voxel blue
	*/
	//this.testSize = 57;
	//this.testSize = 30;
	//this.testSize = 50;
	//this.testSize = 10;
	this.testSize = 30;
	
	//negative is repelled by its current color. positive attract.
	//this.testSpeedMult = -1000; //how fast to move (or accel? todo) the "test" voxel that looks at colors near it and moves toward colors near its own current color
	//this.testSpeedMult = 14400;
	
	//FIXME 14000 might be a little too fast for some computers and will get jittery and get stuck at sides of screen,
	//so reduce it if so. TODO auto detect that kind of stuff. Auto tune it for best match to whats happening on screen and computer abilities.
	//Similar for colorChangeSpeedMult and (this is testSpeedMult).
	this.testSpeedMult = 14000;
	//this.testSpeedMult = 4000;
	//this.testSpeedMult = 400;
	//this.testSpeedMult = 20000; //jumpy even on a fast computer. on a slower computer, might not work at all unless reduce this. springs can make it smoother. todo.
	//
	//2021-7-17 testSpeedMult is how much voxels are moved by near pixel colors they see, not how much they are moved by springs (which is in SSTRENGTH instead).
	//
	//this.testSpeedMult = 400;
	//this.testSpeedMult = 0;
	
	//force (voxelVelocity += dt*mass*accel) due to springs, but all voxels have mass of 1 as of 2021-7-25).
	this.springForceMult = 4000;
	
	//positive becomes more like the color it is near, negative less like it. only positive is stable here.
	//this.colorChangeSpeedMult = 8;
	this.colorChangeSpeedMult = 4;
	//this.colorChangeSpeedMult = .4;
	//this.colorChangeSpeedMult = 0; //FIXME
	
	//this.numVoxels = 3; //TODO want at least 10000 voxels later, will need sparse springs and GPU.js
	//this.numVoxels = 2; //TODO want at least 10000 voxels later, will need sparse springs and GPU.js
	//this.numVoxels = 10; //TODO want at least 10000 voxels later, will need sparse springs and GPU.js
	//this.numVoxels = 50; //TODO want at least 10000 voxels later, will need sparse springs and GPU.js
	this.numVoxels = 200; //TODO want at least 10000 voxels later, will need sparse springs and GPU.js
	//this.numVoxels = 1000; //TODO want at least 10000 voxels later, will need sparse springs and GPU.js
	this.numSprings = this.numVoxels*this.numVoxels;
	//VARSPERVOXEL this.varsPerVoxel = 7; //FIXME how many?
	//VARSPERSPRING this.varsPerSpring = 4; //FIXME how many?
	//for now, do dense springs between all pairs of voxels (including both directions of spring, which are duplicate, but just to keep it simple).
	//later do sparse with max 1 spring (not 2) per pair of voxels, as optimization.
	
	//params are 2 voxel indexs
	this.distanceSq = function(voxA, voxB){
		let aa = voxA*VARSPERVOXEL;
		let bb = voxB*VARSPERVOXEL;
		let diffX = this.voxels[aa+VX]-this.voxels[bb+VX];
		let diffY = this.voxels[aa+VY]-this.voxels[bb+VY];
		let diffZ = this.voxels[aa+VZ]-this.voxels[bb+VZ];
		return diffX*diffX + diffY*diffY + diffZ*diffZ;
	};
	
	//-1 if this.numVoxels==0, else range 0 to this.numVoxels-1.
	//whichever is nearest to mouse in 2d (TODO draggable)
	this.selectedVox = function(){
		let nearestVox = -1;
		let nearestDist = Infinity;
		for(let i=0; i<this.numVoxels; i++){
			let dist = Math.hypot(this.voxelVar(i,VX)-mouseX, this.voxelVar(i,VY)-mouseY);
			if(dist < nearestDist){
				nearestVox = i;
				nearestDist = dist;
			}
		}
		return nearestVox;
	};
	
	this.distance = function(voxA, voxB){
		let aa = voxA*VARSPERVOXEL;
		let bb = voxB*VARSPERVOXEL;
		return Math.hypot(
			this.voxels[aa+VX]-this.voxels[bb+VX],
			this.voxels[aa+VY]-this.voxels[bb+VY],
			this.voxels[aa+VZ]-this.voxels[bb+VZ]
		);
	};
	
	/** 0 <= spr < this.numSprings. */
	this.distanceSpring = function(spr){
		let voxA = spr%this.numVoxels;
		let voxB = (spr-voxA)/this.numVoxels;
		return this.distance(voxA,voxB);
	};
	
	this.setAllVoxelPositionsAndSpeedsInZDimTo0ToBecome2d = function(){
		for(let v=0; v<this.numVoxels; v++){
			let index = v*VARSPERVOXEL+VZ;
			this.voxels[index] = 0;
			this.voxelVels[index] = 0;
		}
	};
	
	this.restart = function(){
		//FIXME this doesnt replace some parts that replaceSim does, and replaceSim maybe doesnt do all this like put the this.voxels back in?
	
		console.log('restart');
		//TODO use GPU.js
		this.voxels = new Float32Array(this.numVoxels*VARSPERVOXEL); //position
		this.voxelVels = new Float32Array(this.voxels.length); //velocity
		this.springs = new Float32Array(this.numSprings*VARSPERSPRING); //springs use the positions and velocities of 2 voxels so dont have those properites themselves
		for(let v=0; v<this.numVoxels; v++){
			let vv = v*VARSPERVOXEL;
			this.voxels[vv+VRED] = Math.random()*255.999;
			this.voxels[vv+VGREEN] = Math.random()*255.999;
			this.voxels[vv+VBLUE] = Math.random()*255.999;
			this.voxels[vv+VX] = 100+300*Math.random();
			this.voxels[vv+VY] = 100+300*Math.random();
			if(this.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly){
				this.voxels[vv+VZ] = 100+300*Math.random();
			}else{
				this.voxels[vv+VZ] = 0;
			}
			this.voxels[vv+VWEBCAMS] = 1;
		}
		for(let v=0; v<this.voxelVels.length; v++){
			this.voxelVels[v] = 0;
		}
		for(let s=0; s<this.numSprings; s++){
			let voxA = s%this.numVoxels;
			let voxB = (s-voxA)/this.numVoxels;
			let ss = s*VARSPERSPRING;
			this.springs[ss+SSTRENGTH] = 25/this.numVoxels;
			//this.springs[ss+SSTRENGTH] = 5/this.numVoxels;
			//this.springs[ss+SSTRENGTH] = 3;
			//this.springs[ss+SSTRENGTH] = 10;
			//this.springs[ss+SSTRENGTH] = 0; //FIXME
			let dist = this.distance(voxA,voxB);
			this.springs[ss+SAVEDIST] = dist;
			//this.springs[ss+SRESTLEN] = dist*rand(.8,1.2);
			this.springs[ss+SRESTLEN] = dist;
			
			//FIXME as of 2021-7-16 SFRICTION is not used yet but Sim.decayVoxelVelocities is.
			//SFRICTION is better cuz doesnt resist objects spinning. only resists change in spring length.
			this.springs[ss+SFRICTION] = .0001; //FIXME this will probably be ignored until later, but without it, springs vibrate out of control
			//TODO norm by energy per spring, sum potentialEnergy of all those and kineticEnergy of all voxels.
			
			this.springs[ss+SDOWNFROM] = 1;
			//this.springs[ss+SWIDE] = dist*.1;
			//this.springs[ss+SWIDE] = dist*.03;
			this.springs[ss+SWIDE] = dist*.07;
			//this.springs[ss+SWIDE] = dist*.1;
			//this.springs[ss+SWIDE] = dist*.01;
			//this.springs[ss+SWIDE] = dist*1.05;
		}
		if(this.addABallIfThereIsNoneWhenRestart){
			if(this.childs.length == 0){
				let div = dom('controlsDiv_aftranses');

				let ball = this.addRandomBall();
				//if(!selectedOb) selectedOb = ball; //FIXME? allowChangeSelectedObIfSomethingAlreadySelected
				trySetSelectedOb(ball);
				//ball.aftrans = Float32Array.of(0, -40, 0, 0, 40, 50, 0, 0, 50, -40, 10, 0, 190 ,200, 0, 0)
				//ball.aftrans = Float32Array.of(40, -40, 0, 0, 40, 80, 0, 0, 50, -40, 10, 0, 190, 200, 0, 0);
				//ball.aftrans = Float32Array.of(40, -40, 1, 1, 40, 80, 1, 1, 50, -40, 10, 1, 190, 200, 1, 1)
				//ball.aftrans = Float32Array.of(40, -40, 0, 0, 40, 70, 0, 0, 50, -40, 0, 0, 190, 200, 0, 0);
				//ball.aftrans = Float32Array.of(40, -40, 0, 1, 40, 70, 0, 1, 50, -40, 0, 1, 190, 200, 0, 1);
				ball.aftrans = Float32Array.of(50, 0, 0, 1, 0, 50, 0, 1, 0, 0, 50, 1, 190, 200, 0, 1);
				createControlsForAftransInDiv(ball.aftrans, div, 10);		
				this.addAfPointSharingAftransWith(this, ball); //FIXME if replace ball.aftrans, its not sharing it with the AfPoint anymore
				
				
				let ball2 = this.addRandomBall();
				//ball2.aftrans = Float32Array.of(0, -40, 0, 0, 40, 50, 0, 0, 50, -40, 10, 0, 390 ,200, 0, 0)
				//ball2.aftrans = Float32Array.of(70, -90, 0, 0, -50, 0, 70, 0, 80, 90, 240, 0, 430, 250, 80, 0);
				//ball2.aftrans = Float32Array.of(70, -90, 1, 1, -50, 1, 70, 1, 80, 90, 240, 1, 430, 250, 80, 1);
				//ball2.aftrans = Float32Array.of(60, 0, 0, 1, 0, 40, 0, 1, 0, 0, 50, 1, 390, 220, 0, 1);
				ball2.aftrans = Float32Array.of(60, 0, 0, 1, 0, 40, 0, 1, 0, 0, 50, 1, 490, 220, 0, 1);
				createControlsForAftransInDiv(ball2.aftrans, div, 10);
				this.addAfPointSharingAftransWith(this, ball2);
				
				this.addAfPoint(); //adds 2 of them, one inside the other
				
			}
		}
	};
	
	this.addRandomBall = function(){
		//TODO need to know size of ByteRect its displayed in (unless theres a standard size of the space and may Sim.aftrans view it)
		//let equatorAngles = 40; //FIXME should be around 100. //must be even. poleAngles is half that
		let equatorAngles = 100; //must be even. poleAngles is half that
		//let equatorAngles = 200;
		//let equatorAngles = 300; //FIXME 100
		let ball = new Ball(equatorAngles); //starts with identityFunc aftrans. change that so its not just 2 pixels wide (radius 1)
		
		ball.setBaxels(function(prevVal, normX, normY, normZ, baxelDim){
			//return 255;
			switch(baxelDim){
			case BRED:
				//return 0;
				return (128+normX*127.999);
			case BGREEN:
				//return 0;
				return (128+normY*127.999);
			case BBLUE:
				//return 0;
				return (128+normZ*127.999);
			case BLASTWEBCAM:
				return 255; //255 is visible. 0 is transparent. as that webcam (of possibly multiple webcams, todo) sees it.
			default:
				return prevVal;
			}
		});
		
		
		//x y z scale, in 4x4
		/*let x = 250;
		let y = 200;
		let z = 0;
		let radius = 70;
		ball.aftrans[ASX] = x; //FIXME ASX vs AXS?
		ball.aftrans[ASY] = y; //FIXME?
		ball.aftrans[ASZ] = z; //FIXME?
		ball.aftrans[ASS] = radius; //TODO choose for radius to go here vs in some combo of x y and z?
		*/
		ball.aftrans[AXX] = 100; //FIXME
		ball.aftrans[AYY] = 100;
		ball.aftrans[AZZ] = 100;
		ball.aftrans[ASS] = 100;
		this.childs.push(ball);
		//let div = dom('controlsDiv');
		return ball;
	};
	
	this.addAfPointSharingAftransWith = function(parentOfShareMyAftrans, shareMyAftrans){
		let div = dom('controlsDiv_aftranses');
		let a = new AfPoint(shareMyAftrans.aftrans);
		parentOfShareMyAftrans.childs.push(a);
		return a;
	};
	
	this.addAfPoint = function(){
		let div = dom('controlsDiv_aftranses');
		let a = new AfPoint(newRandAftrans());
		div.innerHTML += '<hr>';
		createControlsForAftransInDiv(a.aftrans, div, 10);
		for(let i=0; i<1; i++){
			//a.childs.push(new AfPoint(newRandAftrans()));
			//a.childs.push(new AfPoint(newRandAftransNearIdent()));
			let childAftrans = newRandAftransNearIdent();
			a.childs.push(new AfPoint(childAftrans));
			div.innerHTML += '<hr>';
			createControlsForAftransInDiv(childAftrans, div, .1);
		}
		this.childs.push(a);
		
		//this.childs[0].aftrans = this.childs[1].aftrans; //make ball and afpoint share the same aftrans, to figure out what went wrong
		
		//Experimental things I typed into browser:
		//sim.childs[0].aftrans = Float32Array.of(100,0,0,0,  0,100,0,0,  10,10,100,10,  120,90,121,1);
		return a;
	};
	

	//copy of the prev byteRect, so can compare 2 consecutive video frames from webcam.
	//this.prevByteRect = null;
	
	//a 2d bendable surface were each point on it has position and velocity in 6 dims: x y z red green blue (or maybe dont have velocity in the color dims?),
	//so its those 12 (or 9?) floats at each 2d cell. Plus it maybe should also have 3 more floats for the target color, or 6 more for prev and next color.
	//These are aligned to the incoming webcam pixels, to bend the sheet and gradually change its color to represent objects moving and rotating
	//in what the webcam sees, to allow it to better predict what it will see next by these velocities and using those predictions
	//to rotate and bend and stretch and squash etc the sheet in these higher dimensions to, for example, have a moving 3d model of your hands
	//that appears at the same pixel locations the webcam sees your hands, so can put augmented reality stuff
	//ike your fingers friction to affect a basketball's spin while you shoot it at a hoop) into the displayed video.
	//It doesnt have to do object recognition to predict which parts of the 3d volume have objects at them and which dont (at voxel precision).
	//this.sheet = null;
	
	this.adjustVoxelVelocitiesBySprings = function(dt){
		if((this.numVoxels == 0) || (this.numSprings == 0) || (dt == 0)) return;
		
		//TODO use velocity and springDampening instead of this quickly written jittery experiment that doesnt use velocity at all...
		let pos = this.voxels;
		let vel = this.voxelVels;
		let spr = this.springs;
		for(let s=0; s<this.numSprings; s++){
			let voxA = s%this.numVoxels;
			let voxB = (s-voxA)/this.numVoxels; //same as floor(s/this.numVoxels) but faster
			let aa = voxA*VARSPERVOXEL;
			let bb = voxB*VARSPERVOXEL;
			//let ss = s*VARSPERSPRING;
			
			let diffX = pos[bb+VX]-pos[aa+VX];
			let diffY = pos[bb+VY]-pos[aa+VY];
			let diffZ = pos[bb+VZ]-pos[aa+VZ];
			let dist = Math.hypot(diffX, diffY, diffZ);
			if(dist != 0){
				let normX = diffX/dist; //(normX,normY,normZ) is a unit vector from voxA toward voxB.
				let normY = diffY/dist;
				let normZ = diffZ/dist;
			
				//as of 2021-7-25 every voxel's mass is 1.
				let force = this.potentialEnergyDerivativeOfSpring(s)*this.springForceMult;
				//force = -force; //FIXME?
				let forceEach = force/2;
				let mul = forceEach*dt;
				
				let addEachDx = normX*mul;
				let addEachDy = normY*mul;
				let addEachDz = normZ*mul;
				
				vel[aa+VX] += addEachDx;
				vel[aa+VY] += addEachDy;
				vel[aa+VZ] += addEachDz;
				vel[bb+VX] -= addEachDx;
				vel[bb+VY] -= addEachDy;
				vel[bb+VZ] -= addEachDz;
				
				
				/*
				//let dist = this.distance(voxA,voxB);
				//if(dist == 0) continue; //FIXME
				//let aveDist = spr[ss+SAVEDIST];
				let restDist = spr[ss+SRESTLEN]; //how long the spring would be if its at rest
				let strength = spr[ss+SSTRENGTH]; //strength of 0 is spring not existing. strength >= 0. Higher strength holds the 2 voxels toward restDist more.
				let diffX = pos[bb+VX]-pos[aa+VX];
				let diffY = pos[bb+VY]-pos[aa+VY];
				let diffZ = pos[bb+VZ]-pos[aa+VZ];
				let dist = Math.hypot(diffX, diffY, diffZ);
				if(dist != 0){
					//TODO force = mass*accel, but as of 2021-7-16 all voxels have mass 1.
					let accel = strength*(restDist-dist); //positive is the 2 voxels accel toward eachother. negative repels.
					let mul = dt*accel/dist/2; // /2 for half accel at each voxel. divide by dist to get normed (x,y,z) vec.
					mul = -mul; //FIXME why does this need to be flipped? 2021-7-17 found that SSTRENGTH needed to be negative for spring to vibrate vs explode
					let addEachDx = diffX*mul;
					let addEachDy = diffY*mul;
					let addEachDz = diffZ*mul;
					vel[aa+VX] += addEachDx;
					vel[aa+VY] += addEachDy;
					vel[aa+VZ] += addEachDz;
					vel[bb+VX] -= addEachDx;
					vel[bb+VY] -= addEachDy;
					vel[bb+VZ] -= addEachDz;
				}
				*/
			}
		}
	};
	
	this.adjustPositionsByVelocities = function(positions, velocities, dt){
		warnIfStrangeDt(dt);
		if(positions.length != velocities.length) throw 'Diff sizes positions and velocities';
		for(let i=0; i<positions.length; i++) positions[i] += velocities[i]*dt;
	};
	
	//https://en.wikipedia.org/wiki/Harmonic_oscillator#Damped_harmonic_oscillator
	//friction is proportional to abs(dotProd(voxelA_dx_dy_dz - voxelB_dx_dy_dz, normToUnitVec(voxelA_x_y_z-voxelB_x_y_z))),
	//where normToUnitVec divides that by its distance unless its 0 in which case the dotProd is 0.
	this.adjustVelocitiesBetweenPairsOfVoxelsBasedOnVelocitiesAlongSpringsSoIfSpringIsntChangingLengthTheresNoFriction = function(dt){
		//TODO
	};
	
	//decay vars range 0 to 1, normally very near 0.
	this.updateAverageDistancesAndRestLens = function(aveDistDecay){
		if(aveDistDecay == 0) return;
		//console.log('aveDistDecay='+aveDistDecay);
		for(let s=0; s<this.numSprings; s++){
			let voxA = s%this.numVoxels;
			let voxB = (s-voxA)/this.numVoxels;
			let prevAveDist = this.springs[s+SAVEDIST];
			let dist = this.distance(voxA,voxB);
			let ss = s*VARSPERSPRING;
			this.springs[ss+SAVEDIST] = this.springs[ss+SAVEDIST]*(1-aveDistDecay)+aveDistDecay*dist;
			this.springs[ss+SRESTLEN] = this.springs[ss+SAVEDIST]; //FIXME should restlen always be average distance?
			//TODO norm by energy per spring, sum potentialEnergy of all those and kineticEnergy of all voxels.
		}
	};
	
	//FIXME should SRESTLEN and SAVEDIST be merged?
	
	this.updateSpringStrengths = function(decayTowardTargetStrength){
		if(decayTowardTargetStrength == 0) return;
		
		//FIXME
		
		/*
		//TODO strength changes faster depending on how fast both the voxels are moving
		//in absolute 3d space (or 2d per webcam? that makes it harder to scale to n webcams, so 3d better in that way).
		//That would avoid adjusting strength for things that arent moving at the time, such as the background,
		//while making things that are moving, multiple voxels in it moving approx together, grow spring strength between them.
		
		//TODO experiment with few enough voxels that can display all the springs, and a few small marks on the line (between 2 vox)
		//representing aveDist, dist, strength related stuff, etc, so can watch it and verify it does what i want.
	
		for(let s=0; s<this.numSprings; s++){
			let ss = s*VARSPERSPRING;
			let voxA = s%this.numVoxels;
			let voxB = (s-voxA)/this.numVoxels;
			let aveDist = this.springs[ss+SAVEDIST];
			let dist = this.distance(voxA,voxB);
			let distDiff = Math.abs(dist-aveDist); //TODO other nonlinear func? allow it to vary more the farther their aveDist?
			let targetStrength = 1/(10+distDiff);
			this.springs[ss+SSTRENGTH] = this.springs[ss+SSTRENGTH]*(1-decayTowardTargetStrength)+decayTowardTargetStrength*targetStrength;
			//TODO norm by energy per spring, sum potentialEnergy of all those and kineticEnergy of all voxels.
		}
		*/
	};
	
	//called by this.io
	this.voxelsAndSpringsIO = function(dt, byteRectIn, byteRectOut){
		if(this.isPaused) return;
		warnIfStrangeDt(dt);
		byteRectIn.verifySameSizeAs(byteRectOut);
		//TODO use asap: VRED VGREEN VBLUE VX VY, and spring dims: SSTRENGTH SRESTLEN SFRICTION, in this.voxels and this.springs
		//TODO use later: VZ VWEBCAMS
		//TODO use much later: VWEBCAMS+1 VWEBCAMS+2 VWEBCAMS+3...
		//throw 'TODO voxelsAndSpringsIO';
		
		let selectedVox = this.selectedVox();
		
		let moveMul = dt*this.testSpeedMult;
		let accelMul = dt*Math.sqrt(moveMul); //FIXME make a new Sim.varname for this.
		let colorMul = dt*this.colorChangeSpeedMult;
		//let isPaintOver = false;
		//let isPaintOver = true;
		
		let minY = this.testSize/2;
		let minX = this.testSize/2;
		let maxY = byteRectIn.height-this.testSize/2;
		let maxX = byteRectIn.width-this.testSize/2;
		
		
		
		//if((this.ifDisplaySpringsThenOnlyThoseFromThisVoxelIndexOrNullToDisplayAll != null) && Math.random()<.1){
		//if(this.ifDisplaySpringsThenOnlyThoseFromThisVoxelIndexOrNullToDisplayAll != null){
		//	this.ifDisplaySpringsThenOnlyThoseFromThisVoxelIndexOrNullToDisplayAll = randInt(this.numVoxels);
		//}
		this.ifDisplaySpringsThenOnlyThoseFromThisVoxelIndexOrNullToDisplayAll = selectedVox;
		
		for(let v=0; v<this.numVoxels; v++){ //TODO GPU.js instead of this loop
			let vv = v*VARSPERVOXEL;
			let derivs = byteRectIn.yxrgbDerivs(
				this.testSize,
				this.voxels[vv+VY],
				this.voxels[vv+VX],
				this.voxels[vv+VRED],
				this.voxels[vv+VGREEN],
				this.voxels[vv+VBLUE],
				byteRectOut //if this param is nonnull, paint it here
			);
			if(this.pixelColorAcceleratesVoxelsInsteadOfMovesThem){
				this.voxels[vv+VY] += derivs[0]*moveMul;
				this.voxels[vv+VX] += derivs[1]*moveMul;
			}else{
				this.voxelVels[vv+VY] += derivs[0]*accelMul;
				this.voxelVels[vv+VX] += derivs[1]*accelMul;
			}
			if(this.enable_holdVoxelsYXAtSingleRadius){
				let centerY = byteRectOut.height/2;
				let centerX = byteRectOut.width/2;
				let diffY = this.voxels[vv+VY]-centerY;
				let diffX = this.voxels[vv+VX]-centerX;
				let observedRadius = Math.hypot(diffY, diffX);
				let newRadius = this.holdVoxelsYXAtSingleRadius;
				let changeRadius = newRadius-observedRadius;
				let mul = changeRadius/observedRadius;
				this.voxels[vv+VY] += diffY*mul;
				this.voxels[vv+VX] += diffX*mul;
			}
			if(this.holdVoxelsYXInByteRect){
				this.voxels[vv+VY] = between(minY, this.voxels[vv+VY], maxY);
				this.voxels[vv+VX] = between(minX, this.voxels[vv+VX], maxX);
			}
			
			//FIXME why are these 3 lines causing movement?
			this.voxels[vv+VRED] += derivs[2]*colorMul;
			this.voxels[vv+VGREEN] += derivs[3]*colorMul;
			this.voxels[vv+VBLUE] += derivs[4]*colorMul;
			
			
			this.voxels[vv+VY] = between(0, this.voxels[vv+VY], byteRectIn.height-1);
			this.voxels[vv+VX] = between(0, this.voxels[vv+VX], byteRectIn.width-1);
			this.voxels[vv+VRED] = between(0, this.voxels[vv+VRED], 255);
			this.voxels[vv+VGREEN] = between(0, this.voxels[vv+VGREEN], 255);
			this.voxels[vv+VBLUE] = between(0, this.voxels[vv+VBLUE], 255);
		}
		if(this.displaySprings){
			//TODO optimize loop for ifDisplaySpringsThenOnlyThoseFromThisVoxelIndexOrNullToDisplayAll!=null to loop over far fewer springs instead of skipping in loop body
			for(let s=0; s<this.numSprings; s++){
				let voxA = s%this.numVoxels;
				let voxB = (s-voxA)/this.numVoxels;
				if(
					(this.ifDisplaySpringsThenOnlyThoseFromThisVoxelIndexOrNullToDisplayAll == null)
					|| ((!this.displayPotentialEnergyFromSelectedVsTo) && (voxA == this.ifDisplaySpringsThenOnlyThoseFromThisVoxelIndexOrNullToDisplayAll))
					|| ((this.displayPotentialEnergyFromSelectedVsTo) && (voxB == this.ifDisplaySpringsThenOnlyThoseFromThisVoxelIndexOrNullToDisplayAll)) //TODO remove duplicate springs (a-&gt;b and b-&gt;a)
				){ //display spring
					let aa = voxA*VARSPERVOXEL;
					let bb = voxA*VARSPERVOXEL;
					let ss = s*VARSPERSPRING;
					
					//potentialEnergy of spring ranges weak to strength
					let weak = this.springs[ss+SWEAK];
					let strength = this.springs[ss+SSTRENGTH];
					
					/*
					let strength = this.springs[ss+SSTRENGTH];
					byteRectOut.paintLineYXYXRGB(
						this.voxelVar(voxA,VY),
						this.voxelVar(voxA,VX),
						this.voxelVar(voxB,VY),
						this.voxelVar(voxB,VX),
						//TODO color proportional to strength instead of the average color of the voxels
						(this.voxelVar(voxA,VRED)+this.voxelVar(voxB,VRED)), //FIXME ave /2
						(this.voxelVar(voxA,VGREEN)+this.voxelVar(voxB,VGREEN)),
						(this.voxelVar(voxA,VBLUE)+this.voxelVar(voxB,VBLUE))
					);
					*/
					let fromX = this.voxelVar(voxA,VX);
					let fromY = this.voxelVar(voxA,VY);
					let fromZ = this.voxelVar(voxA,VZ);
					let toX = this.voxelVar(voxB,VX);
					let toY = this.voxelVar(voxB,VY);
					let toZ = this.voxelVar(voxB,VZ);
					let diffX = toX-fromX;
					let diffY = toY-fromY;
					let diffZ = toZ-fromZ;
					let len = Math.hypot(diffX, diffY, diffZ);
					let numPoints = Math.ceil(len*1.5);
					for(let i=-100; i<numPoints+100; i++){ //display potentialEnergy of that spring as brightness at many points along line between voxA and voxB
					//for(let i=0; i<numPoints; i++){ //display potentialEnergy of that spring as brightness at many points along line between voxA and voxB
						//TODO optimize
						let y = Math.round(fromY+diffY*i/numPoints);
						let x = Math.round(fromX+diffX*i/numPoints);
						//let possibleLen = Math.hypot(x-fromX, y-fromY); //this only works if all points are directly between the 2 voxels, not past them.
						let possibleLen = len*i/numPoints;
						let possiblePotentialEnergy = this.potentialEnergyOfSpringIfLen(s, possibleLen);
						let possiblePotentialEnergyAsFraction = (possiblePotentialEnergy-weak)/(strength-weak);
						let brightRelToFractionRange = -this.displaySpringBrightnessSubtract + this.displaySpringContrast*possiblePotentialEnergyAsFraction; //not always a fraction
						//let brightRelToFractionRange = this.displaySpringBrightness + this.displaySpringContrast*possiblePotentialEnergy; //not always a fraction
						//brightRelToFractionRange = Math.random();
						let bright = between(0,brightRelToFractionRange*256, 255);
						bright = 255-bright; //FIXME?
						let redByte = bright;
						let greenByte = redByte;
						let blueByte = redByte;
						byteRectOut.atYXWriteRGB(y, x, redByte, greenByte, blueByte);
					}
					
					
					/*
					ByteRect.prototype.paintLineYXYXRGB = function(fromY, fromX, toY, toX, redByte, greenByte, blueByte){
						let diffY = toY-fromY;
						let diffX = toX-fromX;
						let len = Math.hypot(diffY, diffX);
						let numPoints = Math.ceil(len*1.5);
						for(let i=0; i<numPoints; i++){
							//TODO optimize
							let y = Math.round(fromY+diffY*i/numPoints);
							let x = Math.round(fromX+diffX*i/numPoints);
							this.atYXWriteRGB(y, x, redByte, greenByte, blueByte);
						}
					};*/
				}
			}
		}
		
		let aveDistDecay = between(0,colorMul*.1,1); //TODO what number?
		let springStrengthDecay = 100*aveDistDecay; //TODO what number?
		this.updateAverageDistancesAndRestLens(this.decaySAVEDIST);
		this.updateSpringStrengths(this.decaySSTRENGTH);
		this.adjustVoxelVelocitiesBySprings(dt);
		this.adjustPositionsByVelocities(this.voxels, this.voxelVels, dt);
		this.adjustVelocitiesBetweenPairsOfVoxelsBasedOnVelocitiesAlongSpringsSoIfSpringIsntChangingLengthTheresNoFriction(dt);
		let frictionMult = 1-between(0, this.decayVoxelVelocities*dt, 1);
		for(let i=0; i<this.voxelVels.length; i++) this.voxelVels[i] *= frictionMult;
		if(!this.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly){
			this.setAllVoxelPositionsAndSpeedsInZDimTo0ToBecome2d();
		}
	};
	
	//byteRectOut should already contain a copy of what came in thru webcam (after flipped andOr other transforms).
	//Some parts are painted over. Others are kept as they are.
	this.displayVoxels = function(byteRectOut){
		let donutRadius = this.testSize/2;
		for(let v=0; v<this.numVoxels; v++){
			let vv = v*VARSPERVOXEL;
			paintDonut(
				byteRectOut,
				this.voxels[vv+VY],
				this.voxels[vv+VX],
				donutRadius-2,
				donutRadius,
				this.voxels[vv+VRED],
				this.voxels[vv+VGREEN],
				this.voxels[vv+VBLUE]
			);
		}
	};
	
	this.paintChilds = function(byteRectOut, aftrans){
		for(let i in this.childs){
			let child = this.childs[i];
			let af = aftransOfAftrans(aftrans, child.aftrans);
			child.paint(byteRectOut, af);
		}
	};

	//read and write a ByteRect, which may be a wrapper of a Uint8Array or of a canvasContext.getImageData(0, 0, canvas.width, canvas.height).data.
	//This is normally called after copying webcam pixels to a canvas, then this paints some "augmented reality" stuff over it,
	//or this may completely replace it such as viewing it from a different 3d position as best it can estimate where things are in 3d from
	//recent 2d webcam inputs.
	//dt is how many seconds passed since last call,
	//regardless of actual time since you might want to simulate it slower or faster than realtime for testing or to reproduce experimental results.
	this.io = function(dt, byteRectIn, byteRectOut){
	
		this.byteRectInOriginal = byteRectIn;
		
		byteRectIn = byteRectIn.copy(); //cuz may modify byteRectIn such as edge detection.
	
		//FIXME put all graphics in .paint, but yxrgbDeriv etc does some of the graphics here.
		//For now I'm creating a paintChilds func, which will paint Balls, and calling it at end of this func.
	
		//FIXME what if byteRect is smaller than this test code uses indexs? Most code (todo all) does rectangle intersection where it hangs outside range.
		
		controls = getButtonsJoysticksEtc();
		
		if(control('eventExists')!=0){
			if(control('gamepad0_btn0')!=0){
				console.log('pushed "A" so copy selected Ball to another similar Ball but rotated, as an experiment');
				sim.childs.push(selectedOb.copyRotated());
			}
			if(control('gamepad0_btn1')){ //B button
				console.log('select newest object.');
				selectedOb = sim.childs[sim.childs.length-1];
			}else if(control('gamepad0_btn3')){
				console.log('select oldest object. TODO which button?');
				selectedOb = sim.childs[0];
			}
			control('eventExists',0); //consume the event
		}
		
		if(this.gamepadMovesAndRotatesSelectedBall && selectedOb){
			//let rotateHowMuch = 2.1*dt;
			//let resizeHowMuch = rotateHowMuch*.3;
			//let moveHowMuch = rotateHowMuch*5;
			//let af = controllerToAftrans('gamepad0', rotateHowMuch, resizeHowMuch, moveHowMuch);
			
			//let rotateHowMuch = 2.1*dt;
			//let resizeHowMuch = rotateHowMuch*.3;
			//let moveHowMuch = rotateHowMuch*5;
			selectedOb.aftrans = controllerTransformsAftrans('gamepad0', selectedOb.aftrans, dt);
			
			//selectedOb.aftrans = aftransOfAftrans(af, selectedOb.aftrans);
			//selectedOb.aftrans = aftransOfAftrans(selectedOb.aftrans, af);
			
			//selectedOb.aftrans = aftransOfAftrans(af, selectedOb.aftrans);
			//selectedOb.aftrans = transpose4x4(aftransOfAftrans(transpose4x4(selectedOb.aftrans), af));
			//selectedOb.aftrans = transpose4x4(aftransOfAftrans(transpose4x4(selectedOb.aftrans), transpose4x4(af)));
			//selectedOb.aftrans = aftransOfAftrans(transpose4x4(selectedOb.aftrans), af);
			
			//selectedOb.aftrans = aftransOfAftrans(af, selectedOb.aftrans);
			//selectedOb.aftrans = transpose4x4(aftransOfAftrans(af, transpose4x4(selectedOb.aftrans)));
			//selectedOb.aftrans = aftransOfAftrans(af, transpose4x4(selectedOb.aftrans));
			//selectedOb.aftrans = aftransOfAftrans(transpose4x4(af), transpose4x4(selectedOb.aftrans));
			
			
			//selectedOb.aftrans = aftransOfAftrans(inverse4x4(selectedOb.aftrans), af);
			//selectedOb.aftrans = inverse4x4(aftransOfAftrans(inverse4x4(selectedOb.aftrans), af));
			//selectedOb.aftrans = aftransOfAftrans(inverse4x4(af), selectedOb.aftrans);
			//selectedOb.aftrans = aftransOfAftrans(aftransOfAftrans(inverse4x4(selectedOb.aftrans),af), selectedOb.aftrans);
			//selectedOb.aftrans = aftransOfAftrans(aftransOfAftrans(selectedOb.aftrans,af), selectedOb.aftrans);
			//selectedOb.aftrans = inverse4x4(aftransOfAftrans(inverse4x4(selectedOb.aftrans), inverse4x4(af)));
			//selectedOb.aftrans = aftransOfAftrans(inverse4x4(af), selectedOb.aftrans);
			
			//selectedOb.aftrans = aftransOfAftrans(transpose4x4(af), selectedOb.aftrans);
			//selectedOb.aftrans = aftransOfAftrans(af, selectedOb.aftrans);
			//selectedOb.aftrans = transpose4x4(aftransOfAftrans(af, transpose4x4(selectedOb.aftrans)));
			//selectedOb.aftrans = transpose4x4(aftransOfAftrans(af, transpose4x4(selectedOb.aftrans)));
			//selectedOb.aftrans = aftransOfAftrans(selectedOb.aftrans,af);
		}
		
		warnIfStrangeDt(dt);
		byteRectIn.verifySameSizeAs(byteRectOut);
		
		let bytesIn = byteRectIn.bytes;
		let bytesOut = byteRectOut.bytes;
		let len = bytesIn.length;
		
		/*
		//for(let i=0; i<20000; i++) bytes[i+30000] = bytes[i];
		let offset = 0;
		for(let y=0; y<byteRect.height; y++){
			for(let x=0; x<byteRect.width/2; x+=4){
				let temp = bytes[offset+x];
				bytes[offset+x] = bytes[offset+byteRect.width-1-x];
				bytes[offset+byteRect.width-1-x] = temp;
			}
			offset += byteRect.width*4; //bytes per row of pixels
		}
		//for(let i=0; i<20000; i++) bytes[i+30000] = bytes[i];
		
		let pixs = len/4;
		//console.log('pixs='+pixs);
		for(let repeat=0; repeat<10; repeat++){
			for(let evenVsOdd=0; evenVsOdd<2; evenVsOdd++){
				for(let pix=evenVsOdd; pix<pixs-1; pix+=2){
					let j = bytes[pix*4+2];
					let k = bytes[pix*4+4+2];
					//let ave = (j+k)/2;
					let ave = Math.max(j,k); //FIXME
					//let ave = j;
					//let ave = 255;
					bytes[pix*4+2] = ave;
					bytes[pix*4+4+2] = ave;
				}
			}
		}*/
		
		/*
		let targetSum = 255;
		if(this.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU){
			//FIXME this shouldnt modify input ByteRect, but it cant do it to output ByteRect either
			//since that one doesnt get read. Move this to some preprocessing func that happens before Sim.io is called.
			if(1<2) throw 'FIXME see comment about normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU';
			//let end = pixs*4;
			let end = bytes.length;
			for(let i=0; i<end; i+=4){
				let sum = bytes[i+RED]+bytes[i+GREEN]+bytes[i+BLUE];
				let mul = targetSum/sum;
				bytes[i+RED] *= mul;
				bytes[i+GREEN] *= mul;
				bytes[i+BLUE] *= mul;
				//FIXME roundoff, as its probably a Uint8ClampedArray?
			}
		}*/
		
		if(this.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack){
			//TODO optimize: is there something like java.lang.System.arraycopy for Uint8Array and canvas pixels array in js?
			copyBytes(bytesIn, bytesOut);
		}else{
			for(let i=0; i<bytesOut.length; i+=4){
				bytesOut[i+RED] = 0;
				bytesOut[i+GREEN] = 0;
				bytesOut[i+BLUE] = 0;
				bytesOut[i+ALPHA] = 255;
			}
		}
		
		if(this.doTestCirclesDetect_oneCenterMultiSizes){
			this.testCirclesDetect_oneCenterMultiSizes(byteRectIn, byteRectOut);
		}
		
		if(this.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu){
			this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu(byteRectIn, byteRectOut);
		}
		
		if(this.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu){
			this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu_returned =
				this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu(byteRectIn, byteRectOut);
			if(this.isMoveAndResizeSelectedObToStrongestCircleFoundByGPU){
				this.moveAndResizeSelectedObToStrongestCircleFoundByGPU(); //creates this.byteRectInOriginal
				if(this.isRotateAndAdjustSphericalPicOnOfAllBallsFromBallsCurrentApproxPositionButManyPossibleRotations){
					this.rotateAndAdjustSphericalPicOnOfAllBallsFromBallsCurrentApproxPositionButManyPossibleRotations(); //reads this.byteRectInOriginal
				}
			}
		}
		
		this.voxelsAndSpringsIO(dt, byteRectIn, byteRectOut);
		
		if(this.randomlyChangeFirstBallsAftransGradually && (this.childs.length > 0)){
			for(let i=0; i<16; i++){
				this.childs[0].aftrans[i] += (Math.random()*2-1)*25*dt;
			}
		}
		
		let firstBall = this.childs[0];
		
		/*
		paint a red dot on selected ball chosen by mouse position on the main byterect (video user is watching), as if that byterect coordinates were wrapped around the ball.
		This was useful before got ball working, before could copy between the byterect and spherical image on the ball.
		if(firstBall !== undefined){ //TODO checkbox for use mouse to paint on ball or not
			//mouseYFraction = .5; //FIXME remove this
			//mouseXFraction = 0; //FIXME remove this
			let poleIndex = between(0,Math.floor(firstBall.numPoleAngles()*mouseYFraction),firstBall.numPoleAngles()-1);
			let equatorIndex = between(0,Math.floor(firstBall.numAngles*mouseXFraction),firstBall.numAngles-1);
			let baxelIndex = poleIndex*firstBall.numAngles+equatorIndex;
			//let baxelIndex = equatorIndex*firstBall.numPoleAngles()+poleIndex; //FIXME swap these 2 dims?
			//if(Math.random()<.3) console.log('poleIndex='+poleIndex+' equatorIndex='+equatorIndex+' baxelIndex='+baxelIndex
			//	+' normXYZ='+JSON.stringify(firstBall.normXYZOfBaxelIndex(baxelIndex)));
			let i = baxelIndex*VARSPERBAXEL;
			firstBall.baxels[i+BRED] = 255;//randByte();
			firstBall.baxels[i+BGREEN] = 0;//randByte();
			firstBall.baxels[i+BBLUE] = 0;//randByte();
		}*/
		
		this.paintChilds(byteRectOut, newIdentAftrans()); //FIXME only call this once in io(...)
		
		byteRectOut.writeSafeRGBA(mouseY, mouseX, 255, 255, 255);
		
		//console.log('energy='+this.energy());
		
	};
	
	/** A slow experiment (TODO GPU.js) to put a circle at screen center and have person move a ball
	that exact place to make the circle change color depending on how much edge detection is there.
	*/
	this.testCirclesDetect_oneCenterMultiSizes = function(byteRectIn, byteRectOut){
		let cx = byteRectIn.width/2;
		let cy = byteRectIn.height/2
		let minRadius = 1;
		let maxRadius = 60;		
		for(let radius=minRadius; radius<=maxRadius; radius++){
			let numPoints = Math.ceil(radius*2*Math.PI*1.7);
			let brightnessSum = 0;
			let anglePerPoint = 2*Math.PI/numPoints;
			for(let i=0; i<numPoints; i++){
				let angle = anglePerPoint*i;
				let x = cx+radius*Math.cos(angle);
				let y = cy+radius*Math.sin(angle);
				let brightObserved = byteRectIn.readBrightnessSafe(y,x);
				brightnessSum += brightObserved;
				//let brightWrite = between(0, brightObserved, 255);
				//byteRectOut.writeSafeRGBA(y, x, brightWrite, 0, 0);
			}
			let aveBrightness = brightnessSum/numPoints; //at circle
			let multiplyAveBrightness = 1.5;
			let displayBrightness = between(0, aveBrightness*multiplyAveBrightness, 255);
			let oneThirdCircle = 2/3*Math.PI;
			let twoThirdsCircle = 4/3*Math.PI;
			for(let i=0; i<numPoints; i++){
				let angle = anglePerPoint*i;
				let x = cx+radius*Math.cos(angle);
				let y = cy+radius*Math.sin(angle);
				//byteRectOut.writeSafe(y, x, RED, 255-displayBrightness);
				if((i%30) == 0){ //display spread out dots just so you know where the circle is, to move ball there
					byteRectOut.writeSafeRGBA(y, x,
						128+128*Math.sin(angle),
						128+128*Math.sin(oneThirdCircle+angle),
						128+128*Math.sin(twoThirdsCircle+angle)
					);
				}else{
					//byteRectOut.writeSafeRGBA(y, x, 0, displayBrightness, displayBrightness);
					byteRectOut.writeSafe(y, x, GREEN, displayBrightness, displayBrightness);
					//byteRectOut.writeSafeRGBA(y, x, 0, 256*i/numPoints, 255-256*i/numPoints);
				}
			}
		}
	};
	
	this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu = function(byteRectIn, byteRectOut){
	
		let maxScore = -1;
		let centerXOfCircleOfMaxScore = 0;
		let centerYOfCircleOfMaxScore = 0;
		let radiusOfCircleOfMaxScore = 0;
		
		let ccx = byteRectIn.width/2;
		let ccy = byteRectIn.height/2
		
		let howFarFromScreenCenterToLookForBall = 10;
		
		let minRadius = 20;
		let maxRadius = 50;
		for(let cy=ccy-howFarFromScreenCenterToLookForBall; cy<ccy+howFarFromScreenCenterToLookForBall; cy++){
			for(let cx=ccx-howFarFromScreenCenterToLookForBall; cx<ccx+howFarFromScreenCenterToLookForBall; cx++){
				for(let radius=minRadius; radius<=maxRadius; radius++){
					let numPoints = Math.ceil(radius*2*Math.PI*1.7);
					let brightnessSum = 0;
					let anglePerPoint = 2*Math.PI/numPoints;
					for(let i=0; i<numPoints; i++){
						let angle = anglePerPoint*i;
						let x = cx+radius*Math.cos(angle);
						let y = cy+radius*Math.sin(angle);
						let brightObserved = byteRectIn.readBrightnessSafe(y,x);
						brightnessSum += brightObserved;
						//let brightWrite = between(0, brightObserved, 255);
						//byteRectOut.writeSafeRGBA(y, x, brightWrite, 0, 0);
					}
					let aveBrightness = brightnessSum/numPoints; //at circle
					
					let score = aveBrightness; //TODO consider theres more data points in bigger circle, so stdDev relevant?
					if(maxScore < score){ //found a circle in webcam pixels thats more likely to be a ball than best found so far this video frame
						maxScore = score;
						radiusOfCircleOfMaxScore = radius;
						centerYOfCircleOfMaxScore = cy;
						centerXOfCircleOfMaxScore = cx;
					}
					
					/*
					let multiplyAveBrightness = 1.5;
					let displayBrightness = between(0, aveBrightness*multiplyAveBrightness, 255);
					let oneThirdCircle = 2/3*Math.PI;
					let twoThirdsCircle = 4/3*Math.PI;
					for(let i=0; i<numPoints; i++){
						let angle = anglePerPoint*i;
						let x = cx+radius*Math.cos(angle);
						let y = cy+radius*Math.sin(angle);
						//byteRectOut.writeSafe(y, x, RED, 255-displayBrightness);
						if((i%30) == 0){ //display spread out dots just so you know where the circle is, to move ball there
							byteRectOut.writeSafeRGBA(y, x,
								128+128*Math.sin(angle),
								128+128*Math.sin(oneThirdCircle+angle),
								128+128*Math.sin(twoThirdsCircle+angle)
							);
						}else{
							//byteRectOut.writeSafeRGBA(y, x, 0, displayBrightness, displayBrightness);
							byteRectOut.writeSafe(y, x, GREEN, displayBrightness, displayBrightness);
							//byteRectOut.writeSafeRGBA(y, x, 0, 256*i/numPoints, 255-256*i/numPoints);
						}
					}*/
				}
			}
		}
		byteRectOut.paintCircleRadiusYXRGBSafe(radiusOfCircleOfMaxScore, centerYOfCircleOfMaxScore, centerXOfCircleOfMaxScore, 255, 255, 255);
	};
	
	this.yAndXAndRadiusToAftrans = function(centerYOfCircleOfMaxScore, centerXOfCircleOfMaxScore, radiusOfCircleOfMaxScore){
		let af = newIdentAftrans();
		af[AYY] = af[AXX] = radiusOfCircleOfMaxScore;
		af[ASY] = centerYOfCircleOfMaxScore;
		af[ASX] = centerXOfCircleOfMaxScore;
		return af;
	};

	//doesnt find the right rotation. just puts it there (x, y, and radius) at some rotation.
	//TODO fix roundoff of aftrans by doing dotprod between each of 3 dims and moving opposite that .9 times that much, and repeat log cycles.
	//returns true if both of those aftrans existed, else false.
	this.moveAndResizeSelectedObToStrongestCircleFoundByGPU = function(){
		if(!selectedOb) return false;
		let aftranses = this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu_returned;
		if(!aftranses || (aftranses.length == 0)) return false; //no aftrans to move it to
		//if(aftranses.length == 0) return false; //no aftrans to move it to
		let aftrans = aftranses[0]; //TODO this should be highest scoring circle
		copyFloat32ArrayFromTo(aftrans, selectedOb.aftrans);
	};
	
	this.rotateAndAdjustSphericalPicOnOfAllBallsFromBallsCurrentApproxPositionButManyPossibleRotations = function(){
		let byteRectIn = this.byteRectInOriginal;
		if(!byteRectIn) throw 'no this.byteRectInOriginal';
		//use this.childs, check if they are Ball
		throw 'TODO use Ball.aftransBetween andOr Ball.copyRotated andOr compare2BallsAtWebcamIndex'
	};
	
	this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu_gpuKernel = null;
	//this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu_gpuKernel_jsonWasLogged = false;
	
	this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu_returned = [];
	
	/** return aftrans[] of the n strongest circles found. As of 2021-8-31, n is 1, but planning to support up to 20 balls webcam sees at once.
	TODO sort by descending score.
	*/
	this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu = function(byteRectIn, byteRectOut){
	
		if(!this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu_gpuKernel){
			this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu_gpuKernel =
				gpu().createKernel(function(xyBrightFloats, height, width, yFrom, xFrom, radiusFrom, radiusToExcl, pointsPerCircle){
					const cy = yFrom+this.thread.y;
					const cx = xFrom+this.thread.x;
					let maxScore = -1;
					let radiusOfCircleOfMaxScore = 0;
					for(let radius=radiusFrom; radius<radiusToExcl; radius++){
						//let numPoints = Math.ceil(radius*2*Math.PI*1.7);
						let brightnessSum = 0;
						let anglePerPoint = 2*Math.PI/pointsPerCircle;
						for(let i=0; i<pointsPerCircle; i++){
							let angle = anglePerPoint*i;
							let x = Math.floor(cx+radius*Math.cos(angle));
							let y = Math.floor(cy+radius*Math.sin(angle));
							//let brightObserved = byteRectIn.readBrightnessSafe(y,x);
							
							//FIXME dont let this go past the 4 edges of the rectangle pic in 1d xyBrightFloats
							
							let brightObserved = xyBrightFloats[y*width+x];
							brightnessSum += brightObserved;
							//let brightWrite = between(0, brightObserved, 255);
							//byteRectOut.writeSafeRGBA(y, x, brightWrite, 0, 0);
						}
						let aveBrightness = brightnessSum/pointsPerCircle; //at circle
						
						//let score = aveBrightness; //TODO consider theres more data points in bigger circle, so stdDev relevant?
						
						//let radiusScore = Math.log(radius); //slight preference for bigger
						let radiusScore = Math.pow(Math.log(radius),1.5);
						let score = aveBrightness*radiusScore;
						
						
						if(maxScore < score){ //found a circle in webcam pixels thats more likely to be a ball than best found so far this video frame
							maxScore = score;
							radiusOfCircleOfMaxScore = radius;
						}
					}
					
					//maxScore = xyBrightFloats[cy*width+cx]; //FIXME remove this
					//maxScore = cx+cy; //FIXME remove this
					
					return [radiusOfCircleOfMaxScore, maxScore];
				},{
					dynamicOutput: true
				});
		}
		
	
		let monochromePicAsFloats = byteRectIn.brightnessFloats(); //monochromePicAsFloats.length*4 == byteRectIn.length
		let h = byteRectIn.height;
		let w = byteRectIn.width;
		
		let ccx = Math.floor(w/2);
		let ccy = Math.floor(h/2);
		
		
		let howFarFromScreenCenterToLookForBall = 100; //TODO whole byteRectIn size (half of that both directions) but careful not to go off edges
		//let howFarFromScreenCenterToLookForBall = 30; //TODO whole byteRectIn size (half of that both directions) but careful not to go off edges
		let yFrom = ccy-howFarFromScreenCenterToLookForBall;
		let yToExcl = ccy+howFarFromScreenCenterToLookForBall;
		let xFrom = ccx-howFarFromScreenCenterToLookForBall;
		let xToExcl = ccx+howFarFromScreenCenterToLookForBall;
		let yRange = yToExcl-yFrom;
		let xRange = xToExcl-xFrom;
		let radiusFrom = 20;
		let radiusToExcl = 51;
		let pointsPerCircle = Math.ceil((radiusToExcl-1)*2*Math.PI*1.7);
		
		//FIXME is it [yRange, xRange] or [xRange, yRange]? Check which order it is in setOutput vs this.thread.x and this.thread.y
		this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu_gpuKernel.setOutput([xRange, yRange]);
		
		//gpuOut[y-yFrom][x-xFrom][0 for radius of max score circle at that y x, or 1 for max score]
		let gpuOut = this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu_gpuKernel(
			monochromePicAsFloats, h, w, yFrom, xFrom, radiusFrom, radiusToExcl, pointsPerCircle);
		
		/*if(!this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu_gpuKernel_jsonWasLogged){
			//test gpujs toJSON. It works, but is bigger than I want logged to console (24kB)
			this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu_gpuKernel_jsonWasLogged = true;
			console.log('First call of kernel: '+JSON.stringify(this.testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu_gpuKernel.toJSON()));
		}*/
			
		let centerYOfCircleOfMaxScore = 0;
		let centerXOfCircleOfMaxScore = 0;
		let radiusOfCircleOfMaxScore = 0;
			
		let minScore = Infinity;
		let maxScore = -Infinity;
		for(let cy=yFrom; cy<yToExcl; cy++){
			for(let cx=xFrom; cx<xToExcl; cx++){
				let bestScoreAtYX = gpuOut[cy-yFrom][cx-xFrom][1];
				minScore = Math.min(minScore,bestScoreAtYX);
				if(maxScore < bestScoreAtYX){
					maxScore = bestScoreAtYX;
					centerYOfCircleOfMaxScore = cy;
					centerXOfCircleOfMaxScore = cx;
					let bestRadiusAtYX = gpuOut[cy-yFrom][cx-xFrom][0];
					radiusOfCircleOfMaxScore = bestRadiusAtYX;
				}
			}
		}
		if(minScore >= maxScore){
			console.log('WARNING: minScore='+minScore+' maxScore='+maxScore+' so ending early testCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu');
			return;
		}

		for(let cy=yFrom; cy<yToExcl; cy++){
			for(let cx=xFrom; cx<xToExcl; cx++){
				let bestRadiusAtYX = gpuOut[cy-yFrom][cx-xFrom][0];
				let bestScoreAtYX = gpuOut[cy-yFrom][cx-xFrom][1];
				let normedBestScoreAtYX = (bestScoreAtYX-minScore)/(maxScore-minScore); //0..1
				let displayBright = normedBestScoreAtYX*255.999;
				//display circle center as brightest, of many possible circle centers, proportional to score for how much it might be a circle
				//byteRectOut.writeSafe(cy, cx, BLUE, displayBright);
				byteRectOut.writeSafeBright(cy, cx, displayBright);
			}
		}
		
		byteRectOut.paintCircleRadiusYXRGBSafe(radiusOfCircleOfMaxScore, centerYOfCircleOfMaxScore, centerXOfCircleOfMaxScore, 255, 255, 255);
		
		return [this.yAndXAndRadiusToAftrans(centerYOfCircleOfMaxScore, centerXOfCircleOfMaxScore, radiusOfCircleOfMaxScore)];
		
		
		/*
		Tested this in another file, "return [sum, sum*2, sum*sum, sum*10];" where sum var exists in kernel,
		does create a 3d array, when output size is set to 2d, of that many Float32Array(4).
		
		FIXME should it return 2 (radius,score) of 2d (x, y, just find the best circle centered there of all radius)
			or 1 (score) of 3d (x, y, radius)?
		3d could be an IO bottleneck (if doing the whole video size), even though its a 4d amount of compute.
		
		how to get 2 output numbers per gpu thread? I want to return radius and score. 
		Score may just be ave brightness at the circle, but I'll need to tune that to prefer bigger circles,
		and maybe also to prefer circles which are touching more yellow (tennis ball colored) pixels,
		by trying other equations.
		
		Found this: https://github.com/gpujs/gpu.js/issues/405 "Return more than one value in the main kernel. #405"
		 -&gt; "This is solved in v2 rc13.". Which one did they mean in https://github.com/gpujs/gpu.js/releases ?
		or did they mean 2.0 rc13 (release candidate for version 2)?
		Also https://github.com/gpujs/gpu.js/issues/397
		
		https://github.com/gpujs/gpu.js says...
		
		Declaring variables/functions within kernels

		GPU.js makes variable declaration inside kernel functions easy. Variable types supported are:

			Number (Integer or Number), example: let value = 1 or let value = 1.1
			Boolean, example: let value = true
			Array(2), example: let value = [1, 1]
			Array(3), example: let value = [1, 1, 1]
			Array(4), example: let value = [1, 1, 1, 1]
			private Function, example: function myFunction(value) { return value + 1; }

		Number kernel example:

		const kernel = gpu.createKernel(function() {
		 const i = 1;
		 const j = 0.89;
		 return i + j;
		}).setOutput([100]);

		Boolean kernel example:

		const kernel = gpu.createKernel(function() {
		  const i = true;
		  if (i) return 1;
		  return 0;
		}).setOutput([100]);

		Array(2) kernel examples: Using declaration

		const kernel = gpu.createKernel(function() {
		 const array2 = [0.08, 2];
		 return array2;
		}).setOutput([100]);

		Directly returned

		const kernel = gpu.createKernel(function() {
		 return [0.08, 2];
		}).setOutput([100]);

		Array(3) kernel example: Using declaration

		const kernel = gpu.createKernel(function() {
		 const array2 = [0.08, 2, 0.1];
		 return array2;
		}).setOutput([100]);

		Directly returned

		const kernel = gpu.createKernel(function() {
		 return [0.08, 2, 0.1];
		}).setOutput([100]);

		Array(4) kernel example: Using declaration

		const kernel = gpu.createKernel(function() {
		 const array2 = [0.08, 2, 0.1, 3];
		 return array2;
		}).setOutput([100]);

		Directly returned

		const kernel = gpu.createKernel(function() {
		 return [0.08, 2, 0.1, 3];
		}).setOutput([100]);

		private Function kernel example:

		const kernel = gpu.createKernel(function() {
		  function myPrivateFunction() {
			return [0.08, 2, 0.1, 3];
		  }
		  
		  return myPrivateFunction(); // <-- type inherited here
		}).setOutput([100]);
		*/
		
		
		
		
		
		
		
		
	
		/*
		let maxScore = -1;
		let centerXOfCircleOfMaxScore = 0;
		let centerYOfCircleOfMaxScore = 0;
		let radiusOfCircleOfMaxScore = 0;
		
		let ccx = byteRectIn.width/2;
		let ccy = byteRectIn.height/2
		
		let howFarFromScreenCenterToLookForBall = 10;let howFarFromScreenCenterToLookForBall = 10;
		
		let minRadius = 20;
		let maxRadius = 50;
		for(let cy=yFrom; cy<yToExcl; cy++){
			for(let cx=xFrom; cx<xToExcl; cx++){
				for(let radius=minRadius; radius<=maxRadius; radius++){
					let numPoints = Math.ceil(radius*2*Math.PI*1.7);
					let brightnessSum = 0;
					let anglePerPoint = 2*Math.PI/numPoints;
					for(let i=0; i<numPoints; i++){
						let angle = anglePerPoint*i;
						let x = cx+radius*Math.cos(angle);
						let y = cy+radius*Math.sin(angle);
						let brightObserved = byteRectIn.readBrightnessSafe(y,x);
						brightnessSum += brightObserved;
						//let brightWrite = between(0, brightObserved, 255);
						//byteRectOut.writeSafeRGBA(y, x, brightWrite, 0, 0);
					}
					let aveBrightness = brightnessSum/numPoints; //at circle
					
					let score = aveBrightness; //TODO consider theres more data points in bigger circle, so stdDev relevant?
					if(maxScore < score){ //found a circle in webcam pixels thats more likely to be a ball than best found so far this video frame
						maxScore = score;
						radiusOfCircleOfMaxScore = radius;
						centerYOfCircleOfMaxScore = cy;
						centerXOfCircleOfMaxScore = cx;
					}
				}
			}
		}
		byteRectOut.paintCircleRadiusYXRGBSafe(radiusOfCircleOfMaxScore, centerYOfCircleOfMaxScore, centerXOfCircleOfMaxScore, 255, 255, 255);
		*/
		
		
	};
	
	//Example: sim.springVar(17, 30, SFRICTION) returns the friction of the spring between 2 voxels whose indexs are 17 and 30.
	//If writeVal optional param is given, writes the var, else just reads it. either way returns its val at the end.
	//This is only for a few small things here and there, not nearly as efficient as using GPU.js or a loop over the Float32Arrays.
	this.springVar = function(voxA, voxB, whichSpringVar, writeVal){
		let index = this.springVarIndex(voxA,voxB,whichSpringVar);
		if(writeVal !== undefined) this.springs[index] = writeVal; //TODO use between(...) to truncate into allowed range per which*var?
		return this.springs[index];
	};

	this.springVarIndex = function(voxA, voxB, whichSpringVar){
		return (voxA*this.numVoxels+voxB)*VARSPERSPRING+whichSpringVar;
	};
	
	//like springVar(...), can read or write the var.
	this.voxelVar = function(vox, whichVoxelVar, writeVal){
		let index = this.voxelVarIndex(vox,whichVoxelVar);
		if(writeVal !== undefined) this.voxels[index] = writeVal; //TODO use between(...) to truncate into allowed range per which*var?
		return this.voxels[index];
	};
	
	//like springVar(...), can read or write the var.
	this.voxelVelVar = function(vox, whichVoxelVar, writeVal){
		let index = this.voxelVarIndex(vox,whichVoxelVar);
		if(writeVal !== undefined) this.voxelVels[index] = writeVal; //TODO use between(...) to truncate into allowed range per which*var?
		return this.voxelVels[index];
	};
	
	//returns index for this.voxels (positions) and this.voxelVels (velocities)
	this.voxelVarIndex = function(vox, whichVoxelVar){
		return vox*VARSPERVOXEL+whichVoxelVar;
	};

	/** Range sweak to sstrength. 0 <= spr < this.numSprings.
	UPDATE: Going to use a potentialEnergy equation thats same as spring when near atRestLen (is a parabola) but is sigmoidlike when gets farther away.
	OLD: "elastic potential energy = 0.5 × spring constant × (extension)^2" -- https://www.bbc.co.uk/bitesize/guides/z9hk3k7/revision/3
	*/
	this.potentialEnergyOfSpring = function(spr){
		//TODO optimize, should this func take 2 voxel indexs instead?
		return this.potentialEnergyOfSpringIfLen(spr, this.distanceSpring(spr));
	};
	
	//aka force (if mass is 1, and as of 2021-7-25 it always is, then this is also acceleration)
	this.potentialEnergyDerivativeOfSpring = function(spr){
		return this.potentialEnergyDerivativeOfSpringIfLen(spr, this.distanceSpring(spr));
	};
	
	//at a possible distance between 2 voxels: aka force (if mass is 1, and as of 2021-7-25 it always is, then this is also acceleration)
	this.potentialEnergyDerivativeOfSpringIfLen = function(spr, len){
		//let epsilon = len*EPSILON; //Are the nans caused by epsilon being 0 cuz epsilon is caled by len of 0?
		let epsilon = Math.max(len,1)*EPSILON;
		return (this.potentialEnergyOfSpringIfLen(spr,len+epsilon)-this.potentialEnergyOfSpringIfLen(spr,len))/epsilon;
	};
	
	//0 <= spr < this.numSprings.
	//len is any nonnegative number, such as distance between 2 voxels or that plus an epsilon,
	//or (TODO, if needed?) various possible lengths explored by harmonySearch of possible next voxel velocities.
	//FIXME a spring from voxel to itself, as of 2021-7-25, is getting NaN potentialenergy. why? Are the nans caused by epsilon being 0 cuz epsilon is caled by len of 0?
	this.potentialEnergyOfSpringIfLen = function(spr, len){
		if(len == 0) return 0; //FIXME should be [...sstrength]? this is to get rid of those nans. Are the nans caused by epsilon being 0 cuz epsilon is caled by len of 0?
		
		
		//FIXME What about duplicate springs (only need numVoxels*(numVoxels-1)/2 springs, if dense, and much less if sparse)?
		let ss = spr*VARSPERSPRING;
		
		//UPDATE: potentialEnergy of spring ranges SWEAK to SSTRENGTH, so strength scales it around weak.
		//OLD: strength 0 means spring does not exist. strength scales the potentialEnergy added by this spring.
		let weak = this.springs[ss+SWEAK];
		let strength = this.springs[ss+SSTRENGTH];
		if((weak < 0) || (strength < weak)) throw 'weak='+weak+' strength='+strength;
		
		//proportional (mult by strength) max potentialEnergy everywhere on the curve of this spring.
		let downfrom = this.springs[ss+SDOWNFROM];
		/*FIXME use downfrom andOr heat? how about that diffeq of how much to add to heat based on a position and a dt andOr and maybe also velocity?
		FIXME the potentialEnergyOfSpring needs to be duplicated, unless its called twice with epsilon difference of restlen,
			duplicated in the code that actually adjusts velocities of voxels (movebysprings or something like that, what was it called?).
		FIXME should there be a gravity param?
		FIXME somewhere else, change springvars each physics cycle in a way that doesnt change its potentialEnergy at that position.
		*/
		
		//similar to stdDev of a bellcurve but its more like 1/(1+x^2) and if it where that equation then sWide is 1 cuz
		//half the "area under the curve" of that is in -1..1. The actual equation is scaled differently and subtracted
		//from SDOWNFROM (so is vertically flipped) and has something added to repel voxels which are too near.
		let swide = this.springs[ss+SWIDE];
		
		//restlen is like the bellcurve average, if swide is like the stdDev, even though its not a bellcurve only slightly similar shape.
		let restLen = this.springs[ss+SRESTLEN];
		
		let lenDiff = restLen-len;
		let lenDiff_over_swide = lenDiff/swide;
		//let lenDiff_over_swide = lenDiff*swide; //FIXME rename this var, but it seems that swide needs to be used as 1/swide cuz of the way the parabola is defined in 1/(1+...)
		
		//range 0 (if len==Infinity) to 1 (if len==0). Is .5 at repelMidDist.
		//Its important that min and max possible potentialEnergy be known, so things like 1/len are not allowed.
		let lenOverRepelmiddist = len/this.repelMidDist;
		let repelCurve = 1/(1+lenOverRepelmiddist*lenOverRepelmiddist);
		
		//range 0 (if len==restLen) to 1 (limit as Math.abs(len-restLen) --&gt; Infinity).
		//is a parabola near lenDiff==0, and farther away levels off to have derivative approaching 0.
		let springCurve = 1-1/(1+lenDiff_over_swide*lenDiff_over_swide);
		
		let weightDivide = 1+this.repelTimesMoreThanSpring;
		let springWeight = 1/weightDivide;
		let repelWeight = this.repelTimesMoreThanSpring/weightDivide;
		//springWeight+repelWeight==1 (except roundoff)
		
		//range 0 to 1
		let combinedCurve = springWeight*springCurve + repelWeight*repelCurve;
		
		//let potentialEnergy = .5*this.springs[ss+SSTRENGTH]*lenDiff*lenDiff; //normal spring physics
		
		//range SWEAK to SSTRENGTH
		let potentialEnergy = weak+(strength-weak)*combinedCurve; //Like 1/(1+x^2)+repel except scaled a few ways, a potentialEnergy func.
		
		//in case roundoff puts it slightly outside allowed range.
		potentialEnergy = between(weak, potentialEnergy, strength);
		
		return potentialEnergy;
	};
	
	/** returns a ByteRect, does not modify param ByteRect. maxDotSize is max distance from any part of the dot to any other part (diameter-like).
	Truncates maxDotSize if too small or big.
	TODO As a cellularAutomata, it changes color of each pixel to whichever pixel is the nearest color to that.
	TODO Then it shrinks all the small blobs of same color to a single pixel.
	TODO after that in a different function (todo which one?), it changes similar colored dots to the same color as eachother.
		A ball should have colors of dots (drawn from the same 2 ink markers on the tennis ball, about 100 of each color of dot randomly soread.)
		That should allow that ball to be uniquely identified when multiple balls are on screen.
	*/
	this.findDots = function(byterect, maxDotSize){
		//maxDotSize = betweenInt(1, maxDotSize, 20);
		maxDotSize = betweenInt(1, maxDotSize, 200);
		//if((maxDotSize < 1) || (100 < maxDotSize)) throw 'maxDotSize='+maxDotSize;
		//if(20 < maxDotSize) console.log('WARNING: maxDotSize='+maxDotSize+' which could be slow, and dots are supposed to be small');
		byterect = byterect.copy();
		let h = byterect.height;
		let w = byterect.width;
		let dx = 4; //cross this many bytes to move 1 in x
		let dy = w*4; //cross this many bytes to move 1 in y
		//let adjacents = [-dy-dx, -dy, -dy+dx, -dx, dx, dy-dx, dy, dy+dx]; //FIXME should this be fewer adjacent pixels (could be 2, 4, or 8 adjacents)
		let adjacents = [-dy, -dx, dx, dy]; //FIXME should this be fewer adjacent pixels (could be 2, 4, or 8 adjacents)
		let loopSize = maxDotSize*2; //*2 cuz alternates parity of manhattanDistance like a checkerboard only changing half its squares at once.
		//loopSize = 1;
		let bytes = byterect.bytes;
		for(let i=0; i<loopSize; i++){
			//let loopParity = (i&1); //0 or 1
			//let byteStart = dx+dy+parity*4
			//let byteEnd = bytes.length-dx-dy;
			//for(let j=byteStart; j<byteEnd; j+=8){ //+=8 crosses 2 pixels
			for(let y=1; y<h-1; y++){
				//parity = 1-parity;
				//let yParity = (y&1);
				let parity = (i+y)&1;
				for(let x=1+parity; x<w-1; x+=2){ //checkerboard excluding a border size 1
					let j = (y*w+x)*4;
					let redHere = bytes[j+RED];
					let greenHere = bytes[j+GREEN];
					let blueHere = bytes[j+BLUE];
					let smallestColorDiffSquared = 1000000;
					let redOfMostSimilarAdjacentColor = 0;
					let greenOfMostSimilarAdjacentColor = 0;
					let blueOfMostSimilarAdjacentColor = 0;
					
					
					/*
					let smallestColorDiffSquared = 0; //FIXME
					let redOfMostSimilarAdjacentColor = redHere; //FIXME
					let greenOfMostSimilarAdjacentColor = greenHere; //FIXME
					let blueOfMostSimilarAdjacentColor = blueHere; //FIXME
					*/
					
					
					for(let k=0; k<adjacents.length; k++){
						let otherPixelByteIndex = j+adjacents[k];
						let redOfOtherColor = bytes[otherPixelByteIndex+RED];
						let greenOfOtherColor = bytes[otherPixelByteIndex+GREEN];
						let blueOfOtherColor = bytes[otherPixelByteIndex+BLUE];
						let redDiff = redOfOtherColor-redHere;
						let greenDiff = greenOfOtherColor-greenHere;
						let blueDiff = blueOfOtherColor-blueHere;
						let colorDiffSquared = redDiff*redDiff + greenDiff*greenDiff + blueDiff*blueDiff;
						//if(colorDiffSquared < smallestColorDiffSquared){
						//if(colorDiffSquared > smallestColorDiffSquared){
						if(Math.random()<.3){
							smallestColorDiffSquared = colorDiffSquared;
							redOfMostSimilarAdjacentColor = redOfOtherColor;
							greenOfMostSimilarAdjacentColor = greenOfOtherColor;
							blueOfMostSimilarAdjacentColor = blueOfOtherColor;
						}
					}
					bytes[j+RED] = redOfMostSimilarAdjacentColor;
					bytes[j+GREEN] = greenOfMostSimilarAdjacentColor;
					bytes[j+BLUE] = blueOfMostSimilarAdjacentColor;
				}
			}
		}
		return byterect;
	};
	
	this.findEdgesAndKeepTheirColor_modifyByterect = function(byterect, minColorDiffFractionToBeADot){
		let h = byterect.height;
		let w = byterect.width;
		let lastX = w-1;
		let lastY = h-1;
		let maxManhat = h+w; //manhattanDistance from one corner to opposite corner
		let bytes = byterect.bytes;
		let dx = 4; //cross this many bytes to move 1 in x
		let dy = w*4; //cross this many bytes to move 1 in y
		let minColorDiff6dSquaredToBeADot = minColorDiffFractionToBeADot*6*255*255;
		for(let manhat=0; manhat<=maxManhat; manhat++){
			//TODO optimize by not using multiply here, just add a constant to the pixel index in the inner loop.
			//for(let y=manhat; y>=0; y++){
			for(let y=manhat; y>=0; y--){
				let x = manhat-y;
				let writeRed = 0;
				let writeGreen = 0;
				let writeBlue = 0;
				let offset = (y*w+x)*4;
				if((x != lastX) && (y != lastY)){
					let horiz = offset+dx;
					let vert = offset+dy;
					let redHere = bytes[offset+RED];
					let greenHere = bytes[offset+GREEN];
					let blueHere = bytes[offset+BLUE];
					let redDiffHoriz = redHere-bytes[horiz+RED]; //-255..255
					let greenDiffHoriz = greenHere-bytes[horiz+GREEN]; //-255..255
					let blueDiffHoriz = blueHere-bytes[horiz+BLUE]; //-255..255
					let redDiffVert = redHere-bytes[vert+RED]; //-255..255
					let greenDiffVert = greenHere-bytes[vert+GREEN]; //-255..255
					let blueDiffVert = blueHere-bytes[vert+BLUE]; //-255..255
					let colorDiff6dSquared =
						redDiffHoriz*redDiffHoriz
						+ greenDiffHoriz*greenDiffHoriz
						+ blueDiffHoriz*blueDiffHoriz
						+ redDiffVert*redDiffVert
						+ greenDiffVert*greenDiffVert
						+ blueDiffVert*blueDiffVert;
					if(minColorDiff6dSquaredToBeADot <= colorDiff6dSquared){
						writeRed = redHere;
						writeGreen = greenHere;
						writeBlue = blueHere;
					}//else black
				}
				bytes[offset+RED] = writeRed;
				bytes[offset+GREEN] = writeGreen;
				bytes[offset+BLUE] = writeBlue;
				//bytes[offset+ALPHA] is probably already 255 (visible), leave it as it is
			}
			
		}
	};
	
	//does not modify byteRect. returns a new one.
	this.doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls = function(byteRect){
		let inb = byteRect.bytes;
		let ret = new ByteRect(new Uint8Array(byteRect.bytes.length), byteRect.height, byteRect.width);
		let retb = ret.bytes;
		for(let i=ALPHA; i<retb.length; i+=4) retb[i] = 255; //visible
		let muly = ret.width*4;
		let mulx = 4;
		let border = 1;
		
		for(let y=border; y<ret.height-border; y++){
			let byteIndex = y*muly;
			//for(let x=border; x<xEnd; x++){
			for(let x=border; x<ret.width-border; x++){
				
				/*
				let hereRed = inb[byteIndex+RED];
				let hereGreen = inb[byteIndex+GREEN]
				let hereBlue = inb[byteIndex+BLUE];
				let sumOfSquaredDiffs = 0;
				let sumWeights = 0;
				for(let dy=-border; dy<=border; dy++){
					for(let dx=-border; dx<=border; dx++){
						let thereIndex = byteIndex + muly*dy + mulx*dx;
						let thereRed = inb[thereIndex+RED]; //when dx==0 and dy==0, here is there.
						let thereGreen = inb[thereIndex+GREEN];
						let thereBlue = inb[thereIndex+BLUE];
						let redDiff = hereRed-thereRed;
						let greenDiff = hereGreen-thereGreen;
						let blueDiff = hereBlue-thereBlue;
						let weight = ((dx==0) && (dy==0)) ? 0 : (1/(dx*dx + dy*dy));
						//let weight = ((dx==0) && (dy==0)) ? 0 : (1/Math.hypot(dx,dy));
						sumOfSquaredDiffs += weight*(redDiff*redDiff + greenDiff*greenDiff + blueDiff*blueDiff);
						sumWeights += weight;
					}
				}
				let aveSquaredDiff = sumOfSquaredDiffs/sumWeights;
				//let aveSquaredDiff = sumOfSquaredDiffs/(border*border-1); //-1 to not count when dx==0 and dy==0
				let bright = aveSquaredDiff*.05;
				//let bright = aveSquaredDiff*.14;
				*/
				
				
				let dxdred = inb[byteIndex+RED]-inb[byteIndex-mulx+RED];
				let dxdgreen = inb[byteIndex+GREEN]-inb[byteIndex-mulx+GREEN];
				let dxdblue = inb[byteIndex+BLUE]-inb[byteIndex-mulx+BLUE];
				let dydred = inb[byteIndex+RED]-inb[byteIndex-muly+RED];
				let dydgreen = inb[byteIndex+GREEN]-inb[byteIndex-muly+GREEN];
				let dydblue = inb[byteIndex+BLUE]-inb[byteIndex-muly+BLUE];
				let dxydred = inb[byteIndex+RED]-inb[byteIndex-muly-mulx+RED];
				let dxydgreen = inb[byteIndex+GREEN]-inb[byteIndex-muly-mulx+GREEN];
				let dxydblue = inb[byteIndex+BLUE]-inb[byteIndex-muly-mulx+BLUE];
				let dxydred2 = inb[byteIndex+RED]-inb[byteIndex-muly+mulx+RED];
				let dxydgreen2 = inb[byteIndex+GREEN]-inb[byteIndex-muly+mulx+GREEN];
				let dxydblue2 = inb[byteIndex+BLUE]-inb[byteIndex-muly+mulx+BLUE];
				let colorDiffSquared = dxdred*dxdred + dxdgreen*dxdgreen + dxdblue*dxdblue
					+ dydred*dydred + dydgreen*dydgreen + dydblue*dydblue
					+ dxydred*dxydred + dxydgreen*dxydgreen + dxydblue*dxydblue
					+ dxydred2*dxydred2 + dxydgreen2*dxydgreen2 + dxydblue2*dxydblue2;
				//let bright = between(0, colorDiffSquared*.02, 255);
				let bright = between(0, colorDiffSquared*.1, 255);
				
				
				//let bright = between(0, colorDiffSquared*.02, 255);
				//let bright = between(0, Math.sqrt(colorDiffSquared)*5, 255);
				
				let retRed = bright;
				let retGreen = bright;
				let retBlue = bright;
				retb[byteIndex+RED] = retRed;
				retb[byteIndex+GREEN] = retGreen;
				retb[byteIndex+BLUE] = retBlue;
				byteIndex += 4; //optimize using += 4 instead of *muly  and *mulx
			}
		}
		
		
		/*let border = 3;
		//let weights = []; //size (border+1+border)^2. A convolutional weightedSum at each pixel not too near byteRect edges.
		//for(let dy=-border; dy<=border; dy++){
		//	for(let dx=-border; dx<=border; dx++){
		//		weights.push(TODO);
		//	}
		//}
		for(let y=border; y<yEnd; y++){
			let byteIndex = y*muly;
			//for(let x=border; x<xEnd; x++){
			for(let x=border; x<xEnd; x++){
				let retRed = 0;
				let retGreen = 0;
				let retBlue = 0;
				FIXME
				retb[byteIndex+RED] = retRed;
				retb[byteIndex+GREEN] = retGreen;
				retb[byteIndex+BLUE] = retBlue;
				byteIndex += 4; //optimize using += 4 instead of *muly  and *mulx
			}
		}
		*/
		
		return ret;
	};
	
	this.doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_kernel = null;
	
	//func of ByteRect.bytes to Float32Array (size bytes.length/4) of edge detection.
	//Unlike doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls which returns ByteRect,
	//this returns Float32Array (UPDATE: returnByterectElseFloats).
	this.doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu = function(byteRect, returnByterectElseFloats, allowBytesIntoGpu){
		//FIXME can gpujs return Uint8ClampedArray? Or just Uint8Array? Which do I prefer? Uint8Array is probably faster, and just takes the low 8 bits.
		//https://github.com/gpujs/gpu.js/issues/441
	
		//func of ByteRect.bytes to Float32Array (size bytes.length/4) of edge detection.
		if(!this.doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_kernel){
			this.doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_kernel =
				gpu().createKernel(function(inb, height, width){
					
					const RED = this.constants.RED;
					const GREEN = this.constants.GREEN;
					const BLUE = this.constants.BLUE;
					
					const y = this.thread.y;
					const x = this.thread.x;
					const muly = width*4;
					const mulx = 4;
					let bright = 0;
					//let retRed = 0;
					//let retGreen = 0;
					//let retBlue = 0;
					//let retAlpha = 255; //visible
					if((1 <= x) && (x < (width-1)) && (1 <= y) && (y < (height-1))){
						let byteIndex = (width*y+x)*4;
						let dxdred = inb[byteIndex+RED]-inb[byteIndex-mulx+RED];
						let dxdgreen = inb[byteIndex+GREEN]-inb[byteIndex-mulx+GREEN];
						let dxdblue = inb[byteIndex+BLUE]-inb[byteIndex-mulx+BLUE];
						let dydred = inb[byteIndex+RED]-inb[byteIndex-muly+RED];
						let dydgreen = inb[byteIndex+GREEN]-inb[byteIndex-muly+GREEN];
						let dydblue = inb[byteIndex+BLUE]-inb[byteIndex-muly+BLUE];
						let dxydred = inb[byteIndex+RED]-inb[byteIndex-muly-mulx+RED];
						let dxydgreen = inb[byteIndex+GREEN]-inb[byteIndex-muly-mulx+GREEN];
						let dxydblue = inb[byteIndex+BLUE]-inb[byteIndex-muly-mulx+BLUE];
						let dxydred2 = inb[byteIndex+RED]-inb[byteIndex-muly+mulx+RED];
						let dxydgreen2 = inb[byteIndex+GREEN]-inb[byteIndex-muly+mulx+GREEN];
						let dxydblue2 = inb[byteIndex+BLUE]-inb[byteIndex-muly+mulx+BLUE];
						let colorDiffSquared = dxdred*dxdred + dxdgreen*dxdgreen + dxdblue*dxdblue
							+ dydred*dydred + dydgreen*dydgreen + dydblue*dydblue
							+ dxydred*dxydred + dxydgreen*dxydgreen + dxydblue*dxydblue
							+ dxydred2*dxydred2 + dxydgreen2*dxydgreen2 + dxydblue2*dxydblue2;
						//let bright = between(0, colorDiffSquared*.1, 255);
						//bright = Math.max(0, Math.min(colorDiffSquared*.1, 255));
						bright = Math.max(0, Math.min(colorDiffSquared*.3, 255));
						
						//retRed = bright;
						//retGreen = bright;
						//retBlue = bright;
						//byteIndex += 4; //optimize using += 4 instead of *muly  and *mulx
					}
					//retb[byteIndex+RED] = retRed;
					//retb[byteIndex+GREEN] = retGreen;
					//retb[byteIndex+BLUE] = retBlue;
					//retb[byteIndex+ALPHA] = retAlpha;
					//return [retRed, retGren, retBlue, retAlpha];
					
					
					//FIXME
					//bright = inb[byteIndex+RED];
					//bright = Math.random();
					
					return bright;
				},{
					constants: {RED: RED, GREEN: GREEN, BLUE: BLUE},
					dynamicOutput: true,
					precision: 'unsigned' //recommended in https://github.com/gpujs/gpu.js/issues/441 for getting Uint8Array out
				});
		}
		
		//let inb = byteRect.bytes;
		//let ret = new ByteRect(new Uint8Array(byteRect.bytes.length), byteRect.height, byteRect.width);
		//let retb = ret.bytes;
		//for(let i=ALPHA; i<retb.length; i+=4) retb[i] = 255; //visible
		
		//FIXME its 2d in, of that kernel
		//this.doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_kernel.setOutput([byteRect.bytes.length/4]);
		
		this.doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_kernel.setOutput([byteRect.width, byteRect.height]); //FIXME swap width/height?
		
		let pixelsIntoGpu = allowBytesIntoGpu ? byteRect.bytes: bytesToFloats(byteRect.bytes);
		
		let gpuOut = this.doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_kernel(
			pixelsIntoGpu, byteRect.height, byteRect.width);
			
		let gpuOutAs1d = floats2dToFloats1d(gpuOut); //TODO optimize by not requiring this copy
		
		if(returnByterectElseFloats){
			return floatsAsMonochromeToPic(gpuOutAs1d, byteRect.height, byteRect.width); //ByteRect
		}else{
			return gpuOutAs1d; //Float32Array
		}
	};
	
	/** modifies byteRect so that any (rowOrCol,colorDim) which exceeds ave brightLimit, all those bytes are set to 0,
	for RED, GREEN, and BLUE colordims but not ALPHA.
	Removes rows or cols where more (or equalormore?) than fractionLimit fraction (0..1) of pixels (in same color dim)
	are at least brightness brightLimit (0..255)
	*/
	this.preprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic = function(byteRect, brightLimit, fractionLimit){
		//let colorDims = [RED, GREEN, BLUE]; //not ALPHA
		//let colorDims = [RED]; //FIXME
		
		let colsRedFraction = new Float32Array(byteRect.width);
		let colsGreenFraction = new Float32Array(byteRect.width);
		let colsBlueFraction = new Float32Array(byteRect.width);
		let rowsRedFraction = new Float32Array(byteRect.height);
		let rowsGreenFraction = new Float32Array(byteRect.height);
		let rowsBlueFraction = new Float32Array(byteRect.height);
		
		for(let y=0; y<byteRect.height; y++){
			rowsRedFraction[y] = byteRect.rowFractionOfBytesThatAreAtLeastVal(y, RED, brightLimit);
			rowsGreenFraction[y] = byteRect.rowFractionOfBytesThatAreAtLeastVal(y, GREEN, brightLimit);
			rowsBlueFraction[y] = byteRect.rowFractionOfBytesThatAreAtLeastVal(y, BLUE, brightLimit);
		}
		for(let x=0; x<byteRect.width; x++){
			colsRedFraction[x] = byteRect.colFractionOfBytesThatAreAtLeastVal(x, RED, brightLimit);
			colsGreenFraction[x] = byteRect.colFractionOfBytesThatAreAtLeastVal(x, GREEN, brightLimit);
			colsBlueFraction[x] = byteRect.colFractionOfBytesThatAreAtLeastVal(x, BLUE, brightLimit);
		}
		for(let y=0; y<byteRect.height; y++){
			if(fractionLimit < rowsRedFraction[y]){
				byteRect.setRowAndColordimToByte(y, RED, 0);
			}
			if(fractionLimit < rowsGreenFraction[y]){
				byteRect.setRowAndColordimToByte(y, GREEN, 0);
			}
			if(fractionLimit < rowsBlueFraction[y]){
				byteRect.setRowAndColordimToByte(y, BLUE, 0);
			}
		}
		for(let x=0; x<byteRect.width; x++){
			if(fractionLimit < colsRedFraction[x]){
				byteRect.setColAndColordimToByte(x, RED, 0);
			}
			if(fractionLimit < colsGreenFraction[x]){
				byteRect.setColAndColordimToByte(x, GREEN, 0);
			}
			if(fractionLimit < colsBlueFraction[x]){
				byteRect.setColAndColordimToByte(x, BLUE, 0);
			}
		}
		
		
		/*for(let y=0; y<byteRect.height; y++){
			for(let c=0; c<colorDims.length; c++){
				let colorDim = colorDims[c];
				//if(brightLimit < byteRect.rowAve(y,colorDim)){
				if((brightLimit/255) < byteRect.rowFractionOfBytesThatAreAtLeastVal(y, colorDim, brightLimit)){
					//FIXME use 2 separate vars instead of brightLimit twice
					byteRect.setRowAndColordimToByte(y, colorDim, 0);
				}
			}
		}
		for(let x=0; x<byteRect.width; x++){
			for(let c=0; c<colorDims.length; c++){
				let colorDim = colorDims[c];
				//if(brightLimit < byteRect.colAve(x,colorDim)){
				if((brightLimit/255) < byteRect.colFractionOfBytesThatAreAtLeastVal(x, colorDim, brightLimit)){
					//FIXME use 2 separate vars instead of brightLimit twice
					byteRect.setColAndColordimToByte(x, colorDim, 0);
				}
			}
		}*/
	};
	
	this.preprocessPicToRemoveHorizontalAndVerticalLines_usingGpu_kernel = null;
	
	
	/** TODO allow Float32Array as input? func of [ByteRect.bytes or Float32Array] to Float32Array (size bytes.length/4) of edge detection.
	TODO take Float32Array as param instead?
	TODO change ByteRect to have .bytes and .floats but only use 1 of them, whichever form its in?
	*/
	this.preprocessPicToRemoveHorizontalAndVerticalLines_usingGpu = function(byteRectOrFloats, height, width, brightLimit, fractionLimit, isModifyByteRectIn){
		let first_byteRectOrFloats = byteRectOrFloats;
		
		if(!isModifyByteRectIn) throw 'TODO allow !isModifyByteRectIn';
	
		if(!this.preprocessPicToRemoveHorizontalAndVerticalLines_usingGpu_kernel){
			//using plus, and loopSize, this can do rows or cols.
			this.preprocessPicToRemoveHorizontalAndVerticalLines_usingGpu_kernel =
				gpu().createKernel(function(floats, parallelPlus, loopPlus, loopSize, brightLimit){
					let i = this.thread.x*parallelPlus; //this.thread.x could be x/col or y/row
					let count = 0;
					for(let j=0; j<loopSize; j++){
						if(brightLimit < floats[i]) count++;
						i += loopPlus;
					}
					return count/loopSize; //fraction
				},{
					dynamicOutput: true
				});
		}
	
		let wasByterectIn = isByteRect(byteRectOrFloats);
		if(wasByterectIn){
			byteRectOrFloats = byteRectOrFloats.brightnessFloats();
		}else{
			throw 'TODO allow !wasByterectIn';
		}
		//byteRectOrFloats is Float32Array as monochrome
		
		
		this.preprocessPicToRemoveHorizontalAndVerticalLines_usingGpu_kernel.setOutput([height]);
		//for each row, is fraction of pixels that are at least (or equal?) brightLimit
		let gpuOutRows = this.preprocessPicToRemoveHorizontalAndVerticalLines_usingGpu_kernel(
			byteRectOrFloats, width, 1, width, brightLimit);
		
		this.preprocessPicToRemoveHorizontalAndVerticalLines_usingGpu_kernel.setOutput([width]);
		//for each col, is fraction of pixels that are at least (or equal?) brightLimit
		let gpuOutCols = this.preprocessPicToRemoveHorizontalAndVerticalLines_usingGpu_kernel(
			byteRectOrFloats, 1, width, height, brightLimit);
		
		let ret = new ByteRect(new Uint8Array(height*width*4), height, width);
		
		
		//TODO optimize by modifying the input ByteRect, if wasByterectIn and if returnByterectElseFloats,
		//or something like that, todo organize these kinds of inputs and outputs in various funcs.
		//For now, just create a new ByteRect or new floats.
		
		//modify first_byteRectOrFloats
		for(let y=0; y<height; y++){
			if(fractionLimit < gpuOutRows[y]){
				first_byteRectOrFloats.setRowToBlack(y);
			}
		}
		for(let x=0; x<width; x++){
			if(fractionLimit < gpuOutCols[x]){
				first_byteRectOrFloats.setColToBlack(x);
			}
		}
		
		return first_byteRectOrFloats;
	
		/*if(returnByterectElseFloats){
			return floatsAsMonochromeToPic(ret, byteRect.height, byteRect.width); //ByteRect
		}else{
			return ret;
		}*/
	};
	
	
	this.potentialEnergyOfSprings = function(){
		let potentialEnergy = 0;
		for(let i=0; i<this.numSprings; i++){
			potentialEnergy += this.potentialEnergyOfSpring(i);
		}
		return potentialEnergy;
	};
	
	this.heatEnergyOfSprings = function(){
		const end = this.numSprings*VARSPERSPRING;
		let heatEnergy = 0;
		for(let i=SHEAT; i<end; i+=VARSPERSPRING){
			heatEnergy += this.springs[i];
		}
		return heatEnergy;
	};
	
	//0 <= vox < this.numVoxels */
	this.kineticEnergyOfVoxel = function(vox){
		//FIXME should this include velocity in all dims, including color and how much each webcam can see it, or (probably best this way...) just x y z?
		//kineticEnergy = .5*mass*velocity^2. Mass of each voxel is always 1 (as of 2021-7-21).
		let vv = vox*VARSPERVOXEL;
		let velX = this.voxelVels[vv+VX];
		let velY = this.voxelVels[vv+VY];
		let velZ = this.voxelVels[vv+VZ];
		return .5*(velX*velX + velY*velY + velZ*velZ);
	};
	
	this.kineticEnergyOfVoxels = function(){
		let kineticEnergy = 0;
		for(let i=0; i<this.numVoxels; i++){
			kineticEnergy += this.kineticEnergyOfVoxel(i);
		}
		return kineticEnergy;
	};
	
	this.heatEnergyOfVoxels = function(){
		const end = this.numVoxels*VARSPERVOXEL;
		let heatEnergy = 0;
		for(let i=VHEAT; i<end; i+=VARSPERVOXEL){
			heatEnergy += this.voxels[i];
		}
		return heatEnergy;
	};
	
	/** potentialEnergy + heatEnergy of springs, excluding kineticEnergy since thats stored in voxels. A spring is between 2 voxels. *
	this.energyOfSprings = function(includeKineticEnergy, includePotentialEnergy, includeHeatEnergy){
		if(
		for(let s=0; s<this.numSprings; s++){
			let ss = s*VARSPERSPRING;
			let voxA = s%this.numVoxels;
			let voxB = (s-voxA)/this.numVoxels;
			/*let aveDist = this.springs[ss+SAVEDIST];
			let dist = this.distance(voxA,voxB);
			let distDiff = Math.abs(dist-aveDist); //TODO other nonlinear func? allow it to vary more the farther their aveDist?
			let targetStrength = 1/(10+distDiff);
			this.springs[ss+SSTRENGTH] = this.springs[ss+SSTRENGTH]*(1-decayTowardTargetStrength)+decayTowardTargetStrength*targetStrength;
			//TODO norm by energy per spring, sum potentialEnergy of all those and kineticEnergy of all voxels.
			*
		}
		FIXME
	};*/
	
	/** kineticEnergy + heatEnergy of voxels, excluding potentialEnergy since thats stored in springs. A spring is between 2 voxels. *
	this.energyOfVoxels = function(){
	};
	*/
	
	/** Sum of energy of voxels and springs. The purpose of this is to stop the simulated voxels from exploding
	in some combos of the tuneable params (when move the slidebars in some combos, the voxels get stuck on edge of screen, otherwise).
	potentialEnergy + kineticEnergy + heatEnergy must be constant. Friction drains into heat.
	FIXME energy is not conserved when changing pixel colors, since that comes from outside the system,
	so make sure to norm total energy after each video frame, or find a way to conserve energy.
	Springs have only potentialEnergy and heatEnergy, but no kineticEnergy cuz thats stored in voxels. A spring is between 2 voxels.
	Voxels have kineticEnergy and heatEnergy but no potentialEnergy. potentialEnergy is stored in springs.
	Voxels have position and velocity. Springs have no position or velocity other than the 2 voxels they are between.
	*/
	this.energy = function(){
		let en = 0;
		en += this.kineticEnergyOfVoxels();
		en += this.potentialEnergyOfSprings();
		en += this.heatEnergyOfVoxels();
		en += this.heatEnergyOfSprings();
		return en;
	};
	
	this.restart();

};

var nextIdNum = 0;
//prefix is optional
var newId = function(prefix){
	if(!prefix) prefix = 'id';
	return (prefix+(nextIdNum++));
};

//var copySliderToObField = function(slider, ob, field){
//};

//log<base>(val), such as log<e>(e^3)==3
var logBase = function(base, val){
	return Math.log(val)/Math.log(base);
};

//TODO no escapes cuz its field names, but wouldnt hurt to have them anyways
let arrayOfFieldNamesToJsCodeUsingSingleQuotes = function(array){
	let s = '[';
	for(let i in array){
		if(i > 0) s += ', ';
		s += "'"+array[i]+"'";
	}
	return s+']';
};

//used by createControlsForAftransInDiv to refer to js objects in a string of code outside this namespace.
var vars = {};

//filled by getButtonsJoysticksEtc() many times per second.
var controls = {};

/** get something in the controls map or 0 if its not there. Example: control('gamepad0_dim3') returns a number -1 to 1
for that joystick axis, if its a joystick and if there is a first (0th) gamepad.
*/
var control = function(key){
	//TODO call getButtonsJoysticksEtc again? check if its the same millisecond since called it last, and only call again if isnt.
	return controls[key] || 0;
};

//Example: let x = newVar(10); eval(x+' = x*x+5;'); eval(x) is 105.
//used by createControlsForAftransInDiv to refer to js objects in a string of code outside this namespace.
var newVar = function(val){
	let id = newId();
	vars[id] = val;
	return 'vars.'+id;
};

//appends to innerHTML, not replace
var createControlsForAftransInDiv = function(aftrans, div, optionalStep){
	if(!optionalStep) optionalStep = .1;
	let html = '<table border=0><tr><td>';
	let varName = newVar(aftrans);
		let labelId = newId();
	for(let i=0; i<aftrans.length; i++){
		let inner = i%4;
		let outer = (i-inner)/4; //0..4
		if(inner == 0) html += '<br><nobr>\n';
		html += '<input type=number min="-1000" max="1000" step="'+optionalStep+'" oninput="'+varName+'['+i+'] = this.valueAsNumber; dom(\''+labelId+'\').innerHTML = aftransStr('+varName+');" value="'+aftrans[i]+'"></input>';
		if(inner == 3) html += '</nobr>\n';
		//div.innerHTML += '<nobr><input type=range id="'+id+'" min="0" max="1000000" value="'+(fieldValToFraction(firstVal)*1000000)+'"'
		//	+' oninput="let num = '+MUL+'*(Math.pow('+BASE+', between(0,this.valueAsNumber/1000000,1))-1); sim.'+FIELD+' = num; dom(\''+id2+'\').innerHTML = //\''+FIELD+' = \'+num;"></input><label id="'+id2+'">'+FIELD+'='+sim[FIELD]+'</label></nobr><br> ';
	}
	html += '<td><td>';
	//html += '<br><input type=button onclick="" value="copy aftrans to these^, in case something other than these changed it"></input>
	html += '<br><label id='+labelId+'>'+aftransStr(aftrans)+'</label>'; //keep updated as aftransStr(aftrans) if changes from the 16 numberfields
	html += '</td></tr></table>&nbsp;&nbsp;';
	div.innerHTML += html;
};

//appends to innerHTML, not replace
var createControlsForSimInDiv = function(sim, checkboxesDiv, slidersDiv, buttonsDiv){

	//FIXME some of this code ignores the param sim and uses the global var sim instead
	
	
	let bitFields = [
		'gamepadMovesAndRotatesSelectedBall',
		'allowChangeSelectedObIfSomethingAlreadySelected',
		'isFindDots',
		'isFindEdgesAndKeepTheirColor',
		'normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU',
		'isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU',
		'isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG',
		'isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic', //use with brightLimitForRowsAndColsToNotBeSetToBlack
		'isPreprocessPicToRemoveHorizontalAndVerticalLines_usingGpu',
		'isPaused',
		'addABallIfThereIsNoneWhenRestart',
		'doTestCirclesDetect_oneCenterMultiSizes',
		'doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu',
		'doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu',
		'isMoveAndResizeSelectedObToStrongestCircleFoundByGPU', //circle found by doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu
		'isRotateAndAdjustSphericalPicOnOfAllBallsFromBallsCurrentApproxPositionButManyPossibleRotations',
		'allowBytesIntoGpuElseCopyBytesToFloats_thisMayBeBuggy',
		'enable_holdVoxelsYXAtSingleRadius',
		'hidePointsThatAreBehindOtherPoints',
		'randomlyChangeFirstBallsAftransGradually',
		'pixelColorAcceleratesVoxelsInsteadOfMovesThem',
		'copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack',
		'displaySprings',
		'holdVoxelsYXInByteRect',
		'paintTestObjectsAsInput',
		'displayPotentialEnergyFromSelectedVsTo',
		'is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly',
		'nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked'
	];
	let floatFields = [
		'findDots_maxDotSize_param',
		'minColorDiffFractionToBeADot',
		'brightLimitForRowsAndColsToNotBeSetToBlack_bright',
		'brightLimitForRowsAndColsToNotBeSetToBlack_fraction',
		'holdVoxelsYXAtSingleRadius',
		'repelTimesMoreThanSpring',
		'decaySAVEDIST',
		'decaySSTRENGTH',
		'decayVoxelVelocities',
		'testSize',
		'testSpeedMult',
		'springForceMult',
		'displaySpringBrightnessSubtract',
		'displaySpringContrast',
		'colorChangeSpeedMult'
	];
	let funcsOf0Params = [
		'restart'
	];
	let fields = [];
	for(let i in bitFields){
		let FIELD = bitFields[i];
		let id = newId('chk');
		//FIXME if theres multiple Sim objects, this will still just use the one named 'sim', ignoring the param of this function named 'sim'.
		let startChecked = (sim[FIELD] ? true : false);
		checkboxesDiv.innerHTML += '<nobr><input type=checkbox id="'+id+'" onchange="sim.'+FIELD+' = !sim.'+FIELD+';" '+(startChecked ? 'checked' : '')+'><label for="'+id+'"> '+FIELD+'</label></nobr><br> ';
		fields.push(FIELD);
	}
	for(let i in floatFields){
		const FIELD = floatFields[i];
		let id = newId('slider_'+FIELD+'_');
		let firstVal =  sim[FIELD];
		if((firstVal <= 0) || (firstVal !== firstVal)) throw 'field='+FIELD+', firstVal must be positive but is '+firstVal;
		let MIN = firstVal/10;
		let MAX = firstVal*20; //viewed on log scale, so slider moving to right linearly increases field val exponentially
		let MULRANGE = MAX/MIN;
		
		/*
		slider ranges 0 to 1000000.
		fieldval ranges MIN to MAX.
		fieldVal = mul*base^sliderFraction.
		TODO solve. Theres infinity possible solutions since can trade (nonlinearly) between mul and base.
		firstVal should be middle slider position. MIN and MAX are 100 times less and 100 times more than that,
		as of 2021-7-20 but I might change those later.
		TODO
		*/
		
		const MUL = MIN; //MIN*BASE^0
		const BASE = MULRANGE; //MAX == MUL*MULRANGE^1
		
		const fieldValToFraction = function(fieldVal){
			//OLD: fieldVal = mul*base^sliderFraction.
			//OLD: log<base>(fieldVal/mul) = sliderFraction.
			//return logBase(BASE,fieldVal/MUL);
			
			//fieldVal = mul*(base^sliderFraction-1).
			//fieldVal = mul*base^sliderFraction-mul.
			//fieldVal+mul = mul*base^sliderFraction.
			//fieldVal+mul = mul*base^sliderFraction
			//(fieldVal+mul)/mul = base^sliderFraction
			//log<base>((fieldVal+mul)/mul) = sliderFraction
			return logBase(BASE,(fieldVal+MUL)/MUL);
			
		};
		
		const fractionToFieldVal = function(sliderFraction){
			//return MUL*Math.pow(BASE, sliderFraction);
			return MUL*(Math.pow(BASE, sliderFraction)-1);
		};
		
		let id2 = newId(id+'_label');
		
		//FIXME if theres multiple Sim objects, this will still just use the one named 'sim', ignoring the param of this function named 'sim'.
		slidersDiv.innerHTML += '<nobr><input type=range id="'+id+'" min="0" max="1000000" value="'+(fieldValToFraction(firstVal)*1000000)+'"'
			+' oninput="let num = '+MUL+'*(Math.pow('+BASE+', between(0,this.valueAsNumber/1000000,1))-1); sim.'+FIELD+' = num; dom(\''+id2+'\').innerHTML = \''+FIELD+' = \'+num;"></input><label id="'+id2+'">'+FIELD+'='+sim[FIELD]+'</label></nobr><br> ';
		/*const SIM = sim;
		dom(id).oninput = function(e){
			console.log('Slider event');
			/*let sliderPositionFraction = between(0,this.valueAsNumber/1000000,1);
			let nextFieldVal = fractionToFieldVal(sliderPositionFraction);
			console.log('Slider set sim.'+FIELD+' = '+nextFieldVal);
			SIM[FIELD] = nextFieldVal;
			*
		};*/
		//TODO save these changes somewhere, maybe put javascript code into a div so can copy/paste it from there to the js file sometimes,
		//andOr sessionStorage andOr localStorage js vars, but dont forget its there when copying the file to other ppl,
		//and put a button to clear those.
		fields.push(FIELD);
	}
	for(let i in funcsOf0Params){
		let funcName = funcsOf0Params[i];
		let id = newId('btn');
		//FIXME if theres multiple Sim objects, this will still just use the one named 'sim', ignoring the param of this function named 'sim'.
		buttonsDiv.innerHTML += '<input type=button id="'+id+'" value="'+funcName+'" onclick="sim.'+funcName+'();"></input> ';
		//dom(id).onclick = function(){ sim[funcName](); };
		//dont, cuz its not set like a float or true/false: fields.push(funcName);
	}
	buttonsDiv.innerHTML += "<input type=button value=\"get slider positions as js code\" onclick=\"let div = dom('controlsDiv_output'); let fields = "+arrayOfFieldNamesToJsCodeUsingSingleQuotes(fields)+"; div.innerHTML = ''; for(let i in fields) div.innerHTML += '	sim.'+fields[i]+' = '+sim[fields[i]]+';\\n';\"></input> ";
};

var isFirstUseOfSimAfterWebcamStarted = true;

var mouseY = 0;
var mouseX = 0;
var mouseYFraction = 0;
var mouseXFraction = 0;

//for mouse to rotate andOr move ball. This could be any game object (that has a .aftrans and .childs etc), such as Ball or AfPoint.
//TODO move this and trySetSelectedOb into Sim
var selectedOb = null;

var sim = null; //set in window.onload

//returns true/false did it set selectedOb
var trySetSelectedOb = function(ob){
	let allowChangeIfSomethingAlreadySelected = (!sim || sim.allowChangeSelectedObIfSomethingAlreadySelected);
	if(ob && (!selectedOb || allowChangeIfSomethingAlreadySelected)){
		selectedOb = ob;
		return true;
	}
	return false;
};

let isRunningMainLoop = false; //main loop has to stop between painting the screen. Use this to avoid timers possibly running the main loop twice at once.

var replaceSim = function(){
	sim = new Sim();
	
	/*sim.decaySAVEDIST = 0.1;
	sim.decaySSTRENGTH = 0.034316653410148265;
	sim.decayVoxelVelocities = 0.4;
	sim.testSize = 30;
	sim.testSpeedMult = 14000;
	sim.colorChangeSpeedMult = 4;
	*/
	
	/*sim.decaySAVEDIST = 1.2914570562695387;
	sim.decaySSTRENGTH = 0.16351280248351976;
	sim.decayVoxelVelocities = 0.0481811062002097;
	sim.testSize = 37.45811688034309;
	sim.testSpeedMult = 36235.58952071852;
	sim.colorChangeSpeedMult = 0.4;
	*/
	
	/*sim.decaySAVEDIST = 0.7992753435490808;
	sim.decaySSTRENGTH = 0.05432988578658078;
	sim.decayVoxelVelocities = 0.18387273953764224;
	sim.testSize = 25.78076125970597;
	sim.testSpeedMult = 44066.18868455676;
	sim.colorChangeSpeedMult = 1.4900504444106226;
	*/
	
	/*sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = true;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = true;
	sim.holdVoxelsYXAtSingleRadius = 160;
	sim.decaySAVEDIST = 0.7992753435490808;
	sim.decaySSTRENGTH = 0.05432988578658078;
	sim.decayVoxelVelocities = 0.18387273953764224;
	sim.testSize = 25.78076125970597;
	sim.testSpeedMult = 4406.6188684556755;
	sim.colorChangeSpeedMult = 1.4900504444106226;
	*/
	
	/*sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = true;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = true;
	sim.holdVoxelsYXAtSingleRadius = 160;
	sim.decaySAVEDIST = 0.7992753435490808;
	sim.decaySSTRENGTH = 0.2746990526070163;
	sim.decayVoxelVelocities = 0.1238005206092301;
	sim.testSize = 40.36793477837549;
	sim.testSpeedMult = 28166.95075608863;
	sim.colorChangeSpeedMult = 1.2102022482405757;
	*/
	
	/*sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = true;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = true;
	sim.holdVoxelsYXAtSingleRadius = 160;
	sim.decaySAVEDIST = 0.7992753435490808;
	sim.decaySSTRENGTH = 0.2746990526070163;
	sim.decayVoxelVelocities = 0.1238005206092301;
	sim.testSize = 40.36793477837549;
	sim.testSpeedMult = 20829.118400772433;
	sim.springForceMult = 62314.888264822766;
	sim.displaySpringBrightnessSubtract = 60;
	sim.displaySpringContrast = 61.29361620692233;
	sim.colorChangeSpeedMult = 1.2102022482405757;
	
	sim.springForceMult = 200;
	
	sim.displaySpringBrightnessSubtract = .2;
	sim.displaySpringContrast = 1;
	*/
	
	/*sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = true;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = true;
	sim.holdVoxelsYXAtSingleRadius = 160;
	sim.decaySAVEDIST = 0.7992753435490808;
	sim.decaySSTRENGTH = 0.2746990526070163;
	sim.decayVoxelVelocities = 0.1238005206092301;
	sim.testSize = 40.36793477837549;
	sim.testSpeedMult = 20829.118400772433;
	sim.springForceMult = 200;
	sim.displaySpringBrightnessSubtract = 0.29881952810787477;
	sim.displaySpringContrast = 2.622615111455447;
	sim.colorChangeSpeedMult = 1.2102022482405757;
	
	
	sim.springForceMult = 20000;
	*/
	
	
	/*sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = true;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.holdVoxelsYXAtSingleRadius = 160;
	sim.decaySAVEDIST = 1.0374934185566487;
	sim.decaySSTRENGTH = 0.2746990526070163;
	sim.decayVoxelVelocities = 0.1238005206092301;
	sim.testSize = 40.36793477837549;
	sim.testSpeedMult = 2082.911840077243;
	sim.springForceMult = 2000;
	sim.displaySpringBrightnessSubtract = 0.29881952810787477;
	sim.displaySpringContrast = 2.622615111455447;
	sim.colorChangeSpeedMult = 1.2102022482405757;
	*/
	
	/*sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = true;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.holdVoxelsYXAtSingleRadius = 94.8210585858143;
	sim.repelTimesMoreThanSpring = 5.638021239663635;
	sim.decaySAVEDIST = 1.0374934185566487;
	sim.decaySSTRENGTH = 0.2746990526070163;
	sim.decayVoxelVelocities = 0.013851812617503559;
	sim.testSize = 34.45040563350956;
	sim.testSpeedMult = 2082.911840077243;
	sim.springForceMult = 9033.04399163141;
	sim.displaySpringBrightnessSubtract = 1.095755339174466;
	sim.displaySpringContrast = 7.814329630236468;
	sim.colorChangeSpeedMult = 1.2102022482405757;
	*/
	
	/*sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = true;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = true;
	sim.holdVoxelsYXAtSingleRadius = 94.8210585858143;
	sim.repelTimesMoreThanSpring = 0.004607064384103877;
	sim.decaySAVEDIST = 0.12456962305286466;
	sim.decaySSTRENGTH = 0.0032656666431409957;
	sim.decayVoxelVelocities = 0.05216849801632716;
	sim.testSize = 34.45040563350956;
	sim.testSpeedMult = 12.751904492433628;
	sim.springForceMult = 2273.6853180791504;
	sim.displaySpringBrightnessSubtract = 0.6111139203947075;
	sim.displaySpringContrast = 1.3366739284457965;
	sim.colorChangeSpeedMult = 1.2102022482405757;
	*/



	/*sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = true;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = true;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.holdVoxelsYXAtSingleRadius = 94.8210585858143;
	sim.repelTimesMoreThanSpring = .01;
	sim.decaySAVEDIST = 0.12456962305286466;
	sim.decaySSTRENGTH = 0.0032656666431409957;
	sim.decayVoxelVelocities = .01;
	sim.testSize = 34.45040563350956;
	sim.testSpeedMult = 189.60133128377663;
	sim.springForceMult = 21067.995678284373;
	sim.displaySpringBrightnessSubtract = 0.8162463274127334;
	sim.displaySpringContrast = 1.8896223875801657;
	sim.colorChangeSpeedMult = 1.2180064966601865;
	*/

	/*
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = true;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = true;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.holdVoxelsYXAtSingleRadius = 94.8210585858143;
	sim.repelTimesMoreThanSpring = 0.01;
	sim.decaySAVEDIST = 0.12456962305286466;
	sim.decaySSTRENGTH = 0.0032656666431409957;
	sim.decayVoxelVelocities = 0.3;
	sim.testSize = 34.45040563350956;
	sim.testSpeedMult = 20000;
	sim.springForceMult = 33001.356516843494;
	sim.displaySpringBrightnessSubtract = 0.8162463274127334;
	sim.displaySpringContrast = 1.8896223875801657;
	sim.colorChangeSpeedMult = 1.2180064966601865;
	*/
	
	/*
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = true;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = true;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.holdVoxelsYXAtSingleRadius = 10.595620905623312;
	sim.repelTimesMoreThanSpring = 0.01;
	sim.decaySAVEDIST = 0.6900306023779363;
	sim.decaySSTRENGTH = 0.0032656666431409957;
	sim.decayVoxelVelocities = 5.97;
	sim.testSize = 34.45040563350956;
	sim.testSpeedMult = 20000;
	sim.springForceMult = 33001.356516843494;
	sim.displaySpringBrightnessSubtract = 0.8162463274127334;
	sim.displaySpringContrast = 1.8896223875801657;
	sim.colorChangeSpeedMult = 2.696428546613323;
	*/

	/*
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.holdVoxelsYXAtSingleRadius = 10.595620905623312;
	sim.repelTimesMoreThanSpring = 0.01;
	sim.decaySAVEDIST = 0.9779500268510528;
	sim.decaySSTRENGTH = 0.0032656666431409957;
	sim.decayVoxelVelocities = 0.05869256780953997;
	sim.testSize = 53.96384809558231;
	sim.testSpeedMult = 53822.70297499838;
	sim.springForceMult = 76724.29857438857;
	sim.displaySpringBrightnessSubtract = 0.8162463274127334;
	sim.displaySpringContrast = 1.8896223875801657;
	sim.colorChangeSpeedMult = 36.79119149731036;
	*/

	/*
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.holdVoxelsYXAtSingleRadius = 10.595620905623312;
	sim.repelTimesMoreThanSpring = 12;
	sim.decaySAVEDIST = 0.9779500268510528;
	sim.decaySSTRENGTH = 0.0032656666431409957;
	sim.decayVoxelVelocities = 0.05869256780953997;
	sim.testSize = 53.96384809558231;
	sim.testSpeedMult = .00001;
	sim.springForceMult = 52709.95855821406;
	sim.displaySpringBrightnessSubtract = 0.8162463274127334;
	sim.displaySpringContrast = 1.8896223875801657;
	sim.colorChangeSpeedMult = 7.656814952235777;
	*/

	/*
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.holdVoxelsYXAtSingleRadius = 10.595620905623312;
	sim.repelTimesMoreThanSpring = 0.05760820309387089;
	sim.decaySAVEDIST = 9.13933207639887;
	sim.decaySSTRENGTH = 0.0032656666431409957;
	sim.decayVoxelVelocities = 0.00715505143170058;
	sim.testSize = 43.487759351153244;
	sim.testSpeedMult = 10000;
	sim.springForceMult = 7575.730110916798;
	sim.displaySpringBrightnessSubtract = 0.810320633817516;
	sim.displaySpringContrast = 1.8896223875801657;
	sim.colorChangeSpeedMult = 0.8555980052150126;
	*/
	
	/*
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.holdVoxelsYXAtSingleRadius = 10.595620905623312;
	sim.repelTimesMoreThanSpring = 0.05760820309387089;
	sim.decaySAVEDIST = 9.13933207639887;
	sim.decaySSTRENGTH = 0.0032656666431409957;
	sim.decayVoxelVelocities = 0.0002779646460495772;
	sim.testSize = 43.487759351153244;
	sim.testSpeedMult = 34285.358973666;
	sim.springForceMult = 2000;
	sim.displaySpringBrightnessSubtract = 0.810320633817516;
	sim.displaySpringContrast = 1.8896223875801657;
	sim.colorChangeSpeedMult = 0.4470769752094584;
	*/

	/*
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = true;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.holdVoxelsYXAtSingleRadius = 10.595620905623312;
	sim.repelTimesMoreThanSpring = .00001;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.0032656666431409957;
	sim.decayVoxelVelocities = 0.0002779646460495772;
	sim.testSize = 43.487759351153244;
	sim.testSpeedMult = 34285.358973666;
	sim.springForceMult = 2000;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 0.4470769752094584;
	*/
	
	/*
	sim.addABallIfThereIsNoneWhenRestart = true;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = false;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.holdVoxelsYXAtSingleRadius = 10.595620905623312;
	sim.repelTimesMoreThanSpring = 0.00001;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.0032656666431409957;
	sim.decayVoxelVelocities = 0.0002779646460495772;
	sim.testSize = 17.06594612230106;
	sim.testSpeedMult = 34285.358973666;
	sim.springForceMult = 2000;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 0.4470769752094584;
	*/
	
	/*
	sim.addABallIfThereIsNoneWhenRestart = true;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.randomlyChangeFirstBallsAftransGradually = true;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.holdVoxelsYXAtSingleRadius = 6.897260168505984;
	sim.repelTimesMoreThanSpring = 0.00003961482491769488;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.006553182835691826;
	sim.decayVoxelVelocities = .5;
	sim.testSize = 55.753071208141286;
	sim.testSpeedMult = 12681.258426317045;
	sim.springForceMult = 41.25807343847554;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 1.6879101109374244;
	
	sim.randomlyChangeFirstBallsAftransGradually = false;
	
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	*/
	
	
	/*
	sim.isPaused = true;
	sim.addABallIfThereIsNoneWhenRestart = false;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU = true;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.randomlyChangeFirstBallsAftransGradually = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.holdVoxelsYXAtSingleRadius = 6.897260168505984;
	sim.repelTimesMoreThanSpring = 0.00003961482491769488;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.006553182835691826;
	sim.decayVoxelVelocities = 0.5;
	sim.testSize = 55.753071208141286;
	sim.testSpeedMult = 12681.258426317045;
	sim.springForceMult = 41.25807343847554;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 1.6879101109374244;


	sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU = true;
	*/
	
	
	/*
	sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU = true;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU = true;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic = true;
	sim.isPaused = true;
	sim.addABallIfThereIsNoneWhenRestart = false;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.randomlyChangeFirstBallsAftransGradually = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked = false;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright = 22.947005675709576;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction = 0.3636231798750524;
	sim.holdVoxelsYXAtSingleRadius = 6.897260168505984;
	sim.repelTimesMoreThanSpring = 0.00003961482491769488;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.006553182835691826;
	sim.decayVoxelVelocities = 0.5;
	sim.testSize = 55.753071208141286;
	sim.testSpeedMult = 12681.258426317045;
	sim.springForceMult = 41.25807343847554;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 1.6879101109374244;
	*/
	
	
	/*
	sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU = true;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU = true;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic = true;
	sim.isPaused = true;
	sim.addABallIfThereIsNoneWhenRestart = false;
	sim.doTestCirclesDetect_oneCenterMultiSizes = true;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.randomlyChangeFirstBallsAftransGradually = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked = false;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright = 22.947005675709576;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction = 0.5986767961552187;
	sim.holdVoxelsYXAtSingleRadius = 6.897260168505984;
	sim.repelTimesMoreThanSpring = 0.00003961482491769488;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.006553182835691826;
	sim.decayVoxelVelocities = 0.5;
	sim.testSize = 55.753071208141286;
	sim.testSpeedMult = 12681.258426317045;
	sim.springForceMult = 41.25807343847554;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 1.6879101109374244;



	sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU = true;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU = true;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic = true;
	sim.isPaused = true;
	sim.addABallIfThereIsNoneWhenRestart = false;
	sim.doTestCirclesDetect_oneCenterMultiSizes = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu = true;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.randomlyChangeFirstBallsAftransGradually = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked = false;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright = 22.947005675709576;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction = 0.5986767961552187;
	sim.holdVoxelsYXAtSingleRadius = 6.897260168505984;
	sim.repelTimesMoreThanSpring = 0.00003961482491769488;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.006553182835691826;
	sim.decayVoxelVelocities = 0.5;
	sim.testSize = 55.753071208141286;
	sim.testSpeedMult = 12681.258426317045;
	sim.springForceMult = 41.25807343847554;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 1.6879101109374244;


	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu = true;
	*/


	/*
	sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU = true;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU = false;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG = false;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic = false;
	sim.isPaused = true;
	sim.addABallIfThereIsNoneWhenRestart = false;
	sim.doTestCirclesDetect_oneCenterMultiSizes = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu = false;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.randomlyChangeFirstBallsAftransGradually = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked = false;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright = 22.947005675709576;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction = 0.5986767961552187;
	sim.holdVoxelsYXAtSingleRadius = 6.897260168505984;
	sim.repelTimesMoreThanSpring = 0.00003961482491769488;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.006553182835691826;
	sim.decayVoxelVelocities = 0.5;
	sim.testSize = 55.753071208141286;
	sim.testSpeedMult = 12681.258426317045;
	sim.springForceMult = 41.25807343847554;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 1.6879101109374244;
	*/
	
	/*
	sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU = true;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU = false;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG = true;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic = false;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_usingGpu = true;
	sim.isPaused = true;
	sim.addABallIfThereIsNoneWhenRestart = false;
	sim.doTestCirclesDetect_oneCenterMultiSizes = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu = false;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.randomlyChangeFirstBallsAftransGradually = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked = false;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright = 22.947005675709576;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction = 0.5986767961552187;
	sim.holdVoxelsYXAtSingleRadius = 6.897260168505984;
	sim.repelTimesMoreThanSpring = 0.00003961482491769488;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.006553182835691826;
	sim.decayVoxelVelocities = 0.5;
	sim.testSize = 55.753071208141286;
	sim.testSpeedMult = 12681.258426317045;
	sim.springForceMult = 41.25807343847554;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 1.6879101109374244;
	*/

	/*
	sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU = false;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU = false;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG = false;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic = false;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_usingGpu = false;
	sim.isPaused = true;
	sim.addABallIfThereIsNoneWhenRestart = true;
	sim.doTestCirclesDetect_oneCenterMultiSizes = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu = false;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.randomlyChangeFirstBallsAftransGradually = true;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked = false;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright = 22.947005675709576;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction = 0.5986767961552187;
	sim.holdVoxelsYXAtSingleRadius = 6.897260168505984;
	sim.repelTimesMoreThanSpring = 0.00003961482491769488;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.006553182835691826;
	sim.decayVoxelVelocities = 0.5;
	sim.testSize = 55.753071208141286;
	sim.testSpeedMult = 12681.258426317045;
	sim.springForceMult = 41.25807343847554;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 1.6879101109374244;
	
	
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	
	sim.randomlyChangeFirstBallsAftransGradually = false;
	*/
	
	
	/*
	sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU = true;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU = true;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG = false;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic = false;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_usingGpu = true;
	sim.isPaused = true;
	sim.addABallIfThereIsNoneWhenRestart = true;
	sim.doTestCirclesDetect_oneCenterMultiSizes = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu = true;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.hidePointsThatAreBehindOtherPoints = true;
	sim.randomlyChangeFirstBallsAftransGradually = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked = false;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright = 22.947005675709576;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction = 0.5986767961552187;
	sim.holdVoxelsYXAtSingleRadius = 6.897260168505984;
	sim.repelTimesMoreThanSpring = 0.00003961482491769488;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.006553182835691826;
	sim.decayVoxelVelocities = 0.5;
	sim.testSize = 55.753071208141286;
	sim.testSpeedMult = 12681.258426317045;
	sim.springForceMult = 41.25807343847554;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 1.6879101109374244;
	*/
	
	
	/*
	sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU = true;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU = true;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG = false;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic = true;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_usingGpu = false;
	sim.isPaused = true;
	sim.addABallIfThereIsNoneWhenRestart = true;
	sim.doTestCirclesDetect_oneCenterMultiSizes = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu = true;
	sim.allowBytesIntoGpuElseCopyBytesToFloats_thisMayBeBuggy = false;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.hidePointsThatAreBehindOtherPoints = true;
	sim.randomlyChangeFirstBallsAftransGradually = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked = false;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright = 22.947005675709576;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction = 0.5986767961552187;
	sim.holdVoxelsYXAtSingleRadius = 6.897260168505984;
	sim.repelTimesMoreThanSpring = 0.00003961482491769488;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.006553182835691826;
	sim.decayVoxelVelocities = 0.5;
	sim.testSize = 55.753071208141286;
	sim.testSpeedMult = 12681.258426317045;
	sim.springForceMult = 41.25807343847554;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 1.6879101109374244;
	*/
	
	/*
	sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU = true;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU = false;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG = false;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic = false;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_usingGpu = false;
	sim.isPaused = true;
	sim.addABallIfThereIsNoneWhenRestart = true;
	sim.doTestCirclesDetect_oneCenterMultiSizes = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu = false;
	sim.allowBytesIntoGpuElseCopyBytesToFloats_thisMayBeBuggy = false;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.hidePointsThatAreBehindOtherPoints = true;
	sim.randomlyChangeFirstBallsAftransGradually = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked = false;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright = 22.947005675709576;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction = 0.5986767961552187;
	sim.holdVoxelsYXAtSingleRadius = 6.897260168505984;
	sim.repelTimesMoreThanSpring = 0.00003961482491769488;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.006553182835691826;
	sim.decayVoxelVelocities = 0.5;
	sim.testSize = 55.753071208141286;
	sim.testSpeedMult = 12681.258426317045;
	sim.springForceMult = 41.25807343847554;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 1.6879101109374244;
	
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	
	sim.hidePointsThatAreBehindOtherPoints = true;
	*/
	
	
	/*
	sim.gamepadMovesAndRotatesSelectedBall = false;
	sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU = true;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU = true;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG = false;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic = true;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_usingGpu = false;
	sim.isPaused = true;
	sim.addABallIfThereIsNoneWhenRestart = false;
	sim.doTestCirclesDetect_oneCenterMultiSizes = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu = true;
	sim.allowBytesIntoGpuElseCopyBytesToFloats_thisMayBeBuggy = false;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.hidePointsThatAreBehindOtherPoints = true;
	sim.randomlyChangeFirstBallsAftransGradually = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked = false;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright = 22.947005675709576;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction = 0.5986767961552187;
	sim.holdVoxelsYXAtSingleRadius = 6.897260168505984;
	sim.repelTimesMoreThanSpring = 0.00003961482491769488;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.006553182835691826;
	sim.decayVoxelVelocities = 0.5;
	sim.testSize = 55.753071208141286;
	sim.testSpeedMult = 12681.258426317045;
	sim.springForceMult = 41.25807343847554;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 1.6879101109374244;
	
	sim.allowChangeSelectedObIfSomethingAlreadySelected = false;
	sim.addABallIfThereIsNoneWhenRestart = true;
	sim.isMoveAndResizeSelectedObToStrongestCircleFoundByGPU = true;
	
	sim.isFindDots = true;
	*/
	
	
	
	/*
	sim.gamepadMovesAndRotatesSelectedBall = false;
	sim.allowChangeSelectedObIfSomethingAlreadySelected = false;
	sim.isFindDots = true;
	sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU = false;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU = false;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG = false;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic = false;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_usingGpu = false;
	sim.isPaused = true;
	sim.addABallIfThereIsNoneWhenRestart = true;
	sim.doTestCirclesDetect_oneCenterMultiSizes = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu = false;
	sim.isMoveAndResizeSelectedObToStrongestCircleFoundByGPU = false;
	sim.allowBytesIntoGpuElseCopyBytesToFloats_thisMayBeBuggy = false;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.hidePointsThatAreBehindOtherPoints = true;
	sim.randomlyChangeFirstBallsAftransGradually = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked = false;
	sim.minColorDiffFractionToBeADot = 0.0010283089101665933;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright = 22.947005675709576;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction = 0.5986767961552187;
	sim.holdVoxelsYXAtSingleRadius = 6.897260168505984;
	sim.repelTimesMoreThanSpring = 0.00003961482491769488;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.006553182835691826;
	sim.decayVoxelVelocities = 0.5;
	sim.testSize = 55.753071208141286;
	sim.testSpeedMult = 12681.258426317045;
	sim.springForceMult = 41.25807343847554;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 1.6879101109374244;

	sim.isFindDots = false;
	sim.isFindEdgesAndKeepTheirColor = true;
	
	sim.isFindDots = true;
	sim.isFindEdgesAndKeepTheirColor = false;
	
	sim.findDots_maxDotSize_param = 5;
	
	sim.isFindDots = false;
	sim.isFindEdgesAndKeepTheirColor = true
	sim.minColorDiffFractionToBeADot = 0.0015;
	*/
	
	sim.gamepadMovesAndRotatesSelectedBall = false;
	sim.allowChangeSelectedObIfSomethingAlreadySelected = false;
	sim.isFindDots = false;
	sim.isFindEdgesAndKeepTheirColor = false;
	sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU = false;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU = false;
	sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG = true;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic = false;
	sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_usingGpu = false;
	sim.isPaused = true;
	sim.addABallIfThereIsNoneWhenRestart = true;
	sim.doTestCirclesDetect_oneCenterMultiSizes = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingCpu = false;
	sim.doTestCirclesDetect_manyCentersAndSizesButOnlyNearScreenCenterUsingGpu = true;
	sim.isMoveAndResizeSelectedObToStrongestCircleFoundByGPU = false;
	sim.allowBytesIntoGpuElseCopyBytesToFloats_thisMayBeBuggy = false;
	sim.enable_holdVoxelsYXAtSingleRadius = false;
	sim.hidePointsThatAreBehindOtherPoints = true;
	sim.randomlyChangeFirstBallsAftransGradually = false;
	sim.pixelColorAcceleratesVoxelsInsteadOfMovesThem = true;
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = true;
	sim.displaySprings = false;
	sim.holdVoxelsYXInByteRect = true;
	sim.paintTestObjectsAsInput = false;
	sim.displayPotentialEnergyFromSelectedVsTo = false;
	sim.is3d_requiresRestartButtonToGet3dPositionsBackButNotNeedThatToBecome2dInstantly = false;
	sim.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked = false;
	sim.findDots_maxDotSize_param = 8.964933912628947;
	sim.minColorDiffFractionToBeADot = 0.0029686365936277747;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright = 131.54635878872384;
	sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction = 0.4753497737281347;
	sim.holdVoxelsYXAtSingleRadius = 6.897260168505984;
	sim.repelTimesMoreThanSpring = 0.00003961482491769488;
	sim.decaySAVEDIST = 0.08985106660434582;
	sim.decaySSTRENGTH = 0.006553182835691826;
	sim.decayVoxelVelocities = 0.5;
	sim.testSize = 55.753071208141286;
	sim.testSpeedMult = 12681.258426317045;
	sim.springForceMult = 41.25807343847554;
	sim.displaySpringBrightnessSubtract = 0.6882509066172149;
	sim.displaySpringContrast = 1.444384223868754;
	sim.colorChangeSpeedMult = 1.6879101109374244;


	sim.isMoveAndResizeSelectedObToStrongestCircleFoundByGPU = true;
	sim.isRotateAndAdjustSphericalPicOnOfAllBallsFromBallsCurrentApproxPositionButManyPossibleRotations = false; //cuz it doesnt work yet 2021-10-20
	
	sim.isMoveAndResizeSelectedObToStrongestCircleFoundByGPU = false; //cuz its flattening the ball
	sim.gamepadMovesAndRotatesSelectedBall = true;
	
	sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack = false;
	
	
	sim.restart();
};

window.onload = function(){


	// Configure a few settings and attach camera
	Webcam.set({
		fps: 120,               // camera frames per second. FIXME? webcamjs seems to ignore this param.
		width: 320, //FIXME changing thse seems to have no effect 2021-8
		height: 240,
		//image_format: 'png',
		image_format: 'jpeg', //FIXME why does this seem to have no effect? jpeg vs png, and jpeg_quality of 90 vs 3?
		jpeg_quality: 90
	});
	Webcam.attach('#my_camera');

	/*
	// preload shutter audio clip
	var shutter = new Audio();
	shutter.autoplay = true;
	shutter.src = navigator.userAgent.match(/Firefox/) ? 'shutter.ogg' : 'shutter.mp3';
	*/

	updateCanvasObjects();
	replaceSim();

	


	




	//why didnt this fix it, and still need to click restart after it loads (to get voxels off edges of screen they moved too fast got stuck)?: sim.restart(); //cuz changed sim.varnames
	
	createControlsForSimInDiv(sim, dom('controlsDiv_checkboxes'), dom('controlsDiv_sliders'), dom('controlsDiv_buttons'));
	
	let x = function(){
		if(isRunningMainLoop){
			console.log('WARNING: Already isRunningMainLoop='+isRunningMainLoop);
			return;
		}
		isRunningMainLoop = true;
		try{
			if(Webcam.live){ //FIXME also check isPaused here?
				take_snapshot(sim);
				dom('buttonsJoysticksEtcDiv').innerHTML = "<br>"+JSON.stringify(getButtonsJoysticksEtc()).replaceAll(',',',<br>');
				//setTimeout(x, 20);
				if(isFirstUseOfSimAfterWebcamStarted){
					isFirstUseOfSimAfterWebcamStarted = false;
					adjustCanvasEtcSizesToMatchAspectRatioOfWebcamExceptRoundoff();
					sim.restart();
				}
				if(sim.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked){
					setTimeout(x, 1); //likely to get out of sync compared to requestAnimationFrame but seems to get a little higher fps than requestAnimationFrame
				}else{
					requestAnimationFrame(x);
				}
			}else{
				console.log('Webcam isnt on yet');
				setTimeout(x, 500);
			}
		}finally{
			isRunningMainLoop = false;
		}
	};
	x();
	
};


//Returns a map of button/joystick/etc name to number in range -1 to 1. TODO Everything not in the map means 0? Or include zeros?
//gamepad api, todo also add mouse, keyboard, etc. Any data flow from person to computer that doesnt need high bandwidth.
//sound and video need high bandwidth.
//This is called many times per second since navigator.getGamepads() only reads gamepad state once and does not start a stream of it (like browsers used to).
//
/*TODO use controller rumble. I got it to work with bluetooth xbox controller in win10 in chrome (first browser I tried) 2021-8-28 with this
gamepad.vibrationActuator.playEffect("dual-rumble", {
	duration: 1000,
	strongMagnitude: 1.0,
	weakMagnitude: 1.0
})
but it kept rumbling, maybe cuz i was in browser debugger at a breakpoint.
*/
var getButtonsJoysticksEtc = function(){
	let gamepads = navigator.getGamepads(); //may contain nulls, such as [null, null, null, null] or [aGamepad, null, null, null].
	let ret = {};
	ret.mouse0_dim0 = mouseYFraction*2-1; //TODO swap y and x order of dims?
	ret.mouse0_dim1 = mouseXFraction*2-1;
	for(let i=0; i<gamepads.length; i++){
		let gamepad = gamepads[i];
		if(gamepad){
			let s = gamepad.id;
			if(!s) s = 'gamepad';
			//s = s.trim().replaceAll(/\s|\(|\)/g,'_');
			s = s.trim().replaceAll(/\(|\)/g,'').replaceAll(/\s/g,'_');
			//let gamepadName = s+'_index'+i;
			let gamepadName = 'gamepad'+i;
			
			//let buttonOrAxisNum = 0;
			for(let a in gamepad.axes){
				//ret[gamepadName+'_'+(buttonOrAxisNum++)] = gamepad.axes[a];
				ret[gamepadName+'_dim'+a] = gamepad.axes[a];
			}
			for(let b in gamepad.buttons){
				ret[gamepadName+'_btn'+b] = gamepad.buttons[b].value; //GamepadButton {pressed: false, touched: false, value: 0}
			}
			if(gamepad.vibrationActuator){
				ret[gamepadName+'_vib0_TODO'] = 0; //TODO see how I used this in comment of getButtonsJoysticksEtc
			}
			
		}
	}
	ret.eventExists = 1; //becomes 0 after event is consumed
	return ret;
};

var domSetSize = function(dom, width, height){
	if(dom.width) dom.width = width;
	else dom.style.width = width+'px';
	if(dom.height) dom.height = height;
	else dom.style.height = height+'px';
};

var adjustCanvasEtcSizesToMatchAspectRatioOfWebcamExceptRoundoff = function(){
	let webcamVideo = Webcam.video;
	if(!webcamVideo) throw 'No webcam yet, webcamVideo='+webcamVideo;
	let physicalCameraAspectRatio = webcamVideo.videoWidth/webcamVideo.videoHeight; //may differ from aspectRatio on screen.
	let observedCanvasWidth = canvasOut.width;
	let newCanvasWidth = observedCanvasWidth;
	let newCanvasHeight = Math.ceil(observedCanvasWidth/physicalCameraAspectRatio);
	domSetSize(dom('canvasIn'), newCanvasWidth, newCanvasHeight);
	domSetSize(dom('canvasOut'), newCanvasWidth, newCanvasHeight);
	
};

</script>

</head><body>
//FIXME mouseY etc measures from here not in canvas
<table border=0><tr><td valign=top>

	<canvas id="canvasOut" width=640 height=640 onmousemove="let rect = this.getBoundingClientRect(); mouseY = event.clientY-rect.top; mouseYFraction = between(0,mouseY/this.clientHeight,1); mouseX = event.clientX-rect.left; mouseXFraction = between(0,mouseX/this.clientWidth,1); trySetSelectedOb(sim.whatsAtYx([mouseY,mouseX])); /*if(selectedOb) selectedOb.randomizeColors();*/"></canvas><br>
	<div id="controlsDiv_checkboxes"></div>
	<br><br>
</td><td valign=top>
	Works in most browsers if camera is not already in use (or sometimes even if it is), when you click allow camera in the popup. Close other browser tabs or programs that may be using the camera then reload this page, if an error pops up and you dont see live webcam on the left. Its lower lag if only 1 browser tab is using webcam at once. <label id=fpsLabel></label>
	<div id="controlsDiv_sliders"></div>
	<hr>
	<input type=button value="replaceSim (fixme this doesnt replace the checkboxes etc, so they might be the opposite of what they should be)" onclick="replaceSim();"></input>
	<hr>
	<div id="controlsDiv_aftranses"></div>
	<hr>
	<div id="controlsDiv_buttons">
		<textarea cols=50 rows=2 id="controlsDiv_output"></textarea><br>
	</div>
	<div id="buttonsJoysticksEtcDiv">buttonsJoysticksEtcDiv</div>
</td></tr></table>

<hr><hr>

* DONE Make first ball using a tennis ball and black permanent marker (TODO maybe nonpermanent is faster to wash and dry?) then let it dry then wash it with soapy water then dry again, which has 2 colors (black and yellow), and the code detects its 3d position. The code needs to be optimized since it only detects 3d position if the ball is in a certain square near screen center its looks in, and I had to fiddle with the sliders to get it to just barely work, so that needs to be made more reliable, but it works enough to continue building the prototype.
<br><br>
* DONE Ball.prototype func that copies pixels from a ByteRect onto the ball in sphere coordinates (added optionalIsReversePaint param in Ball.paint(byteRect, aftrans, optionalIsReversePaint)), including that it uses the first WEBCAM* dim) as opacity/transparency dim cuz the webcam cant see the back side of the ball.
<br><br>
In browser run "sim.childs.push(selectedOb.copyRotated());" then "selectedOb = sim.childs[sim.childs.length-1]" and using gamepad (may need to check the box) move around the new Ball. Problem is it didnt copy the pixels right. It has red green blue pixels near eachother, mixed up from where they should be.
<br><br>
* TODO Ball.prototype func to create Ball.numAngles or poleAngles (numAngles/2) number of Balls whose poles are at each of those angles, so if its a 100x50 image on a Ball, then you would either create 50 or 100 Balls that are copies of those pixels but rotated. Display these other Balls and move and rotate them using gamepad as a test. Do this in rotateAndAdjustSphericalPicOnOfAllBallsFromBallsCurrentApproxPositionButManyPossibleRotations.
<br><br>
* TODO Use a group of 50 balls (sphere rotations of what webcam sees at a circle it finds the ball's 3d position), and a group of 100 Balls (rotations of selectedOb Ball etc), or whatever is the ball resolution, and align those in all bipartite pairs and 100 rotations each, so thats 50*100*100=500k rotations, and they each have 5000 points to compare 1-to-1 with 5000 points from the other group but that comparing can be done at lower resolution or random sampling etc such as only 1 pixel out of every 4x4 block of pixels since it would otherwise be too slow, and that finds which of the 500k possible rotations the webcam video and the simulated ball match best at. After finding the best of those 500k, do more detailed searching of maybe 10k possible rotations and up to 2 pixels moved in x y z etc (using the same copyRotated func, or maybe a whole extra batch of them in gpu), to get sub-pixel accuracy of ball position and rotation. Maybe a few rounds of that to get it as close as it can. Then decay the ball color toward what the webcam sees, so it will find the ball's position and rotation easier in the future. Put an AfPoint at the Ball and move it around in my physical hand, verifying the ball is now a 6d joystick.
<br><br>
* TODO put a very fast speed limit on ball so it cant jump discontinuously to somewhere else on screen that temporarily looks like a ball.
<br><br>
* (leave this for later, if its not fast enuf) TODO create a math model of how fast gpujs (using webcl) is based on total size of data copied to gpu, how much data each gputhread needs,
how indirect of pointer jumping such as using sine cosing exp + / etc (webgl shaders can do that, which lwjgl_opencl_1.2 (or opencl in general?) cant)
to choose where to read data vs just using & + * etc like opencl can do. I've seen gpujs vary flops by around 500 times faster than itself depending how its used. I need to know this before choosing how to compute the 500k possible rotations (per ball per video frame, each having around 5000 pixels to check against 5000 other pixels, which could be done more or less sparsely, with just 2 balls, or with (()50 outerjoin 100) multiply 100 balls, storing only 100+50 of those balls) etc). And I could put just 1 bit of color (did i draw black marker on the ball there or not, or 2 bits per pixel for is that part of ball visible or not, or 4 floats per pixel for red green blue visibility, or 1 float per pixel storing 4 of uint6 as the float ranges 0 to 2^24-1, etc). Also test on multiple computers, including rented cloud computers, android, etc. Test it in a separate html file that just uses gpujs and does not have any of this webcam stuff. I probably remember gpujs working faster than cpu in some android browser, but the webcam stuff is slow and I might just barely get it fast enough to be useful on android browser, might have to be a mostly desktop/laptop/etc system, or stream video from phone browser to where theres more compute power. Figure out this kind of stuff. Include in this model combineKernels as explained at https://github.com/gpujs/gpu.js readme.
<br><br>
* TODO use 1 ball and mouse at same time various ways. While right mouse button is held, ball moves and rotates the view. While left mouse button is held, ball grabs and drags things in 3d. Or something like that.
Hook in basic cannon.js or gpu-physics.js etc and build something with domino-like blocks or make a simple 4wheeling or flying game on a heightmap or something. More balls at once will do more addvanced things later, but this is an early experiment.
<br><br>
* TODO Get it working for 20 balls at once, such as rolling them on a table, as long as they're moving slow enough they dont motionblur so no throwing or bouncing them (yet?).
<br><br>
* TODO: Make 3d ball position detection reliable for a variety of balls, computers, light, shadows, fingers over the ball, ball in front of another ball, multiple people holding a ball in each hand in front of the same webcam, etc.
<br><br>
* TODO Make it work in phone browsers (just test on android for now) using front camera, holding 2 balls above the phone laid on a table.
<br><br>
* TODO put basic prototype online at some rented server whose main job is just to copy 3d positions of objects between players.
Any one player, who may be at the server itself (lower lag) or may be a remote player (higher lag) can be the game host which computes the physics,
keeps track of which players are trying to move which ways, syncs with them, etc.
<br><br>
* TODO add a gas* system (gasTime, gasMem, gasNetwork, etc) where at a server, players (some Human, some AIs, the gas system doesnt care)
can leave pieces of gas in the game world and pick them up, which gives the ability to do more calculations or store things on the server temporarily,
which will later be used for wikibinator107 fns but for now will be how anyone can become a host and make rules and new kinds of games etc
that they and other players may choose to play together at that server.
Each server has its own gas* and it does not transfer across servers and is not stored longterm.
<br><br>
* TODO Even though it will be computed the normal way in middle calculations, using js stack and func param context ret caching,
as a way for players (some are people, some are AIs, and some are simple self-modifying lambdas/fns) wrap outermost calls
(each with their own gas* and thousands of them each in their own greenthread) in...<br>
Use fns (wikibinator107) as a turingComplete transfinite quasicrystal, a directedGraph where each node has 3 outgoing edges (red green blue)
and infinity incoming edges (but not always of all 3 kinds of edges). The purpose of this is to run fns in thousands of greenthreads per computer
that each have their own gasTime and gasMem, which can choose to give eachother gas* or to spend it on lambda calls.
Imagine a bunch of objects moving around in 3d game world. Some of those objects have these slots:
&lt;gasTime gasMem minExpireTime fromNode greenToNode blueToNode redToNode inferenceDirection didItRunOutOfGas&gt;.
inferenceDirection (or maybe split it into multiple bit vars?) is 0 to allow changing the other vars (gasTime...redToNode etc) to whatever you want,
of course not allowing the creation of new gasTime or gasMem but can move them to other "piles of gasMem" or "piles of gasTime" etc.
If inferenceDirection is 1 its (greenToNode blueToNode)--&gt;fromNode so writes fromNode to be that halted callpair IF that would be instantly trivially halted
else inferenceDirection becomes 0 (to refuse to do that).
If inferenceDirection is 2 then it replaces greenToNode and blueToNode with the L and R childs of fromNode. It always works since everything knows its 2 childs,
and the childs of leaf are identityFunc and leaf, and the childs of Leaf (DirtyLeaf) are IdentityFunc (DirtyIdentityFunc) and Leaf (DirtyLeaf).
InferenceDirection is 3 then replaces all 3 of greenToNode, bluetoNode, and redToNode with the correct 3 edges from fromNode.
If theres not enuf gasTime or gasMem (which decrease while these calculations are done),
inferenceDirection becomes 0 and didItRunOutOfGas becomes T, else didItRunOutOfGas is F.
Or something like that. Theres many variants of this I'm considering.
Using multiple &lt;gasTime gasMem minExpireTime fromNode greenToNode blueToNode redToNode inferenceDirection didItRunOutOfGas&gt;s together,
can copy nodes from one to the other like to call 5 fns on any chosen fn to measure things about it then choose what to do with it
depending on those measurements. Its a little similar to fntape but more like cpu registers (and can do gpu optimizations in some parts, todo).<br>
.............................................<br>
The red edges maybe should be split into 2 kinds of edge, one that counts containing ax constraints as nonhalting (so call on leaf, and if what it returns containsAx then infloop...)
and one that allows ax constraints to be returned. The default one should NOT allow axConstraints cuz they are very expensive to verify across untrusted borders,
but axConstraints can still occur in middle calculations as long as they dont exist in the nodes that the green blue and red (or redA redB?) edges are between.
To make debugStepInto and debugStepOver fns, you need axConstraints, so having green blue redA and redB edges would make it as flexible as wikibinator107's full abilities
and still have that subset of it (just green blue and redA edges) thats far easier to optimize and prove things about and is enough for most uses.
Also might want doesItHalt (T vs F, or maybe leaf vs (leaf leaf)) edge type, and returnsWhatIFItHalts (which is whatever it returns,
or leaf if it does not return, so --returnsWhatIFItHalts--&gt; can lead to leaf and that doesnt tell you if it halted
on leaf vs did not halt, but the other edge types can tell you that, and similar to redA and redB you would have returnsWhatIFItHaltsA and returnsWhatIFItHaltsB),
but since all those extra edge types can be derived from green blue redA and redB, you only really need 4 edge types,
but might make it easier for humans to think about the directed graph (that is a turingComplete transfinite quasicrystal)
if also have edges for car cdr growinglist-related things sCurryList vararg_syntax_using_growinglist etc.
Theres many ways to display the same turingComplete transfinite quasicrystal.<br> 
.............................................<br>
Only call b on c if (b c) is halted
and does not contain (axa anything) or (axb anything), so it trivially builds up halted fast-to-verify callpairs and to have the security of
every node has exactly 1 of each outgoing edge type so in theory AI can learn to predict the shape of this directedGraph,
but if AI doesnt predict it and its just computed the normal way (red edges never returning leaf to say it doesnt halt)
its still a well defined directedGraph in abstract math, and I plan to use recursiveExpireTime (of parent must expire before childs,
and can pay gasMem into any fn with a target min expireTime to increase recursively everything reachable from that fn, if it has enuf gasMem)
so thats how to expand upward from the green and blue edges (whatever would be instantly trivially halted if callpair them),
and gasTime crosses red edges (may not have enuf to prove it doesns)<br>
.............................................<br>
()todo finish writing, got distracted in the middle here)<br>
.............................................<br>
, and to call them,
you dont actually call but use redEdge which is a transfinite operator (a higher cardinality above lambdas)
Green edge is L/getFunc. Blue edge is R/getParam. Red edge depends on what calling self on leaf does.
If (self leaf) does not halt (which may take infinity cycles to know), then red edge goes to leaf. If (self leaf)-&gt;ret (halts on ret), then red edge goes to (leaf ret).
Therfore if the lambda call (x y) returns z, then you get z by (S (T x) (T y))--red--&gt;--blue--&gt;z, and if it does not halt then (S (T x) (T y))--red--&gt;leaf.
(T x)--green--&gt;T. (T x)--blue--&gt;x. (T x)--red--&gt;(leaf x). (S (T (S I I)) (T (S I I)) )--red--&gt;leaf cuz ((S I I) (S I I)) does not halt.
You could also use (lazig (S I I) (S I I))--red--&gt;leaf.<br>
.............................................<br>
Derive the debugStepInto and debugStepOver and pushEmulator and popEmulator fns (wikibinator107 nodes that are a call of axa, which is a turing-complete-typed lambda), and use those to define the middle steps of calculations so the quasicrystal has a well defined energy function, though I'm not claiming to be able to solve the transfinite parts without graph-neural-nets andOr other kinds of AI learning how, i can easily solve the forward calculation of lambda called on lambda finds/creates lambda, those parts of the directedGraph.
.............................................<br>
Add an edge type that goes to T or F, for is it from a valid node, among all possible binary forest nodes
(some of which are invalid cuz have 0 curries (cur) or are axa or axb statements that arent true).
Also add an edge type that goes to T or F for is it from the leaf (clean or dirty forms? or 2 edge types for that?),
even though the R/blue edge type is from and to the same node. These T/F edges are stored as bits instead of edges, but in abstract math are edges.
<br><br>
* TODO  Create a flexible "build your own game" kind of game objects that can be reshaped, put spring or hinge etc between them, use fns (wikibinator107) as their "brains", have simulated camera, simulated gyroscope, simulated linear motors (just a pole that changes length), etc, as ways to build things in this space.
There will be a few kinds of computing built in that can interact with eachother:
fns, physics_and_graphics, neuralnets (maybe tensorflow.js keras? verify it works on non-nvidia computers in browser), gpujs number crunching in general.
There will be a few kinds of inputs and outputs built in, including WebAudioAPI for speakers and microphones (browser), PointerLock (browser), multitouchscreen browser api, webcam, canvas, balls as 6d joysticks seen by webcam(s), etc.
All these things will be usable thru fns which will store them as bitstrings in treemaps etc, and call the various funcs thru the Wiki (where all nondeterminism goes) fn
such as (Wiki "tensorflowjs" ...params...) but that can be done by dragAndDrop of fn onto fn to find/create fn, OR can be done by calling fns as js lambdas or by a custom syntax I'm building for fns (see the java version).
As a test of these things, build a few musical instruments that are played by moving 3d objects in the game, and build a few game objects that evolve neuralnet weights to find gas* laying around the game world which lets them do more calculations and storage so they can in some cases think smarter to find more gas* etc. Do a few basic experiments like that.
<br><br>
* TODO Store things on server using a kind of gas* thats meant for longterm storage, that can be looked up by its marklar107b id. Verify the world exists across multiple players who find a few simple objects laying around a mostly empty game world, from which they are supposed to build the game world and invite more people and build AIs to play with other AIs and with people. Verify all these objects, including AIs, musical instruments, custom shaped 3d objects, lisp-like data structures, etc, transfer from one server to another by any player who wants to can download the full fn forest of any fn and upload it to any server running marklar107b and these few js libs. The servers wont normally talk to eachother directly, but their users can cross servers and copy stuff between them, and users can be connected to multiple servers at once and copy things at gaming-low-lag, so if users want to try to get multiple servers in sync with eachother, each server doing a different part of a shared large game world, it would be possible, though its more likely to end up being a bunch of minigames of 1-100 players each that things can be copied between in realtime.
<br><br>
* TODO Start building a fun game world, using only tools in the game world to build more parts of the game world.
<br><br>
* TODO mutableWrapperLambda to use ed25519 publickeys as lambdas where (myPublicKey anyParam)-&gt;anyResponse (or maybe also having a time param?) is how network stuff will work, though might have that as a second network protocol and just use ajax http etc to get things started easier.
<br><br>
* TODO hook in the java version of lazycl and wikibinator107 for extra compute power, using a kind of gas*. It will only compute what fns say to so is still sandboxed. This might not even be needed but is the language the system started in before I decided to make the next prototype in javascript and GPU.js etc turned out to be only a few times slower than lazycl at number crunching, and GPU.js can do something that opencl cant cuz it uses webgl shaders instead of opencl, and that is pointer jumping in an array by nonlinear calculations such as combos of sine exp + / etc to choose the address to read or write and it does that 10 billion times per second and I've seen it go up to a few trillion multiplies per second when its just computing without doing much IO in or out of the gpu thread. Take whatever parts are in the java/nativeC++OfLwjgl2OpenclAPI/lazycl and javassist compiler etc, and hook them in thru ajax etc, to be optionally used for extra compute power by those who have the gas* to pay for it. Gas* is not a real currency and is just within 1 server (not transferrable to another server, but is transferrable to other users or 3d locations at the same server) and decays over time or is otherwise meant for short-term allocation of compute resources, and sometimes might store things for longer. Also hook in dynamic calling of GPU clouds and other cloud services, for even more compute power etc, by those who want it. You can always just use it for free and opensource, but theres many things that might improve it to hook in thru network as plugins. Everything moving thru these various systems should be in the form of fns (wikibinator107), and only the kind of fns that have no axa or axb.
<br><br>
* TODO continue AI research in the game world, using only tools in the game world to build ever more advanced things in the game worlds, and to expand to more people and systems doing fun and useful things in the worlds together. Its as open-ended as computing itself since it is both safely sandboxed (in a sandbox that exists across potentially millions or billions of computers at once in realtime) and able to build anything that computers can do. It becomes a general internet protocol with a bunch of things able to be used together thru it, with many people and AIs having fun and doing useful things together. Its decentralized and nobody can control anyone else through it except what someone may opt into. It can be in some parts (larger ids, more redundant checking of constraints, etc) also secure enough to run dangerous equipment on and can at runtime trade between security and efficiency and latency etc. In the same network where people and AIs screw around playing together could safely be the operation of dangerous machines and all potentially reacting to eachother within turing-complete constraints.
<br><br>
* TODO sit back and watch what it becomes, and enjoy using it the same as anyone else, as it is now truly decentralized without "the programmers" needing to have higher access to it than anyone else. It is a self sufficient life form or web of stuff thats kind of alive when viewed together.
<br><br>
* TODO Maybe... Kind of chip to more efficiently run wikibinator107 or some variant of it, and a web of these chips,
along with the pure software more compatible form of it, all navigate the same constant directedGraph (turingComplete transfinite quasicrystal)
as the directedGraph is navigated by many people and computers together across the internet, the same constant directedGraph but different nodes in it,
which they fit together by the property of math that it has only 1 automorphism and the leaf node has a blue edge to itself and no other node has a blue edge to itself.
Explore different kinds of turingComplete transfinite quasicrystals (such as the one with green blue redA and redB edges)
and try to use them, with AI filling in the edges by pattern matching, to simulate https://en.wikipedia.org/wiki/Delayed-choice_quantum_eraser
and based on the infinite directedGraph having exactly 4 times as many edges as nodes (green blue redA redB,
or however many edge types a different kind of quasicrystal has that happens to model physics better),
that seems like it could fit at least approximately into some kind of unitary math
even though its a constant directedGraph and does not get transformed into anything and is just so big it contains all turingCompleteness already.
There might be some kind of pbrane-based computer, maybe made of a shape of pbrane
that is both https://en.wikipedia.org/wiki/Time_crystal and https://en.wikipedia.org/wiki/Quasicrystal
and maybe various other strange properties of physics... This model of computing might be very very very optimizable in some new kind of chip,
so efficient it might in realtime simulate every particle individually in a cup of water while itself being smaller than that cup
in our normal 3 dimensions because it is an infinite dimensional chip. The turingComplete transfinite quasicrystal
has a superexponential number of dimensions per height of lambda call forest.
Or maybe it will just be a useful model of computing but not a good model of physics.
<br><br>

<hr><hr>


<br>//from.isleaf
<br>//to.isleaf
<br>from.isvalid
<br>//to.isvalid
<br>haltswhencalledonleaf
<br>l
<br>r
<br>returnswhat(elseleaf)whencalledonleaf
<br>
<br>
<br>this --green--> this.l()
<br>this --blue--> this.r()
<br>this --red--> some datastruct containing [this is a valid node?] and [does (this leaf) halt?] and [what (this leaf) halts on, if it halts, else leaf if it does not halt]. so maybe (T (T retVal))? of course that would need to be (t (t retVal)) if retVal is dirty. or (t (f retVal)) etc. or (growinglist retval t f) aka (((growinglist retval) t) f) etc.
<br>
<br>Since everything must be halted in the quasicrystal (no o6 of 0 aka op.deeplazy), if (x y) is not trivially halted, then you do that call by (lazig x y)-red->-...something...->whatCallingXOnYReturns. (lazig x y) is halted, similar to (s (t x) (t y)) is halted, and lazig is a derived func of 3 params which does that.
<br>
<br>Problem is, I want the -red-> to lead to a small datastruct, cuz need to call things often, but I dont want to create too many other arrow/edge types cuz those will end up being ignored, like if x-fromIsValid->t or x-fromIsValid->f thats likely to be ignored and just use whats needed to call x, assuming its valid. If you are forced to get the result of is caller valid or not, does it halt or not, etc, every time you call something, and maybe every time that thing is returned by something else, at least in abstract math, then the model of computing is more reliable, can self repair things that dont fit constraints more often, can move computing power across the internet without needing as much trust of where it came from.
<br>
<br>Lets call (axa anything) and (axb anything) axes, but axa by itself or axb by itself are not axes. Ax (axiom-like) op works this way... (axa x) is halted if (x leaf)->leaf, and (axb x) is halted if (x leaf)->anything_except_leaf, and if (x leaf) does not halt, then (axa x) is not halted and (axb x) is not halted. (axa x y)->(x (t y)). (axb x y)->(x (f y)). So thats how to make typed lambdas, which take all possible params (regardless of type) but guarantee their own type in a turingCompleteWay, such as that way you can make a list that can only contain prime numbers, or a data structure that can only contain some kinds of C code that does not create memory leaks, or any turing complete constraints that you can come up with a way to prove in finite time.
<br>
<br>The number of binary forest nodes atOrBelow height 0 is 1, atOrBelow height 1 is 2, atOrBelow height 2 is 5, atOrBelow height 3 is 26, and generally:
<br>numberOfBinaryForestNodesAtOrBelowHeight(x)=((x==0) ? 1 : 1+numberOfBinaryForestNodesAtOrBelowHeight(x)^2). numberOfBinaryForestNodesAtHeight(x)=numberOfBinaryForestNodesAtOrBelowHeight(x)-numberOfBinaryForestNodesAtOrBelowHeight(x-1).
<br>numberOfBinaryForestNodesAtOrBelowHeight(x) = approx 1.5^(2^x).
<br>..
<br>numberOfBinaryForestNodesAtOrBelowHeight = function(h){ if(h < 0) return 0; let ret = 1; for(let i=0; i<h; i++) ret=1+ret*ret; return ret; };
<br>numberOfBinaryForestNodesAtHeight = h=>(numberOfBinaryForestNodesAtOrBelowHeight(h)-numberOfBinaryForestNodesAtOrBelowHeight(h-1));
<br>..
<br>TODO fix this for there being 2 leafs, cleanLeaf and dirtyLeaf.
<br>..
<br>All possible binary forest nodes are mapped 1-to-1 with the integers. Leaf (the universal function) is 0. (leaf leaf) is 1. (leaf (leaf leaf)) is 2. ((leaf leaf) leaf) is 3. ((leaf leaf)(leaf leaf)) is 4. (or should they start at 1 instead of 0?). And so on. Nodes are sorted first by height, then recursively by how left child is sorted, then recursively by how right child is sorted.
<br>..
<br>Every integer/binaryForestNode has its green/L and blue/R edges/arrows defined that way. Those point from integer to lower integer, except 0/leaf-green->identityFunc (identityFunc is (f leaf)) and 0/leaf-blue->0/leaf. Every integer has a red arrow, though it may take infinite time and memory to know which other integer it points at since a red arrow can say that it does not halt when called on leaf or that itself can not be derived from the universal function (such as (axa x) where (x leaf)->(leaf leaf) or w here (x leaf) does not halt). The point is, the quasicrystal is a map of integer to integer which defines the red edges, and 2 more maps of integer to integer for the green and blue edges, and maybe other edge types. Or define it as map of integer to tuple of 3 integers.
<br>
<br>Cuz of axes and number of curries and that some nodes have constraints that make them infiniteloop (by design) if called on something other than leaf or (leaf leaf) (or clean or dirty or mix of that, forms of it)... not all integers/nodes can be derived from leaf. But all are valid nodes in the quasicrystal, and thats why "isvalid" needs to be somewhere in the quasicrystal, so that a node can be in it and figure out if that node is a valid halted lambda or not (can be derived from leaf).
<br>
<br>Also, dirty lambdas (all nondeterminism goes in Wiki op, and anything higher on the stack from it) would be viewed as Wiki op is a superposition of all possible maps of integer/node to integer/node. given Any specific [function(integer)->integer] as the Wiki op, the whole system can be derived from that as another [function(integer)->integer], where some of those param integers contain a lazy call of Wiki.
<br>
It may be possible to use a graph-neuralnet andOr other kinds of AI to, given an incomplete set of edges between some nodes (blue, green, and red edges), that the neuralnet would fill in the other edges, though cuz of haltingProblem etc it might take an infinite time to converge or never converge exactly, but it would probably find some useful patterns. For example, if you told it ((curry3 Wiki "mandelbrot")#mbrot .3 .7)--red-->[some datastruct containing whats at mandelbrot fractal at position .3 .7]) and (mbrot 2.2 -3.9)--red-->[...similar...] and many other points, then such a graph-neural-net might allow you to call (mbrot 5 6.7) without it ever being trained on that, as if mbrot is a lambda function even though its just something inside the Wiki op. The Wiki op is a function to be learned, or a place to hook in plugins etc. (curry3 Wiki "mandelbrot") is that lambda, is a specific integer, has specific L/green and R/blue edges to its 2 child integers/nodes, and so on down to dirtyLeaf. Though theres actually 2 leafs, cleanLeaf and dirtyLeaf, but everything above them is clean or dirty based on is its left child (L/green) clean or dirty. If the left is clean, the right has to be clean. If the left is dirty, the right may be clean or dirty, and self is dirty.
<br>
<br>
<br>TODO fix this for there being 2 leafs, cleanLeaf and dirtyLeaf.
<br>Maybe should still use the binary forest with single leaf, but, similar to i was planning in axiomforest (see github project of that incomplete code), different kinds of universal function and different kinds of nodes in various quasicrystals could all be in the same binaryForest. The 2 Wikibinator107 leafs might be (axiomforestLeaf "Wikibinator107.cleanLeaf") and (axiomforestLeaf "Wikibinator107.dirtyLeaf"), where axiomforestLeaf (afleaf) is not a function but just a meta-quasicrystal node. (afleaf (afleaf afleaf)) and ((afleaf afleaf) afleaf) and ((afleaf afleaf)(afleaf afleaf)) could be used as bit0, bit1, and endStatement, such as (0 0 1 0 1 1 1 1 0 1 ... 0 1 endStatement), or use cbt-like way of organizing those 0 0 1 0 1 1 1 1 0 1 (utf8 bytes etc). Either way, use that to write "Wikibinator107.dirtyLeaf", so can make nodes by naming them. Basically they're like lisp tokens in a namespace that many people and systems can put lots of different stuff in. Wikibinator107 wont be able to point at things outside its own area, so wont be able to generate ids for them, but it could emulate binary forest in general such as using pairs of pairs in various combos, and generate ids of that, and could make some kind of other afleaf nodes that map between that and things outside of wikibinator107.
<br>..
<br>Various quasicrystals and other systems could be hooked together (as directedGraphs) that way.
<br>..
<br>Maybe in the whole system it should only have 3 edge types. Green and blue are shared among all of them and defined by "numberOfBinaryForestNodesAtOrBelowHeight(x)=((x==0) ? 1 : 1+numberOfBinaryForestNodesAtOrBelowHeight(x)^2)" integer/node mapping. Red edges are open-ended what they might point at, are custom to each namespace. If you want to point at multiple things, use a linkedlist of these kinds of nodes, or if you want to define sets, then choose some 2 nodes (representing a set and a thing possibly in the set) and make a datastruct whose red edge points to some representation of true vs some representation of false. More generally, this can be thought of like the hypergraphs in opencog except that its supposed to be timeless and converge to a constant and the forest be so big it includes all possible things that ever were, are, or could be, all as constants, most never observed.
<br>
<br>So 3 edge types, from every possible binary forest node with only 1 leaf. Edge types are green and blue are 2 forest childs (which means wikibinator107 will have to use derived edge types that loop around at its own cleanLeaf and dirtyLeaf cuz those are few levels above afleaf. So maybe edges should be between 3 nodes instead of 2, so can have many custom edge types, or maybe use twice as deep (in abstract math) and use a pair of nodes to say what the edges mean, and have just 3 edge types.
<br>
<br>An advantage of having exactly 3 edge types is graph-neural-net would be simpler.
<br>
<br>TODO if I'm redesigning the opcodes, bring back typeval, cleancall, and maybe a few others. Could sacrifice curry13..curry16, cuz 12 curries should be enough, or maybe increase the number of opcodes and have up to curry64???
<br>
<br>TODO create a clean fn in wikibinator108 that is a lazyEval of the question "does P equal NP?" and returns t or f,
and have graph-neural-net in the quasicrystal try to prove it or at least estimate it,
and of course you can use that fn in if/else statements like (ifElse lazyEvalOf_doesPEqualNP lazyEvalOfIfTrue lazyEvalOfIfFalse),
so if the answer to that changes (even if its just believed by whoever makes the optimizations of the quasicrystal and nobody can find a disproof of those optimizations)
then that code would automatically "fix itself" by fitting to the constraints better. Given infinity^3 (or is it infinity^2?)
time and memory the quasicrystal would probably solve it automatically, but we dont have that much compute resources.
Also create a fn that represents is collatzConjecture true or not,
and a fn for what is the BigO of matrix multiply,
and a fn for what is the BigO of integer factoring,
and a fn for proving does the debugStepInto and debugStepOver and pushEmulator and popEmulator (fns derived from axa) correctly emulate wikibinator108
and generally the system proving the correctness of the parts of the system that exist at a lower cardinality than the proof
so it cant prove the proof is correct but maybe with some strange combos of self reference a higher cardinality of lambda calls
could observe what multiple lower cardinalities of lambda calls do with eachother and give some of them higher cardinality access
by the higher cardinality lambda choosing to eval something at higher cardinality (still lower cardinality than itself)
that is a "request" from lower cardinality lambdas, something like a linkedlist
containing the words ("i request you eval this at that cardinality" evalThis requestedCardinality) and it existing in an axa statement
so that it can only be derived from other fns. Axa is how to make some kinds of turingComplete constraints,
but with cardinalities, can go beyond turingCompleteness and have doesItHalt at chosen cardinality, and have it consistently.
..........................................................................
TODO verify consistency of cardinality system, and that it can emulate the --red--> edges at
lower cardinality than itself (even if costs infinity^cardinality time and memory).
.. 
Cleaupgrade wikibinator107 (as wikibinator108) to have a unary number (such as (leaf (leaf (leaf leaf)))) is 3 and leaf is 0) for cardinality,
and have a well-defined doesItHalt opcode, along with modified fpcr (func param context ret) opcode to be fpckr (func param context cardinality ret),
and (doesItHalt x)->t or ->f depending on if at 1 lower cardinality than caller would (x leaf) halt or not.
There must be a minimum cardinality so its not possible to infiniteLoop by recursively calling doesItHalt at 1 lower cardinality than self's cardinality.
Fns dont have cardinality, but during evaling they do, similar to the third child (context, first 2 childs are l and r) exists on stack but not while halted,
except in fpckr or fpcr those contain something that would be used as context but is actually in the l and r childs,
and use you call a fpcr on leaf to trigger its lazyeval.
..........................................................................
Maybe could use dirty fns (where all nondeterminism goes) as a way to approximate the self-reference of crossing cardinalities,
but I need cardinalities to first exist in clean fns so they are guaranteed consistent, as the perfect model for dirty lambdas to
mix in some partially irrational approximations to help figure out things that cant be absolutely proven and as optimizations.
You can choose to only use the clean fns, where the math is perfect, even if the graph-neural-nets only converge toward it,
or you can use js stack interpreter to compute it exactly, or you can use dirty fns to "talk about" what might be true in higher cardinalities.
The clean fns should be enuf to derive the red edges at 1 lower cardinality than caller.
<br>
<br> TODO replace axa and axb with a 3 param ax, where its halted at 2 params (ax b c) if (b c) halts, and what does (ax b c d)->ret return?
does it return (b (pair c d))? Does it return (b c d)?
<br>
<br>Might need a few more opcodes, so replace curry13..curry16 with those.
Opcodes I might want: lazig, doesItHaltAtLowerCardinalityThanCaller, typeval, cleanCall, getCardinality (similar to getCx/getContext), callAtNextLowerCardinality.
You cant raise your own cardinality.
<br>
<br>Like theres truncateToClean, is there truncateToCardinality? Or should fpck op infloop if its cardinality is higher than current cardinality?
<br>
<br>PROBLEM: If what the red edge points at depends on cardinality the lambda call (self leaf) happens at, then theres 1 red edge per cardinality.
Should cardinality be a forest child (like l and r childs) instead of just on the stack ()like context child)?
Should nodes have an edge that points at (some prefix then) themself
but 1 cardinality lower (unless they're lowest, in which case "some prefix" would say that doesnt exist)?
Ax seems to need cardinality to be the l/r kind of child. Cardinality is a unary number like (leaf (leaf (leaf leaf))),
so that could easily be stored in the id256 up to at least cardinality 1 billion (where biz40 (low 40 bits of bitstring size) would go, since its not a bitstring).
But what happens when one cardinality is called on another? truncateToCardinality?
What should be new cardinality of what funcs return like (s x y z)->(xz(yz))?
Does it take the max cardinality of its childs, or does it take the cardinality of the caller (x)?
For example, if (x z) returns a lower cardinality than x and a lower cardinality of z, that could be a problem if (y z) keeps the max cardinality of y and z
cuz that could be bigger than the cardinality of what (x z) returns. So should the stack remember that the call started at x which is a certain cardinality?
Or should fns have to call raiseCardinality op which can only raise cardinality of param (by forkEditing it) to at most their own cardinality?
Cardinality of a fn must be at least the cardinality of each of its 3 childs (left, right, and cardinality).
The cardinality of a cardinality is always 0 since it is a unary list of (cardinality 0) leaf.
Should there still be only 2 leafs (cleanLeaf and dirtyLeaf), or should there be 2 for each cardinality?
Seems there has to be 2 for each cardinality since you need the ability to have (leaf x) for every possible x.
No clean fn can derive any dirty fn, even if the clean fn is at a very high cardinality it cant derive a dirty fn at low cardinality. It cant do that at all.
Only dirty fn can derive dirty fns and clean fns.
<br>
<br>TODO since cardinality (as unary linkedlist of leaf at cardinality 0) will be a child (like l and r)
of every halted fn (unlike context/cx exists only on stack), the whole turingComplete transfinite quasicrystal exists with only those 3 edge types,
and the red edges (what they used to be) would be proven by the existence of some combo of ax and doesItHalt at 1 higher cardinality than where the red edge is from.
You can still go up in cardinality in the quasicrystal, since theres only 1 next higher cardinality and at most 1 next lower cardinality per fn
(of the same fn but differing in cardinality, differing in size of the unary linkedlist of leaf),
and you can still go along the red edge (which goes to leaf if (self leaf) does not halt, else goes to (leaf whateverCallingSelfOnLeafReturns))
which is important for graph-neural-net to be able to navigate the quasicrystal,
but thats just a way of viewing the 3-way-forest.
Theres still the issue of can a node be derived or not (from.isvalid and to.isvalid, or just isvalid),
and for that reason, the red edges should maybe include
[from.isvalid to.isvalid doesToHalt whatDoesToReturnIfItHalts etc, as some datastruct I havent decided on yet].
The isvalid part of quasicrystal (think of it as a bit at every possible 3-way-forest node that says can it be derived from leaf of its cardinality or not)...
That seems like it could be derived at the next higher cardinality by looping over
all possible things that could be derived at next lower cardinality (dovetailing etc), and checking each for does it equal a certain node
its being asked can that be derived or not, and calling a doesItHalt on that.
That seems like it would make the whole quasicrystal self contained in the set of all 3-way-forest nodes it can derive (with 2*numcardinalities number of leafs),
including that the quasicrystal can prove that any 3-way-tree (stored as lists, since all possible lists of lists of lists...
(limited contents, cant contain lambdas that are hard to predict, just a meta data structure)...)...
the quasicrystal can compute (if you have infinity^cardinality time and memory) every node that is NOT part of the quasicrystal,
and every node that IS part of it.
<br>
<br>Based on that, TODO, create a fn that is a lazyEval that returns t or f depending on the question "are halting oracles possible?",
which of course would return f/false. A haltingOracle would be if the doesItHalt op did not require its param be at a lower cardinality than caller.
<br>
<br>TODO reduce the bitstring header size to 31 bits, so up to 2^31-1 bits (256mB),
and past that it would just have to compute bitstring size as lambda calls instead of primitive optimization of it.
It would still be a bigdata system, just have to use chunks of that max size for efficiency.
<br>
<br>TODO graph-neural-net on the quasicrystal with 3 downward edges (l r cardinality) and 1 red edge
(what does calling self on leaf return, is self valid (derivable), is what that returns valid (derivable), does calling self halt, etc),
upCardinality edge, downCardinalityOrSelfIfAlreadyMinCardinality edge, and maybe a few more edge types (isClean, isLeaf, isMinCardinality, etc).
Have graph-neural-net pattern match, similar to a RBM but far more sparse (superexponentially sparse at cardinality 0,
at least infinity times sparser per cardinality higher)... Have graph-neural-net andOr other kinds of AI fill in the directedGraph with n edge types,
from partial pattern of observing some edges but not others. Edges are only outgoing from nodes, exactly 1 edge of each type from each node, no exceptions,
which will help with the stats.
<br>
<br>Problem: If downCardinality can point at self if self is already at lower cardinality, then upCardinality is not always the inverse of downCardinality,
and the lowest cardinality clean leaf has 2 incoming edges from downCardinality: from the next higher cardinality and from itself,
so if split upCardinality into upCardinalityA and upCardinalityB, one of those can stay at that leaf and one go up,
and all other times they go the same place. Is there a simpler way to solve it?
<br>
<br>Every node in the quasicrystal will be callable as a lambda in browser console,
even if it has to mix the interpreter that uses js stack and graph-neural-net and GPU.js optimizations etc.
<br>
<br>A specific integer will be derived (stored in the compressed form of a 3-way-forest of ids)
which is the lazy-eval of "does P equal NP" that returns t or f when called on leaf,
and another specific integer for collatz conjecture, another one for "are halting oracles possible?",
another one for the BigO of matrix multiply, etc.
<br>
<br>An integer/fn will be derived that computes the kolmogorovComplexity of any param (of lower cardinality than itself),
which can be raised to any finite cardinality so can also derive the kolmogorovComplexity of itself and add just 1 hop more for the upCardinalityB edge.
The kolmogorov complexity of kolmogorov complexity will probably be somewhere between 100-1000 bits.
This function will not actually finish computing, would take infinitely long,
but may help the graph-neural-net to estimate kolmogorov-complexity of various other functions.
<br>
<br>
<br>TODO work out the details of the quasicrystal and new opcodes for wikibinator108, and define energy function of an infinite set of
"particles" which are each like a point with colored arrows outward, 1 arrow of each color, for some constant number of arrows (edge types),
each arrow pointing at the middle point of any particle (other particles or self particle),
including that it may look outward recursively to some constant depth but other than that things must be derived
from same energy function, with middle steps of lambdas being done by using ax op to derive debugStepOver, debugStepInto, pushEmulator, popEmulator, etc,
so that the quasicrystal these "particles" form into (in is it infinity^cardinality * 1.5^(2^lambdaCallHeight) but for 3-way instead of thats the 2-way forest)...
they form into all possible lambda functions including debugger breakpoints of them and ForAll and Exists statements about combos of them,
and can be called as javascript lambdas in browser console and route GPU clouds to wherever computing is needed based on realtime supply and demand
at gaming-low-lag.
<br>
<br>FIXME BIG PROBLEM!!! cant know if (ax anything) is instantly trivially halted cuz it has to check if (anything leaf) halts
to know if (ax anything) is halted. Its not a problem in the energyfunc view of the quasicrystal,
but it is a problem for knowing if you can put those together or not as javascript/java/python/etc objects millions of times per second.
Maybe its ok to have all possible 3-way-forest nodes, some of which can and some of which cant be derived (are not lambdas),
since when you go along the red edge it would tell you that, or if you look at certain bits in the node (similar to red edge, points at t or f),
would say it is or is not a valid node, and could leave "is it a valid node?" as a lazyEval???
FIXME BIG PROBLEM!!!
FIXME BIG PROBLEM!!!
FIXME BIG PROBLEM!!!
FIXME BIG PROBLEM!!!
To be a quasicrystal, every lambda call has to be done by lazyeval.
<br>
<br>FIXME BIG PROBLEM!!! Every edge needs to be a specific 3-way-forest node at same or +1 cardinality of where the edge is from,
such as a combo of ax and doesItHalt of (self leaf) at 1 higher cardinality than self, for part of the red edge from self.
It might need to be more than a 3-way-forest to include a few more edges that point at t or f, each a bit per node,
for is it cleanLeaf, is it dirtyLeaf, is it min cardinality, is it valid (deriveable), etc.
Those like l and r and cardinality are stored in id256 of a node. Others will be lazyEvaled.
UpCardinalityB and upCardinalityA and downCardinality are all derivable from the 3-way-forest,
though upCardinality* will be lazyEvaled cuz forest cant have cycles.
Red edges will be lazyEvaled.
<br>
<br>TODO redesign the "wikibinator107 interpreter using javascript stack"
(which is still incomplete (wikibinator106 passes testcases in java, and wikibinator107 passes test cases in java), but move on to as wikibinator108)...
Wikibinator108 will be graph based instead of lambda based, and converge toward the behaviors of lambdas
(and higher cardinalities such as P equals NP being a function you can call if you have infinity^3 memory and time to wait for it to finish
or maybe sooner to approximate it if graph-neural-net approximates the graph shape connecting that to other code)....
will be graph based, and will have optimizations of Uint32Array andOr Float32Array, and a powOf2 size range of them,
being pointed to by graph nodes (some of which may share the same arrays and have same or different subranges of them)
which is where it will hook into GPU.js and WebAudioAPI etc, and still be callable as lambdas in browser console.
The difference is, not every node is a lambda, but you can tell if its a halted lambda by isvalid is true.
There are no nodes which represent nonhalted lambdas.
<br>
<br>gasMem pays in one server to increase recursiveExpireTime of a node (which must expire before all its childs),
and gasTime pays to cross the lazyevaled edges (red, isvalid, upCardinalityA, upcardinalityB, etc),
in thousands of greenthreads per computer.
<br>
<br>
<br>
<br>
<br>



<canvas id="canvasIn" width=640 height=640 style="visibility:hidden"></canvas>
<div id="my_camera" style="visibility:hidden"
></div>
<div id="results" style="width:320px;height:240px;border:1px solid black;"></div>




</body></html>